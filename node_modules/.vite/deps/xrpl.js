import {
  __commonJS
} from "./chunk-4MBMRILA.js";

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XRPLFaucetError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.RippledNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.RippledError = exports.ConnectionError = exports.UnexpectedError = exports.XrplError = void 0;
    var XrplError = class extends Error {
      constructor(message = "", data) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace != null) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      toString() {
        let result = `[${this.name}(${this.message}`;
        if (this.data) {
          result += `, ${JSON.stringify(this.data)}`;
        }
        result += ")]";
        return result;
      }
      inspect() {
        return this.toString();
      }
    };
    exports.XrplError = XrplError;
    var RippledError = class extends XrplError {
    };
    exports.RippledError = RippledError;
    var UnexpectedError = class extends XrplError {
    };
    exports.UnexpectedError = UnexpectedError;
    var ConnectionError = class extends XrplError {
    };
    exports.ConnectionError = ConnectionError;
    var NotConnectedError = class extends ConnectionError {
    };
    exports.NotConnectedError = NotConnectedError;
    var DisconnectedError = class extends ConnectionError {
    };
    exports.DisconnectedError = DisconnectedError;
    var RippledNotInitializedError = class extends ConnectionError {
    };
    exports.RippledNotInitializedError = RippledNotInitializedError;
    var TimeoutError = class extends ConnectionError {
    };
    exports.TimeoutError = TimeoutError;
    var ResponseFormatError = class extends ConnectionError {
    };
    exports.ResponseFormatError = ResponseFormatError;
    var ValidationError = class extends XrplError {
    };
    exports.ValidationError = ValidationError;
    var XRPLFaucetError = class extends XrplError {
    };
    exports.XRPLFaucetError = XRPLFaucetError;
    var NotFoundError = class extends XrplError {
      constructor(message = "Not found") {
        super(message);
      }
    };
    exports.NotFoundError = NotFoundError;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/common/index.js
var require_common = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/common/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2 = exports.RIPPLED_API_V1 = void 0;
    exports.RIPPLED_API_V1 = 1;
    exports.RIPPLED_API_V2 = 2;
    exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js
var require_AccountRoot = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountRootFlags = void 0;
    var AccountRootFlags;
    (function(AccountRootFlags2) {
      AccountRootFlags2[AccountRootFlags2["lsfPasswordSpent"] = 65536] = "lsfPasswordSpent";
      AccountRootFlags2[AccountRootFlags2["lsfRequireDestTag"] = 131072] = "lsfRequireDestTag";
      AccountRootFlags2[AccountRootFlags2["lsfRequireAuth"] = 262144] = "lsfRequireAuth";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowXRP"] = 524288] = "lsfDisallowXRP";
      AccountRootFlags2[AccountRootFlags2["lsfDisableMaster"] = 1048576] = "lsfDisableMaster";
      AccountRootFlags2[AccountRootFlags2["lsfNoFreeze"] = 2097152] = "lsfNoFreeze";
      AccountRootFlags2[AccountRootFlags2["lsfGlobalFreeze"] = 4194304] = "lsfGlobalFreeze";
      AccountRootFlags2[AccountRootFlags2["lsfDefaultRipple"] = 8388608] = "lsfDefaultRipple";
      AccountRootFlags2[AccountRootFlags2["lsfDepositAuth"] = 16777216] = "lsfDepositAuth";
      AccountRootFlags2[AccountRootFlags2["lsfAMM"] = 33554432] = "lsfAMM";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingNFTokenOffer"] = 67108864] = "lsfDisallowIncomingNFTokenOffer";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingCheck"] = 134217728] = "lsfDisallowIncomingCheck";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingPayChan"] = 268435456] = "lsfDisallowIncomingPayChan";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingTrustline"] = 536870912] = "lsfDisallowIncomingTrustline";
      AccountRootFlags2[AccountRootFlags2["lsfAllowTrustLineClawback"] = 2147483648] = "lsfAllowTrustLineClawback";
    })(AccountRootFlags || (exports.AccountRootFlags = AccountRootFlags = {}));
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/utils/shared.js
var require_shared = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/utils/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.equal = exports.concat = exports.HEX_REGEX = void 0;
    var utils_1 = require_utils();
    exports.HEX_REGEX = /^[A-F0-9]*$/iu;
    function concat(views) {
      return (0, utils_1.concatBytes)(...views);
    }
    exports.concat = concat;
    function equal(buf1, buf2) {
      if (buf1.byteLength !== buf2.byteLength) {
        return false;
      }
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i !== buf1.byteLength; i++) {
        if (dv1[i] !== dv2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equal = equal;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/utils/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/utils/browser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.stringToHex = exports.hexToString = exports.hexToBytes = exports.bytesToHex = void 0;
    var utils_1 = require_utils();
    var shared_1 = require_shared();
    var bytesToHex = (bytes) => {
      const hex = (0, utils_1.bytesToHex)(bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes));
      return hex.toUpperCase();
    };
    exports.bytesToHex = bytesToHex;
    var hexToBytes = (hex) => {
      const len = hex.length;
      const array = new Uint8Array(len / 2);
      if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error("Invalid hex string");
      }
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) {
          throw new Error("Invalid byte sequence");
        }
        array[i] = byte;
      }
      return array;
    };
    exports.hexToBytes = hexToBytes;
    var hexToString = (hex, encoding = "utf8") => {
      return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));
    };
    exports.hexToString = hexToString;
    var stringToHex = (string) => {
      return (0, exports.bytesToHex)(new TextEncoder().encode(string));
    };
    exports.stringToHex = stringToHex;
    exports.randomBytes = utils_1.randomBytes;
    __exportStar(require_shared(), exports);
  }
});

// node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function isArrayOf(isString, arr) {
      if (!Array.isArray(arr))
        return false;
      if (arr.length === 0)
        return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function afn(input) {
      if (typeof input !== "function")
        throw new Error("function expected");
      return true;
    }
    function astr(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
    }
    function aArr(input) {
      if (!Array.isArray(input))
        throw new Error("array expected");
    }
    function astrArr(label, input) {
      if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr(label, input) {
      if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    function chain(...args) {
      const id = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode = args.map((x) => x.encode).reduceRight(wrap, id);
      const decode = args.map((x) => x.decode).reduce(wrap, id);
      return { encode, decode };
    }
    function alphabet(letters) {
      const lettersA = typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l, i) => [l, i]));
      return {
        encode: (digits) => {
          aArr(digits);
          return digits.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= len)
              throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
            return lettersA[i];
          });
        },
        decode: (input) => {
          aArr(input);
          return input.map((letter) => {
            astr("alphabet.decode", letter);
            const i = indexes.get(letter);
            if (i === void 0)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
            return i;
          });
        }
      };
    }
    function join(separator = "") {
      astr("join", separator);
      return {
        encode: (from) => {
          astrArr("join.decode", from);
          return from.join(separator);
        },
        decode: (to) => {
          astr("join.decode", to);
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      anumber(bits);
      astr("padding", chr);
      return {
        encode(data) {
          astrArr("padding.encode", data);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          astrArr("padding.decode", input);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("padding: invalid, string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            const last = end - 1;
            const byte = last * bits;
            if (byte % 8 === 0)
              throw new Error("padding: invalid, string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize(fn) {
      afn(fn);
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
      aArr(data);
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
          throw new Error(`invalid integer: ${d}`);
        return d;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
          const digit = digits[i];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit;
          if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to;
          carry = digitBase % to;
          const rounded = Math.floor(div);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    var radix2carry = (from, to) => from + (to - gcd(from, to));
    var powers = (() => {
      let res = [];
      for (let i = 0; i < 40; i++)
        res.push(2 ** i);
      return res;
    })();
    function convertRadix2(data, from, to, padding2) {
      aArr(data);
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const max = powers[from];
      const mask = powers[to] - 1;
      const res = [];
      for (const n of data) {
        anumber(n);
        if (n >= max)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === void 0)
          throw new Error("invalid carry");
        carry &= pow - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num) {
      anumber(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
          anumArr("radix.decode", digits);
          return Uint8Array.from(convertRadix(digits, num, _256));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      anumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          anumArr("radix2.decode", digits);
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      afn(fn);
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      anumber(len);
      afn(fn);
      return {
        encode(data) {
          if (!isBytes(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const sum = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(sum, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const oldChecksum = data.slice(-len);
          const newChecksum = fn(payload).slice(0, len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    exports.base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
    exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    exports.base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
    exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    var decodeBase64Builtin = (s, isUrl) => {
      astr("base64", s);
      const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet2 = isUrl ? "base64url" : "base64";
      if (s.length > 0 && !re.test(s))
        throw new Error("invalid base64");
      return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
    };
    exports.base64 = hasBase64Builtin ? {
      encode(b) {
        abytes(b);
        return b.toBase64();
      },
      decode(s) {
        return decodeBase64Builtin(s, false);
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    exports.base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
    exports.base64url = hasBase64Builtin ? {
      encode(b) {
        abytes(b);
        return b.toBase64({ alphabet: "base64url" });
      },
      decode(s) {
        return decodeBase64Builtin(s, true);
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
    exports.createBase58check = createBase58check;
    exports.base58check = exports.createBase58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if ((b >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode(prefix, words, limit = 90) {
        astr("bech32.encode prefix", prefix);
        if (isBytes(words))
          words = Array.from(words);
        anumArr("bech32.encode", words);
        const plen = prefix.length;
        if (plen === 0)
          throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode(str, limit = 90) {
        astr("bech32.decode input", str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit)
          throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode);
      function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
      }
      return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
      };
    }
    exports.bech32 = genBech32("bech32");
    exports.bech32m = genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
    var hexBuiltin = {
      encode(data) {
        abytes(data);
        return data.toHex();
      },
      decode(s) {
        astr("hex", s);
        return Uint8Array.fromHex(s);
      }
    };
    exports.hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
      if (typeof s !== "string" || s.length % 2 !== 0)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes(bytes))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports.HashMD = HashMD;
    exports.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
    exports.add = add;
    exports.fromBig = fromBig;
    exports.split = split;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports.SHA224 = SHA224;
    var K512 = (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh = (() => K512[0])();
    var SHA512_Kl = (() => K512[1])();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports.SHA384 = SHA384;
    var T224_IV = Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports.SHA512_256 = SHA512_256;
    exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
    var sha2_ts_1 = require_sha2();
    exports.SHA256 = sha2_ts_1.SHA256;
    exports.sha256 = sha2_ts_1.sha256;
    exports.SHA224 = sha2_ts_1.SHA224;
    exports.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js
var require_normalizeInput = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeInput(input) {
      return Array.isArray(input) ? new Uint8Array(input) : input;
    }
    exports.default = normalizeInput;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/internal/wrapNoble.js
var require_wrapNoble = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/internal/wrapNoble.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var normalizeInput_1 = __importDefault(require_normalizeInput());
    function wrapNoble(chash) {
      function wrapped(input) {
        return chash((0, normalizeInput_1.default)(input));
      }
      wrapped.create = () => {
        const hash = chash.create();
        return {
          update(input) {
            hash.update((0, normalizeInput_1.default)(input));
            return this;
          },
          digest() {
            return hash.digest();
          }
        };
      };
      return wrapped;
    }
    exports.default = wrapNoble;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/sha256/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/sha256/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var sha256_1 = require_sha256();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.sha256 = (0, wrapNoble_1.default)(sha256_1.sha256);
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatArgs = exports.arrayEqual = void 0;
    function arrayEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      return arr1.every((value, index) => value === arr2[index]);
    }
    exports.arrayEqual = arrayEqual;
    function isScalar(val) {
      return typeof val === "number";
    }
    function concatArgs(...args) {
      return args.flatMap((arg) => {
        return isScalar(arg) ? [arg] : Array.from(arg);
      });
    }
    exports.concatArgs = concatArgs;
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/xrp-codec.js
var require_xrp_codec = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/xrp-codec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var base_1 = require_lib();
    var sha256_1 = require_browser2();
    var utils_1 = require_utils2();
    var Codec = class {
      constructor(options) {
        this._sha256 = options.sha256;
        this._codec = base_1.base58xrp;
      }
      /**
       * Encoder.
       *
       * @param bytes - Uint8Array of data to encode.
       * @param opts - Options object including the version bytes and the expected length of the data to encode.
       */
      encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
      }
      /**
       * Decoder.
       *
       * @param base58string - Base58Check-encoded string to decode.
       * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
       */
      /* eslint-disable max-lines-per-function --
       * TODO refactor */
      decode(base58string, opts) {
        var _a;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
          throw new Error("expectedLength is required because there are >= 2 possible versions");
        }
        const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
          const version = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
          if ((0, utils_1.arrayEqual)(versionBytes, version)) {
            return {
              version,
              bytes: payload,
              type: types ? types[i] : null
            };
          }
        }
        throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
      }
      encodeChecked(bytes) {
        const check = this._sha256(this._sha256(bytes)).slice(0, 4);
        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));
      }
      decodeChecked(base58string) {
        const intArray = this._decodeRaw(base58string);
        if (intArray.byteLength < 5) {
          throw new Error("invalid_input_size: decoded data must have length >= 5");
        }
        if (!this._verifyCheckSum(intArray)) {
          throw new Error("checksum_invalid");
        }
        return intArray.slice(0, -4);
      }
      _encodeVersioned(bytes, versions, expectedLength) {
        if (!checkByteLength(bytes, expectedLength)) {
          throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Uint8Array.");
        }
        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));
      }
      _encodeRaw(bytes) {
        return this._codec.encode(Uint8Array.from(bytes));
      }
      /* eslint-enable max-lines-per-function */
      _decodeRaw(base58string) {
        return this._codec.decode(base58string);
      }
      _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.arrayEqual)(computed, checksum);
      }
    };
    var ACCOUNT_ID = 0;
    var ACCOUNT_PUBLIC_KEY = 35;
    var FAMILY_SEED = 33;
    var NODE_PUBLIC = 28;
    var ED25519_SEED = [1, 225, 75];
    var codecOptions = {
      sha256: sha256_1.sha256
    };
    var codecWithXrpAlphabet = new Codec(codecOptions);
    exports.codec = codecWithXrpAlphabet;
    function encodeSeed(entropy, type) {
      if (!checkByteLength(entropy, 16)) {
        throw new Error("entropy must have length 16");
      }
      const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
      };
      return codecWithXrpAlphabet.encode(entropy, opts);
    }
    exports.encodeSeed = encodeSeed;
    function decodeSeed(seed, opts = {
      versionTypes: ["ed25519", "secp256k1"],
      versions: [ED25519_SEED, FAMILY_SEED],
      expectedLength: 16
    }) {
      return codecWithXrpAlphabet.decode(seed, opts);
    }
    exports.decodeSeed = decodeSeed;
    function encodeAccountID(bytes) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountID = encodeAccountID;
    exports.encodeAddress = encodeAccountID;
    function decodeAccountID(accountId) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.decode(accountId, opts).bytes;
    }
    exports.decodeAccountID = decodeAccountID;
    exports.decodeAddress = decodeAccountID;
    function decodeNodePublic(base58string) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeNodePublic = decodeNodePublic;
    function encodeNodePublic(bytes) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeNodePublic = encodeNodePublic;
    function encodeAccountPublic(bytes) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountPublic = encodeAccountPublic;
    function decodeAccountPublic(base58string) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeAccountPublic = decodeAccountPublic;
    function isValidClassicAddress(address) {
      try {
        decodeAccountID(address);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidClassicAddress = isValidClassicAddress;
    function checkByteLength(bytes, expectedLength) {
      return "byteLength" in bytes ? bytes.byteLength === expectedLength : bytes.length === expectedLength;
    }
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0/node_modules/ripple-address-codec/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var utils_1 = require_browser();
    var xrp_codec_1 = require_xrp_codec();
    Object.defineProperty(exports, "codec", { enumerable: true, get: function() {
      return xrp_codec_1.codec;
    } });
    Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.encodeSeed;
    } });
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.decodeSeed;
    } });
    Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountID;
    } });
    Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountID;
    } });
    Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeNodePublic;
    } });
    Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeNodePublic;
    } });
    Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountPublic;
    } });
    Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountPublic;
    } });
    Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
      return xrp_codec_1.isValidClassicAddress;
    } });
    var PREFIX_BYTES = {
      // 5, 68
      main: Uint8Array.from([5, 68]),
      // 4, 147
      test: Uint8Array.from([4, 147])
    };
    var MAX_32_BIT_UNSIGNED_INT = 4294967295;
    function classicAddressToXAddress(classicAddress, tag, test) {
      const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
      return encodeXAddress(accountId, tag, test);
    }
    exports.classicAddressToXAddress = classicAddressToXAddress;
    function encodeXAddress(accountId, tag, test) {
      if (accountId.length !== 20) {
        throw new Error("Account ID must be 20 bytes");
      }
      if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error("Invalid tag");
      }
      const theTag = tag || 0;
      const flag = tag === false || tag == null ? 0 : 1;
      const bytes = (0, utils_1.concat)([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Uint8Array.from([
          // 0x00 if no tag, 0x01 if 32-bit tag
          flag,
          // first byte
          theTag & 255,
          // second byte
          theTag >> 8 & 255,
          // third byte
          theTag >> 16 & 255,
          // fourth byte
          theTag >> 24 & 255,
          0,
          0,
          0,
          // four zero bytes (reserved for 64-bit tags)
          0
        ])
      ]);
      return xrp_codec_1.codec.encodeChecked(bytes);
    }
    exports.encodeXAddress = encodeXAddress;
    function xAddressToClassicAddress(xAddress) {
      const { accountId, tag, test } = decodeXAddress(xAddress);
      const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
      return {
        classicAddress,
        tag,
        test
      };
    }
    exports.xAddressToClassicAddress = xAddressToClassicAddress;
    function decodeXAddress(xAddress) {
      const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
      const test = isUint8ArrayForTestAddress(decoded);
      const accountId = decoded.slice(2, 22);
      const tag = tagFromUint8Array(decoded);
      return {
        accountId,
        tag,
        test
      };
    }
    exports.decodeXAddress = decodeXAddress;
    function isUint8ArrayForTestAddress(buf) {
      const decodedPrefix = buf.slice(0, 2);
      if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {
        return false;
      }
      if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {
        return true;
      }
      throw new Error("Invalid X-address: bad prefix");
    }
    function tagFromUint8Array(buf) {
      const flag = buf[22];
      if (flag >= 2) {
        throw new Error("Unsupported X-address");
      }
      if (flag === 1) {
        return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
      }
      if (flag !== 0) {
        throw new Error("flag must be zero to indicate no tag");
      }
      if (!(0, utils_1.equal)((0, utils_1.hexToBytes)("0000000000000000"), buf.slice(23, 23 + 8))) {
        throw new Error("remaining bytes must be zero");
      }
      return false;
    }
    function isValidXAddress(xAddress) {
      try {
        decodeXAddress(xAddress);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidXAddress = isValidXAddress;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/definitions.json
var require_definitions = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/definitions.json"(exports, module) {
    module.exports = {
      FIELDS: [
        [
          "Generic",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 0,
            type: "Unknown"
          }
        ],
        [
          "Invalid",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: -1,
            type: "Unknown"
          }
        ],
        [
          "ObjectEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STObject"
          }
        ],
        [
          "ArrayEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STArray"
          }
        ],
        [
          "taker_gets_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Amount"
          }
        ],
        [
          "taker_pays_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 259,
            type: "Amount"
          }
        ],
        [
          "LedgerEntryType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt16"
          }
        ],
        [
          "TransactionType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt16"
          }
        ],
        [
          "SignerWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt16"
          }
        ],
        [
          "TransferFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt16"
          }
        ],
        [
          "TradingFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt16"
          }
        ],
        [
          "DiscountedFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt16"
          }
        ],
        [
          "Version",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt16"
          }
        ],
        [
          "HookStateChangeCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt16"
          }
        ],
        [
          "HookEmitCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt16"
          }
        ],
        [
          "HookExecutionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt16"
          }
        ],
        [
          "HookApiVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt16"
          }
        ],
        [
          "LedgerFixType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt16"
          }
        ],
        [
          "NetworkID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt32"
          }
        ],
        [
          "Flags",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt32"
          }
        ],
        [
          "SourceTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt32"
          }
        ],
        [
          "Sequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt32"
          }
        ],
        [
          "PreviousTxnLgrSeq",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt32"
          }
        ],
        [
          "LedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt32"
          }
        ],
        [
          "CloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt32"
          }
        ],
        [
          "ParentCloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt32"
          }
        ],
        [
          "SigningTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt32"
          }
        ],
        [
          "Expiration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt32"
          }
        ],
        [
          "TransferRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt32"
          }
        ],
        [
          "WalletSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt32"
          }
        ],
        [
          "OwnerCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt32"
          }
        ],
        [
          "DestinationTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "UInt32"
          }
        ],
        [
          "LastUpdateTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "UInt32"
          }
        ],
        [
          "HighQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt32"
          }
        ],
        [
          "HighQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt32"
          }
        ],
        [
          "LowQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt32"
          }
        ],
        [
          "LowQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt32"
          }
        ],
        [
          "QualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt32"
          }
        ],
        [
          "QualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt32"
          }
        ],
        [
          "StampEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt32"
          }
        ],
        [
          "BondAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt32"
          }
        ],
        [
          "LoadFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt32"
          }
        ],
        [
          "OfferSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt32"
          }
        ],
        [
          "FirstLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt32"
          }
        ],
        [
          "LastLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "UInt32"
          }
        ],
        [
          "TransactionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "UInt32"
          }
        ],
        [
          "OperationLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "UInt32"
          }
        ],
        [
          "ReferenceFeeUnits",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "UInt32"
          }
        ],
        [
          "ReserveBase",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "UInt32"
          }
        ],
        [
          "ReserveIncrement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "UInt32"
          }
        ],
        [
          "SetFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "UInt32"
          }
        ],
        [
          "ClearFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "UInt32"
          }
        ],
        [
          "SignerQuorum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "UInt32"
          }
        ],
        [
          "CancelAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "UInt32"
          }
        ],
        [
          "FinishAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 37,
            type: "UInt32"
          }
        ],
        [
          "SignerListID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 38,
            type: "UInt32"
          }
        ],
        [
          "SettleDelay",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 39,
            type: "UInt32"
          }
        ],
        [
          "TicketCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 40,
            type: "UInt32"
          }
        ],
        [
          "TicketSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 41,
            type: "UInt32"
          }
        ],
        [
          "NFTokenTaxon",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 42,
            type: "UInt32"
          }
        ],
        [
          "MintedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 43,
            type: "UInt32"
          }
        ],
        [
          "BurnedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 44,
            type: "UInt32"
          }
        ],
        [
          "HookStateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 45,
            type: "UInt32"
          }
        ],
        [
          "EmitGeneration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 46,
            type: "UInt32"
          }
        ],
        [
          "VoteWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 48,
            type: "UInt32"
          }
        ],
        [
          "FirstNFTokenSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 50,
            type: "UInt32"
          }
        ],
        [
          "OracleDocumentID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 51,
            type: "UInt32"
          }
        ],
        [
          "IndexNext",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt64"
          }
        ],
        [
          "IndexPrevious",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt64"
          }
        ],
        [
          "BookNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt64"
          }
        ],
        [
          "OwnerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt64"
          }
        ],
        [
          "BaseFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt64"
          }
        ],
        [
          "ExchangeRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt64"
          }
        ],
        [
          "LowNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt64"
          }
        ],
        [
          "HighNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt64"
          }
        ],
        [
          "DestinationNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt64"
          }
        ],
        [
          "Cookie",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt64"
          }
        ],
        [
          "ServerVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt64"
          }
        ],
        [
          "NFTokenOfferNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt64"
          }
        ],
        [
          "EmitBurden",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt64"
          }
        ],
        [
          "HookOn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt64"
          }
        ],
        [
          "HookInstructionCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt64"
          }
        ],
        [
          "HookReturnCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt64"
          }
        ],
        [
          "ReferenceCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt64"
          }
        ],
        [
          "XChainClaimID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountCreateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountClaimCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt64"
          }
        ],
        [
          "AssetPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt64"
          }
        ],
        [
          "MaximumAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt64"
          }
        ],
        [
          "OutstandingAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt64"
          }
        ],
        [
          "MPTAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt64"
          }
        ],
        [
          "IssuerNode",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "SubjectNode",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "EmailHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash128"
          }
        ],
        [
          "LedgerHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash256"
          }
        ],
        [
          "ParentHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash256"
          }
        ],
        [
          "TransactionHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash256"
          }
        ],
        [
          "AccountHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash256"
          }
        ],
        [
          "PreviousTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Hash256"
          }
        ],
        [
          "LedgerIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Hash256"
          }
        ],
        [
          "WalletLocator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Hash256"
          }
        ],
        [
          "RootIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Hash256"
          }
        ],
        [
          "AccountTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Hash256"
          }
        ],
        [
          "NFTokenID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Hash256"
          }
        ],
        [
          "EmitParentTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Hash256"
          }
        ],
        [
          "EmitNonce",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Hash256"
          }
        ],
        [
          "EmitHookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Hash256"
          }
        ],
        [
          "AMMID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "Hash256"
          }
        ],
        [
          "BookDirectory",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Hash256"
          }
        ],
        [
          "InvoiceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Hash256"
          }
        ],
        [
          "Nickname",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Hash256"
          }
        ],
        [
          "Amendment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Hash256"
          }
        ],
        [
          "Digest",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "Hash256"
          }
        ],
        [
          "Channel",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Hash256"
          }
        ],
        [
          "ConsensusHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Hash256"
          }
        ],
        [
          "CheckID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Hash256"
          }
        ],
        [
          "ValidatedHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Hash256"
          }
        ],
        [
          "PreviousPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Hash256"
          }
        ],
        [
          "NextPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Hash256"
          }
        ],
        [
          "NFTokenBuyOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Hash256"
          }
        ],
        [
          "NFTokenSellOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Hash256"
          }
        ],
        [
          "HookStateKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Hash256"
          }
        ],
        [
          "HookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Hash256"
          }
        ],
        [
          "HookNamespace",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "Hash256"
          }
        ],
        [
          "HookSetTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "Hash256"
          }
        ],
        [
          "DomainID",
          {
            nth: 34,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "hash",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Hash256"
          }
        ],
        [
          "index",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Hash256"
          }
        ],
        [
          "Amount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Amount"
          }
        ],
        [
          "Balance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Amount"
          }
        ],
        [
          "LimitAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Amount"
          }
        ],
        [
          "TakerPays",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Amount"
          }
        ],
        [
          "TakerGets",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Amount"
          }
        ],
        [
          "LowLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Amount"
          }
        ],
        [
          "HighLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Amount"
          }
        ],
        [
          "Fee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Amount"
          }
        ],
        [
          "SendMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Amount"
          }
        ],
        [
          "DeliverMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Amount"
          }
        ],
        [
          "Amount2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Amount"
          }
        ],
        [
          "BidMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Amount"
          }
        ],
        [
          "BidMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Amount"
          }
        ],
        [
          "MinimumOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Amount"
          }
        ],
        [
          "RippleEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Amount"
          }
        ],
        [
          "DeliveredAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Amount"
          }
        ],
        [
          "NFTokenBrokerFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Amount"
          }
        ],
        [
          "BaseFeeDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Amount"
          }
        ],
        [
          "ReserveBaseDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Amount"
          }
        ],
        [
          "ReserveIncrementDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Amount"
          }
        ],
        [
          "LPTokenOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Amount"
          }
        ],
        [
          "LPTokenIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Amount"
          }
        ],
        [
          "EPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Amount"
          }
        ],
        [
          "Price",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Amount"
          }
        ],
        [
          "SignatureReward",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Amount"
          }
        ],
        [
          "MinAccountCreateAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Amount"
          }
        ],
        [
          "LPTokenBalance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Amount"
          }
        ],
        [
          "PublicKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Blob"
          }
        ],
        [
          "MessageKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Blob"
          }
        ],
        [
          "SigningPubKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Blob"
          }
        ],
        [
          "TxnSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 4,
            type: "Blob"
          }
        ],
        [
          "URI",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "Blob"
          }
        ],
        [
          "Signature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 6,
            type: "Blob"
          }
        ],
        [
          "Domain",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 7,
            type: "Blob"
          }
        ],
        [
          "FundCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "Blob"
          }
        ],
        [
          "RemoveCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "Blob"
          }
        ],
        [
          "ExpireCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "Blob"
          }
        ],
        [
          "CreateCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "Blob"
          }
        ],
        [
          "MemoType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 12,
            type: "Blob"
          }
        ],
        [
          "MemoData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 13,
            type: "Blob"
          }
        ],
        [
          "MemoFormat",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 14,
            type: "Blob"
          }
        ],
        [
          "Fulfillment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "Blob"
          }
        ],
        [
          "Condition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 17,
            type: "Blob"
          }
        ],
        [
          "MasterSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 18,
            type: "Blob"
          }
        ],
        [
          "UNLModifyValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "Blob"
          }
        ],
        [
          "ValidatorToDisable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "Blob"
          }
        ],
        [
          "ValidatorToReEnable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "Blob"
          }
        ],
        [
          "HookStateData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "Blob"
          }
        ],
        [
          "HookReturnString",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "Blob"
          }
        ],
        [
          "HookParameterName",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 24,
            type: "Blob"
          }
        ],
        [
          "HookParameterValue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 25,
            type: "Blob"
          }
        ],
        [
          "DIDDocument",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 26,
            type: "Blob"
          }
        ],
        [
          "Data",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 27,
            type: "Blob"
          }
        ],
        [
          "AssetClass",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 28,
            type: "Blob"
          }
        ],
        [
          "Provider",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 29,
            type: "Blob"
          }
        ],
        [
          "MPTokenMetadata",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 30,
            type: "Blob"
          }
        ],
        [
          "CredentialType",
          {
            nth: 31,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Account",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "AccountID"
          }
        ],
        [
          "Owner",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "AccountID"
          }
        ],
        [
          "Destination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "AccountID"
          }
        ],
        [
          "Issuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "AccountID"
          }
        ],
        [
          "Authorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "AccountID"
          }
        ],
        [
          "Unauthorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 6,
            type: "AccountID"
          }
        ],
        [
          "RegularKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "AccountID"
          }
        ],
        [
          "NFTokenMinter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "AccountID"
          }
        ],
        [
          "EmitCallback",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "AccountID"
          }
        ],
        [
          "Holder",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "AccountID"
          }
        ],
        [
          "HookAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "AccountID"
          }
        ],
        [
          "OtherChainSource",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 18,
            type: "AccountID"
          }
        ],
        [
          "OtherChainDestination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "AccountID"
          }
        ],
        [
          "AttestationSignerAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "AccountID"
          }
        ],
        [
          "AttestationRewardAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "AccountID"
          }
        ],
        [
          "LockingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "AccountID"
          }
        ],
        [
          "IssuingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "AccountID"
          }
        ],
        [
          "Subject",
          {
            nth: 24,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "TransactionMetaData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "STObject"
          }
        ],
        [
          "CreatedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "STObject"
          }
        ],
        [
          "DeletedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STObject"
          }
        ],
        [
          "ModifiedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STObject"
          }
        ],
        [
          "PreviousFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STObject"
          }
        ],
        [
          "FinalFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STObject"
          }
        ],
        [
          "NewFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STObject"
          }
        ],
        [
          "TemplateEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STObject"
          }
        ],
        [
          "Memo",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STObject"
          }
        ],
        [
          "SignerEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STObject"
          }
        ],
        [
          "NFToken",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STObject"
          }
        ],
        [
          "EmitDetails",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "STObject"
          }
        ],
        [
          "Hook",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "STObject"
          }
        ],
        [
          "Signer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STObject"
          }
        ],
        [
          "Majority",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STObject"
          }
        ],
        [
          "DisabledValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STObject"
          }
        ],
        [
          "EmittedTxn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STObject"
          }
        ],
        [
          "HookExecution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STObject"
          }
        ],
        [
          "HookDefinition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STObject"
          }
        ],
        [
          "HookParameter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "STObject"
          }
        ],
        [
          "HookGrant",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STObject"
          }
        ],
        [
          "VoteEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STObject"
          }
        ],
        [
          "AuctionSlot",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "STObject"
          }
        ],
        [
          "AuthAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "STObject"
          }
        ],
        [
          "XChainClaimProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "STObject"
          }
        ],
        [
          "XChainClaimAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "STObject"
          }
        ],
        [
          "PriceData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "STObject"
          }
        ],
        [
          "Credential",
          {
            nth: 33,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Signers",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 3,
            type: "STArray"
          }
        ],
        [
          "SignerEntries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STArray"
          }
        ],
        [
          "Template",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STArray"
          }
        ],
        [
          "Necessary",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STArray"
          }
        ],
        [
          "Sufficient",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STArray"
          }
        ],
        [
          "AffectedNodes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STArray"
          }
        ],
        [
          "Memos",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STArray"
          }
        ],
        [
          "NFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STArray"
          }
        ],
        [
          "Hooks",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STArray"
          }
        ],
        [
          "VoteSlots",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STArray"
          }
        ],
        [
          "Majorities",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STArray"
          }
        ],
        [
          "DisabledValidators",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "STArray"
          }
        ],
        [
          "HookExecutions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STArray"
          }
        ],
        [
          "HookParameters",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STArray"
          }
        ],
        [
          "HookGrants",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STArray"
          }
        ],
        [
          "XChainClaimAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STArray"
          }
        ],
        [
          "XChainCreateAccountAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STArray"
          }
        ],
        [
          "PriceDataSeries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STArray"
          }
        ],
        [
          "AuthAccounts",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STArray"
          }
        ],
        [
          "AuthorizeCredentials",
          {
            nth: 26,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "UnauthorizeCredentials",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "AcceptedCredentials",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "CloseResolution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt8"
          }
        ],
        [
          "Method",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt8"
          }
        ],
        [
          "TransactionResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt8"
          }
        ],
        [
          "Scale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt8"
          }
        ],
        [
          "AssetScale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt8"
          }
        ],
        [
          "TickSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt8"
          }
        ],
        [
          "UNLModifyDisabling",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt8"
          }
        ],
        [
          "HookResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt8"
          }
        ],
        [
          "WasLockingChainSend",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt8"
          }
        ],
        [
          "TakerPaysCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash160"
          }
        ],
        [
          "TakerPaysIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash160"
          }
        ],
        [
          "Paths",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "PathSet"
          }
        ],
        [
          "Indexes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Vector256"
          }
        ],
        [
          "Hashes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Vector256"
          }
        ],
        [
          "Amendments",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Vector256"
          }
        ],
        [
          "NFTokenOffers",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "Vector256"
          }
        ],
        [
          "CredentialIDs",
          {
            nth: 5,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Vector256"
          }
        ],
        [
          "MPTokenIssuanceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash192"
          }
        ],
        [
          "LockingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Issue"
          }
        ],
        [
          "IssuingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Issue"
          }
        ],
        [
          "Asset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Issue"
          }
        ],
        [
          "Asset2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Issue"
          }
        ],
        [
          "XChainBridge",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "XChainBridge"
          }
        ],
        [
          "BaseAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Currency"
          }
        ],
        [
          "QuoteAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Currency"
          }
        ],
        [
          "Transaction",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Transaction"
          }
        ],
        [
          "LedgerEntry",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "LedgerEntry"
          }
        ],
        [
          "Validation",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Validation"
          }
        ],
        [
          "Metadata",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Metadata"
          }
        ]
      ],
      LEDGER_ENTRY_TYPES: {
        AMM: 121,
        AccountRoot: 97,
        Amendments: 102,
        Bridge: 105,
        Check: 67,
        DID: 73,
        DepositPreauth: 112,
        DirectoryNode: 100,
        Escrow: 117,
        FeeSettings: 115,
        Invalid: -1,
        LedgerHashes: 104,
        MPToken: 127,
        MPTokenIssuance: 126,
        NFTokenOffer: 55,
        NFTokenPage: 80,
        NegativeUNL: 78,
        Offer: 111,
        Oracle: 128,
        Credential: 129,
        PayChannel: 120,
        PermissionedDomain: 130,
        RippleState: 114,
        SignerList: 83,
        Ticket: 84,
        XChainOwnedClaimID: 113,
        XChainOwnedCreateAccountClaimID: 116
      },
      TRANSACTION_RESULTS: {
        tecAMM_ACCOUNT: 168,
        tecAMM_BALANCE: 163,
        tecAMM_EMPTY: 166,
        tecAMM_FAILED: 164,
        tecAMM_INVALID_TOKENS: 165,
        tecAMM_NOT_EMPTY: 167,
        tecARRAY_EMPTY: 190,
        tecARRAY_TOO_LARGE: 191,
        tecBAD_CREDENTIALS: 193,
        tecCANT_ACCEPT_OWN_NFTOKEN_OFFER: 158,
        tecCLAIM: 100,
        tecCRYPTOCONDITION_ERROR: 146,
        tecDIR_FULL: 121,
        tecDST_TAG_NEEDED: 143,
        tecDUPLICATE: 149,
        tecEMPTY_DID: 187,
        tecEXPIRED: 148,
        tecFAILED_PROCESSING: 105,
        tecFROZEN: 137,
        tecHAS_OBLIGATIONS: 151,
        tecINCOMPLETE: 169,
        tecINSUFFICIENT_FUNDS: 159,
        tecINSUFFICIENT_PAYMENT: 161,
        tecINSUFFICIENT_RESERVE: 141,
        tecINSUFF_FEE: 136,
        tecINSUF_RESERVE_LINE: 122,
        tecINSUF_RESERVE_OFFER: 123,
        tecINTERNAL: 144,
        tecINVALID_UPDATE_TIME: 188,
        tecINVARIANT_FAILED: 147,
        tecKILLED: 150,
        tecLOCKED: 192,
        tecMAX_SEQUENCE_REACHED: 154,
        tecNEED_MASTER_KEY: 142,
        tecNFTOKEN_BUY_SELL_MISMATCH: 156,
        tecNFTOKEN_OFFER_TYPE_MISMATCH: 157,
        tecNO_ALTERNATIVE_KEY: 130,
        tecNO_AUTH: 134,
        tecNO_DST: 124,
        tecNO_DST_INSUF_XRP: 125,
        tecNO_ENTRY: 140,
        tecNO_ISSUER: 133,
        tecNO_LINE: 135,
        tecNO_LINE_INSUF_RESERVE: 126,
        tecNO_LINE_REDUNDANT: 127,
        tecNO_PERMISSION: 139,
        tecNO_REGULAR_KEY: 131,
        tecNO_SUITABLE_NFTOKEN_PAGE: 155,
        tecNO_TARGET: 138,
        tecOBJECT_NOT_FOUND: 160,
        tecOVERSIZE: 145,
        tecOWNERS: 132,
        tecPATH_DRY: 128,
        tecPATH_PARTIAL: 101,
        tecTOKEN_PAIR_NOT_FOUND: 189,
        tecTOO_SOON: 152,
        tecUNFUNDED: 129,
        tecUNFUNDED_ADD: 102,
        tecUNFUNDED_AMM: 162,
        tecUNFUNDED_OFFER: 103,
        tecUNFUNDED_PAYMENT: 104,
        tecXCHAIN_ACCOUNT_CREATE_PAST: 181,
        tecXCHAIN_ACCOUNT_CREATE_TOO_MANY: 182,
        tecXCHAIN_BAD_CLAIM_ID: 172,
        tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR: 185,
        tecXCHAIN_BAD_TRANSFER_ISSUE: 170,
        tecXCHAIN_CLAIM_NO_QUORUM: 173,
        tecXCHAIN_CREATE_ACCOUNT_DISABLED: 186,
        tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE: 175,
        tecXCHAIN_INSUFF_CREATE_AMOUNT: 180,
        tecXCHAIN_NO_CLAIM_ID: 171,
        tecXCHAIN_NO_SIGNERS_LIST: 178,
        tecXCHAIN_PAYMENT_FAILED: 183,
        tecXCHAIN_PROOF_UNKNOWN_KEY: 174,
        tecXCHAIN_REWARD_MISMATCH: 177,
        tecXCHAIN_SELF_COMMIT: 184,
        tecXCHAIN_SENDING_ACCOUNT_MISMATCH: 179,
        tecXCHAIN_WRONG_CHAIN: 176,
        tefALREADY: -198,
        tefBAD_ADD_AUTH: -197,
        tefBAD_AUTH: -196,
        tefBAD_AUTH_MASTER: -183,
        tefBAD_LEDGER: -195,
        tefBAD_QUORUM: -185,
        tefBAD_SIGNATURE: -186,
        tefCREATED: -194,
        tefEXCEPTION: -193,
        tefFAILURE: -199,
        tefINTERNAL: -192,
        tefINVALID_LEDGER_FIX_TYPE: -178,
        tefINVARIANT_FAILED: -182,
        tefMASTER_DISABLED: -188,
        tefMAX_LEDGER: -187,
        tefNFTOKEN_IS_NOT_TRANSFERABLE: -179,
        tefNOT_MULTI_SIGNING: -184,
        tefNO_AUTH_REQUIRED: -191,
        tefNO_TICKET: -180,
        tefPAST_SEQ: -190,
        tefTOO_BIG: -181,
        tefWRONG_PRIOR: -189,
        telBAD_DOMAIN: -398,
        telBAD_PATH_COUNT: -397,
        telBAD_PUBLIC_KEY: -396,
        telCAN_NOT_QUEUE: -392,
        telCAN_NOT_QUEUE_BALANCE: -391,
        telCAN_NOT_QUEUE_BLOCKED: -389,
        telCAN_NOT_QUEUE_BLOCKS: -390,
        telCAN_NOT_QUEUE_FEE: -388,
        telCAN_NOT_QUEUE_FULL: -387,
        telENV_RPC_FAILED: -383,
        telFAILED_PROCESSING: -395,
        telINSUF_FEE_P: -394,
        telLOCAL_ERROR: -399,
        telNETWORK_ID_MAKES_TX_NON_CANONICAL: -384,
        telNO_DST_PARTIAL: -393,
        telREQUIRES_NETWORK_ID: -385,
        telWRONG_NETWORK: -386,
        temARRAY_EMPTY: -253,
        temARRAY_TOO_LARGE: -252,
        temBAD_AMM_TOKENS: -261,
        temBAD_AMOUNT: -298,
        temBAD_CURRENCY: -297,
        temBAD_EXPIRATION: -296,
        temBAD_FEE: -295,
        temBAD_ISSUER: -294,
        temBAD_LIMIT: -293,
        temBAD_NFTOKEN_TRANSFER_FEE: -262,
        temBAD_OFFER: -292,
        temBAD_PATH: -291,
        temBAD_PATH_LOOP: -290,
        temBAD_QUORUM: -271,
        temBAD_REGKEY: -289,
        temBAD_SEND_XRP_LIMIT: -288,
        temBAD_SEND_XRP_MAX: -287,
        temBAD_SEND_XRP_NO_DIRECT: -286,
        temBAD_SEND_XRP_PARTIAL: -285,
        temBAD_SEND_XRP_PATHS: -284,
        temBAD_SEQUENCE: -283,
        temBAD_SIGNATURE: -282,
        temBAD_SIGNER: -272,
        temBAD_SRC_ACCOUNT: -281,
        temBAD_TICK_SIZE: -269,
        temBAD_TRANSFER_FEE: -251,
        temBAD_TRANSFER_RATE: -280,
        temBAD_WEIGHT: -270,
        temCANNOT_PREAUTH_SELF: -267,
        temDISABLED: -273,
        temDST_IS_SRC: -279,
        temDST_NEEDED: -278,
        temEMPTY_DID: -254,
        temINVALID: -277,
        temINVALID_ACCOUNT_ID: -268,
        temINVALID_COUNT: -266,
        temINVALID_FLAG: -276,
        temMALFORMED: -299,
        temREDUNDANT: -275,
        temRIPPLE_EMPTY: -274,
        temSEQ_AND_TICKET: -263,
        temUNCERTAIN: -265,
        temUNKNOWN: -264,
        temXCHAIN_BAD_PROOF: -259,
        temXCHAIN_BRIDGE_BAD_ISSUES: -258,
        temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT: -256,
        temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT: -255,
        temXCHAIN_BRIDGE_NONDOOR_OWNER: -257,
        temXCHAIN_EQUAL_DOOR_ACCOUNTS: -260,
        terFUNDS_SPENT: -98,
        terINSUF_FEE_B: -97,
        terLAST: -91,
        terNO_ACCOUNT: -96,
        terNO_AMM: -87,
        terNO_AUTH: -95,
        terNO_LINE: -94,
        terNO_RIPPLE: -90,
        terOWNERS: -93,
        terPRE_SEQ: -92,
        terPRE_TICKET: -88,
        terQUEUED: -89,
        terRETRY: -99,
        tesSUCCESS: 0
      },
      TRANSACTION_TYPES: {
        AMMBid: 39,
        AMMClawback: 31,
        AMMCreate: 35,
        AMMDelete: 40,
        AMMDeposit: 36,
        AMMVote: 38,
        AMMWithdraw: 37,
        AccountDelete: 21,
        AccountSet: 3,
        CheckCancel: 18,
        CheckCash: 17,
        CheckCreate: 16,
        Clawback: 30,
        CredentialCreate: 58,
        CredentialAccept: 59,
        CredentialDelete: 60,
        DIDDelete: 50,
        DIDSet: 49,
        DepositPreauth: 19,
        EnableAmendment: 100,
        EscrowCancel: 4,
        EscrowCreate: 1,
        EscrowFinish: 2,
        Invalid: -1,
        LedgerStateFix: 53,
        MPTokenAuthorize: 57,
        MPTokenIssuanceCreate: 54,
        MPTokenIssuanceDestroy: 55,
        MPTokenIssuanceSet: 56,
        NFTokenAcceptOffer: 29,
        NFTokenBurn: 26,
        NFTokenCancelOffer: 28,
        NFTokenCreateOffer: 27,
        NFTokenMint: 25,
        NFTokenModify: 61,
        OfferCancel: 8,
        OfferCreate: 7,
        OracleDelete: 52,
        OracleSet: 51,
        Payment: 0,
        PaymentChannelClaim: 15,
        PaymentChannelCreate: 13,
        PaymentChannelFund: 14,
        PermissionedDomainSet: 62,
        PermissionedDomainDelete: 63,
        SetFee: 101,
        SetRegularKey: 5,
        SignerListSet: 12,
        TicketCreate: 10,
        TrustSet: 20,
        UNLModify: 102,
        XChainAccountCreateCommit: 44,
        XChainAddAccountCreateAttestation: 46,
        XChainAddClaimAttestation: 45,
        XChainClaim: 43,
        XChainCommit: 42,
        XChainCreateBridge: 48,
        XChainCreateClaimID: 41,
        XChainModifyBridge: 47
      },
      TYPES: {
        AccountID: 8,
        Amount: 6,
        Blob: 7,
        Currency: 26,
        Done: -1,
        Hash128: 4,
        Hash160: 17,
        Hash192: 21,
        Hash256: 5,
        Issue: 24,
        LedgerEntry: 10002,
        Metadata: 10004,
        NotPresent: 0,
        PathSet: 18,
        STArray: 15,
        STObject: 14,
        Transaction: 10001,
        UInt16: 1,
        UInt32: 2,
        UInt384: 22,
        UInt512: 23,
        UInt64: 3,
        UInt8: 16,
        UInt96: 20,
        Unknown: -2,
        Validation: 10003,
        Vector256: 19,
        XChainBridge: 25
      }
    };
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/bytes.js
var require_bytes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = void 0;
    var Bytes = class {
      constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = new Uint8Array(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
          this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 255;
        }
      }
      toJSON() {
        return this.name;
      }
      toBytesSink(sink) {
        sink.put(this.bytes);
      }
      toBytes() {
        return this.bytes;
      }
    };
    exports.Bytes = Bytes;
    var BytesLookup = class {
      constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
          this.add(k, v);
        });
      }
      /**
       * Add a new name value pair to the BytesLookup.
       *
       * @param name - A human readable name for the field.
       * @param value - The numeric value for the field.
       * @throws if the name or value already exist in the lookup because it's unclear how to decode.
       */
      add(name, value) {
        if (this[name]) {
          throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
          throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
      }
      from(value) {
        return value instanceof Bytes ? value : this[value];
      }
      fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
      }
    };
    exports.BytesLookup = BytesLookup;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js
var require_binary_serializer = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinarySerializer = exports.BytesList = void 0;
    var utils_1 = require_browser();
    var BytesList = class {
      constructor() {
        this.bytesArray = [];
      }
      /**
       * Get the total number of bytes in the BytesList
       *
       * @return the number of bytes
       */
      getLength() {
        return (0, utils_1.concat)(this.bytesArray).byteLength;
      }
      /**
       * Put bytes in the BytesList
       *
       * @param bytesArg A Uint8Array
       * @return this BytesList
       */
      put(bytesArg) {
        const bytes = Uint8Array.from(bytesArg);
        this.bytesArray.push(bytes);
        return this;
      }
      /**
       * Write this BytesList to the back of another bytes list
       *
       *  @param list The BytesList to write to
       */
      toBytesSink(list) {
        list.put(this.toBytes());
      }
      toBytes() {
        return (0, utils_1.concat)(this.bytesArray);
      }
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
    };
    exports.BytesList = BytesList;
    var BinarySerializer = class {
      constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
      }
      /**
       * Write a value to this BinarySerializer
       *
       * @param value a SerializedType value
       */
      write(value) {
        value.toBytesSink(this.sink);
      }
      /**
       * Write bytes to this BinarySerializer
       *
       * @param bytes the bytes to write
       */
      put(bytes) {
        this.sink.put(bytes);
      }
      /**
       * Write a value of a given type to this BinarySerializer
       *
       * @param type the type to write
       * @param value a value of that type
       */
      writeType(type, value) {
        this.write(type.from(value));
      }
      /**
       * Write BytesList to this BinarySerializer
       *
       * @param bl BytesList to write to BinarySerializer
       */
      writeBytesList(bl) {
        bl.toBytesSink(this.sink);
      }
      /**
       * Calculate the header of Variable Length encoded bytes
       *
       * @param length the length of the bytes
       */
      encodeVariableLength(length) {
        const lenBytes = new Uint8Array(3);
        if (length <= 192) {
          lenBytes[0] = length;
          return lenBytes.slice(0, 1);
        } else if (length <= 12480) {
          length -= 193;
          lenBytes[0] = 193 + (length >>> 8);
          lenBytes[1] = length & 255;
          return lenBytes.slice(0, 2);
        } else if (length <= 918744) {
          length -= 12481;
          lenBytes[0] = 241 + (length >>> 16);
          lenBytes[1] = length >> 8 & 255;
          lenBytes[2] = length & 255;
          return lenBytes.slice(0, 3);
        }
        throw new Error("Overflow error");
      }
      /**
       * Write field and value to BinarySerializer
       *
       * @param field field to write to BinarySerializer
       * @param value value to write to BinarySerializer
       */
      writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        if (associatedValue.toBytesSink === void 0 || field.name === void 0) {
          throw new Error();
        }
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
          this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        } else {
          associatedValue.toBytesSink(this.sink);
        }
      }
      /**
       * Write a variable length encoded value to the BinarySerializer
       *
       * @param value length encoded value to write to BytesList
       */
      writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
          value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
      }
    };
    exports.BinarySerializer = BinarySerializer;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/serialized-type.js
var require_serialized_type = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/serialized-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comparable = exports.SerializedType = void 0;
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_browser();
    var SerializedType = class {
      constructor(bytes) {
        this.bytes = new Uint8Array(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);
      }
      static fromParser(parser, hint) {
        throw new Error("fromParser not implemented");
        return this.fromParser(parser, hint);
      }
      static from(value) {
        throw new Error("from not implemented");
        return this.from(value);
      }
      /**
       * Write the bytes representation of a SerializedType to a BytesList
       *
       * @param list The BytesList to write SerializedType bytes to
       */
      toBytesSink(list) {
        list.put(this.bytes);
      }
      /**
       * Get the hex representation of a SerializedType's bytes
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
      /**
       * Get the bytes representation of a SerializedType
       *
       * @returns A Uint8Array of the bytes
       */
      toBytes() {
        if (this.bytes) {
          return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
      }
      /**
       * Return the JSON representation of a SerializedType
       *
       * @param _definitions rippled definitions used to parse the values of transaction types and such.
       *                          Unused in default, but used in STObject, STArray
       *                          Can be customized for sidechains and amendments.
       * @returns any type, if not overloaded returns hexString representation of bytes
       */
      toJSON(_definitions, _fieldName) {
        return this.toHex();
      }
      /**
       * @returns hexString representation of this.bytes
       */
      toString() {
        return this.toHex();
      }
    };
    exports.SerializedType = SerializedType;
    var Comparable = class extends SerializedType {
      lt(other) {
        return this.compareTo(other) < 0;
      }
      eq(other) {
        return this.compareTo(other) === 0;
      }
      gt(other) {
        return this.compareTo(other) > 0;
      }
      gte(other) {
        return this.compareTo(other) > -1;
      }
      lte(other) {
        return this.compareTo(other) < 1;
      }
      /**
       * Overload this method to define how two Comparable SerializedTypes are compared
       *
       * @param other The comparable object to compare this to
       * @returns A number denoting the relationship of this and other
       */
      compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
      }
    };
    exports.Comparable = Comparable;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
    exports.TYPE_WIDTH = 2;
    exports.LEDGER_ENTRY_WIDTH = 2;
    exports.TRANSACTION_TYPE_WIDTH = 2;
    exports.TRANSACTION_RESULT_WIDTH = 1;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/field.js
var require_field = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/field.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldLookup = void 0;
    var bytes_1 = require_bytes();
    var serialized_type_1 = require_serialized_type();
    var constants_1 = require_constants();
    function fieldHeader(type, nth) {
      const header = [];
      if (type < 16) {
        if (nth < 16) {
          header.push(type << 4 | nth);
        } else {
          header.push(type << 4, nth);
        }
      } else if (nth < 16) {
        header.push(nth, type);
      } else {
        header.push(0, type, nth);
      }
      return Uint8Array.from(header);
    }
    function buildField([name, info], typeOrdinal) {
      const field = fieldHeader(typeOrdinal, info.nth);
      return {
        name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: typeOrdinal << 16 | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType
        // For later assignment in ./types/index.js or Definitions.updateAll(...)
      };
    }
    var FieldLookup = class {
      constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
          const typeOrdinal = types[field_info.type];
          this[name] = buildField([name, field_info], typeOrdinal);
          this[this[name].ordinal.toString()] = this[name];
        });
      }
      fromString(value) {
        return this[value];
      }
    };
    exports.FieldLookup = FieldLookup;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js
var require_xrpl_definitions_base = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
    var bytes_1 = require_bytes();
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return bytes_1.Bytes;
    } });
    Object.defineProperty(exports, "BytesLookup", { enumerable: true, get: function() {
      return bytes_1.BytesLookup;
    } });
    var field_1 = require_field();
    Object.defineProperty(exports, "FieldLookup", { enumerable: true, get: function() {
      return field_1.FieldLookup;
    } });
    var constants_1 = require_constants();
    var XrplDefinitionsBase = class {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param types - A list of type objects with the same name as the fields defined.
       *              You can use the coreTypes object if you are not adding new types.
       */
      constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES).filter(([_key, value]) => value >= 0).map(([key, _value]) => key);
        this.dataTypes = {};
        this.associateTypes(types);
      }
      /**
       * Associates each Field to a corresponding class that TypeScript can recognize.
       *
       * @param types a list of type objects with the same name as the fields defined.
       *              Defaults to xrpl.js's core type definitions.
       */
      associateTypes(types) {
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
          field.associatedType = this.dataTypes[field.type.name];
        });
        this.field["TransactionType"].associatedType = this.transactionType;
        this.field["TransactionResult"].associatedType = this.transactionResult;
        this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
      }
      getAssociatedTypes() {
        return this.dataTypes;
      }
    };
    exports.XrplDefinitionsBase = XrplDefinitionsBase;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/index.js
var require_enums = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
    var definitions_json_1 = __importDefault(require_definitions());
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.Bytes;
    } });
    var DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(definitions_json_1.default, {});
    exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
    var Type = DEFAULT_DEFINITIONS.type;
    exports.Type = Type;
    var LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
    exports.LedgerEntryType = LedgerEntryType;
    var TransactionType = DEFAULT_DEFINITIONS.transactionType;
    exports.TransactionType = TransactionType;
    var TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
    exports.TransactionResult = TransactionResult;
    var Field = DEFAULT_DEFINITIONS.field;
    exports.Field = Field;
    var TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
    exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compare = exports.equal = exports.readUInt32BE = exports.readUInt16BE = exports.writeUInt32BE = exports.writeUInt16BE = exports.writeUInt8 = void 0;
    function writeUInt8(array, value, offset) {
      value = Number(value);
      array[offset] = value;
    }
    exports.writeUInt8 = writeUInt8;
    function writeUInt16BE(array, value, offset) {
      value = Number(value);
      array[offset] = value >>> 8;
      array[offset + 1] = value;
    }
    exports.writeUInt16BE = writeUInt16BE;
    function writeUInt32BE(array, value, offset) {
      array[offset] = value >>> 24 & 255;
      array[offset + 1] = value >>> 16 & 255;
      array[offset + 2] = value >>> 8 & 255;
      array[offset + 3] = value & 255;
    }
    exports.writeUInt32BE = writeUInt32BE;
    function readUInt16BE(array, offset) {
      return new DataView(array.buffer).getUint16(offset, false).toString(10);
    }
    exports.readUInt16BE = readUInt16BE;
    function readUInt32BE(array, offset) {
      return new DataView(array.buffer).getUint32(offset, false).toString(10);
    }
    exports.readUInt32BE = readUInt32BE;
    function equal(a, b) {
      const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
      const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
      if (aUInt.byteLength != bUInt.byteLength)
        return false;
      if (aligned32(aUInt) && aligned32(bUInt))
        return compare32(aUInt, bUInt) === 0;
      if (aligned16(aUInt) && aligned16(bUInt))
        return compare16(aUInt, bUInt) === 0;
      return compare8(aUInt, bUInt) === 0;
    }
    exports.equal = equal;
    function compare8(a, b) {
      const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
      return compare(ua, ub);
    }
    function compare16(a, b) {
      const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
      return compare(ua, ub);
    }
    function compare32(a, b) {
      const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
      const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
      return compare(ua, ub);
    }
    function compare(a, b) {
      if (a.byteLength !== b.byteLength) {
        throw new Error("Cannot compare arrays of different length");
      }
      for (let i = 0; i < a.length - 1; i += 1) {
        if (a[i] > b[i])
          return 1;
        if (a[i] < b[i])
          return -1;
      }
      return 0;
    }
    exports.compare = compare;
    function aligned16(array) {
      return array.byteOffset % 2 === 0 && array.byteLength % 2 === 0;
    }
    function aligned32(array) {
      return array.byteOffset % 4 === 0 && array.byteLength % 4 === 0;
    }
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var Hash = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
        if (this.bytes.length !== this.constructor.width) {
          throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
      }
      /**
       * Construct a Hash object from an existing Hash object or a hex-string
       *
       * @param value A hash object or hex-string of a hash
       */
      static from(value) {
        if (value instanceof this) {
          return value;
        }
        if (typeof value === "string") {
          return new this((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Hash from given value");
      }
      /**
       * Read a Hash object from a BinaryParser
       *
       * @param parser BinaryParser to read the hash from
       * @param hint length of the bytes to read, optional
       */
      static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
      }
      /**
       * Overloaded operator for comparing two hash objects
       *
       * @param other The Hash to compare this to
       */
      compareTo(other) {
        return (0, utils_2.compare)(this.bytes, this.constructor.from(other).bytes);
      }
      /**
       * @returns the hex-string representation of this Hash
       */
      toString() {
        return this.toHex();
      }
      /**
       * Returns four bits at the specified depth within a hash
       *
       * @param depth The depth of the four bits
       * @returns The number represented by the four bits
       */
      nibblet(depth) {
        const byteIx = depth > 0 ? depth / 2 | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
          b = (b & 240) >>> 4;
        } else {
          b = b & 15;
        }
        return b;
      }
    };
    exports.Hash = Hash;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-160.js
var require_hash_160 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash160 = void 0;
    var hash_1 = require_hash();
    var Hash160 = class _Hash160 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash160.ZERO_160.bytes);
      }
    };
    exports.Hash160 = Hash160;
    Hash160.width = 20;
    Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/account-id.js
var require_account_id = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/account-id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountID = void 0;
    var ripple_address_codec_1 = require_dist();
    var hash_160_1 = require_hash_160();
    var utils_1 = require_browser();
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var AccountID = class _AccountID extends hash_160_1.Hash160 {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _AccountID.defaultAccountID.bytes);
      }
      /**
       * Defines how to construct an AccountID
       *
       * @param value either an existing AccountID, a hex-string, or a base58 r-Address
       * @returns an AccountID object
       */
      static from(value) {
        if (value instanceof _AccountID) {
          return value;
        }
        if (typeof value === "string") {
          if (value === "") {
            return new _AccountID();
          }
          return HEX_REGEX.test(value) ? new _AccountID((0, utils_1.hexToBytes)(value)) : this.fromBase58(value);
        }
        throw new Error("Cannot construct AccountID from value given");
      }
      /**
       * Defines how to build an AccountID from a base58 r-Address
       *
       * @param value a base58 r-Address
       * @returns an AccountID object
       */
      static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
          const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
          if (classic.tag !== false)
            throw new Error("Only allowed to have tag on Account or Destination");
          value = classic.classicAddress;
        }
        return new _AccountID(Uint8Array.from((0, ripple_address_codec_1.decodeAccountID)(value)));
      }
      /**
       * Overload of toJSON
       *
       * @returns the base58 string for this AccountID
       */
      toJSON() {
        return this.toBase58();
      }
      /**
       * Defines how to encode AccountID into a base58 address
       *
       * @returns the base58 string defined by this.bytes
       */
      toBase58() {
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
      }
    };
    exports.AccountID = AccountID;
    AccountID.defaultAccountID = new AccountID(new Uint8Array(20));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js
var require_binary_parser = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryParser = void 0;
    var enums_1 = require_enums();
    var utils_1 = require_browser();
    var BinaryParser = class {
      /**
       * Initialize bytes to a hex string
       *
       * @param hexBytes a hex string
       * @param definitions Rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       */
      constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = (0, utils_1.hexToBytes)(hexBytes);
        this.definitions = definitions;
      }
      /**
       * Peek the first byte of the BinaryParser
       *
       * @returns The first byte of the BinaryParser
       */
      peek() {
        if (this.bytes.byteLength === 0) {
          throw new Error();
        }
        return this.bytes[0];
      }
      /**
       * Consume the first n bytes of the BinaryParser
       *
       * @param n the number of bytes to skip
       */
      skip(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        this.bytes = this.bytes.slice(n);
      }
      /**
       * read the first n bytes from the BinaryParser
       *
       * @param n The number of bytes to read
       * @return The bytes
       */
      read(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
      }
      /**
       * Read an integer of given size
       *
       * @param n The number of bytes to read
       * @return The number represented by those bytes
       */
      readUIntN(n) {
        if (0 >= n || n > 4) {
          throw new Error("invalid n");
        }
        return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;
      }
      readUInt8() {
        return this.readUIntN(1);
      }
      readUInt16() {
        return this.readUIntN(2);
      }
      readUInt32() {
        return this.readUIntN(4);
      }
      size() {
        return this.bytes.byteLength;
      }
      end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || customEnd !== void 0 && length <= customEnd;
      }
      /**
       * Reads variable length encoded bytes
       *
       * @return The variable length bytes
       */
      readVariableLength() {
        return this.read(this.readVariableLengthLength());
      }
      /**
       * Reads the length of the variable length encoded bytes
       *
       * @return The length of the variable length encoded bytes
       */
      readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
          return b1;
        } else if (b1 <= 240) {
          const b2 = this.readUInt8();
          return 193 + (b1 - 193) * 256 + b2;
        } else if (b1 <= 254) {
          const b2 = this.readUInt8();
          const b3 = this.readUInt8();
          return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error("Invalid variable length indicator");
      }
      /**
       * Reads the field ordinal from the BinaryParser
       *
       * @return Field ordinal
       */
      readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
          type = this.readUInt8();
          if (type === 0 || type < 16) {
            throw new Error(`Cannot read FieldOrdinal, type_code ${type} out of range`);
          }
        }
        if (nth === 0) {
          nth = this.readUInt8();
          if (nth === 0 || nth < 16) {
            throw new Error(`Cannot read FieldOrdinal, field_code ${nth} out of range`);
          }
        }
        return type << 16 | nth;
      }
      /**
       * Read the field from the BinaryParser
       *
       * @return The field represented by the bytes at the head of the BinaryParser
       */
      readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
      }
      /**
       * Read a given type from the BinaryParser
       *
       * @param type The type that you want to read from the BinaryParser
       * @return The instance of that type read from the BinaryParser
       */
      readType(type) {
        return type.fromParser(this);
      }
      /**
       * Get the type associated with a given field
       *
       * @param field The field that you wan to get the type of
       * @return The type associated with the given field
       */
      typeForField(field) {
        return field.associatedType;
      }
      /**
       * Read value of the type specified by field from the BinaryParser
       *
       * @param field The field that you want to get the associated value for
       * @return The value associated with the given field
       */
      readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
          throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : void 0;
        const value = type.fromParser(this, sizeHint);
        if (value === void 0) {
          throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
      }
      /**
       * Get the next field and value from the BinaryParser
       *
       * @return The field and value
       */
      readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
      }
    };
    exports.BinaryParser = BinaryParser;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/currency.js
var require_currency = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/currency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Currency = void 0;
    var hash_160_1 = require_hash_160();
    var utils_1 = require_browser();
    var XRP_HEX_REGEX = /^0{40}$/;
    var ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
    function isoToBytes(iso) {
      const bytes = new Uint8Array(20);
      if (iso !== "XRP") {
        const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
      }
      return bytes;
    }
    function isIsoCode(iso) {
      return ISO_REGEX.test(iso);
    }
    function isoCodeFromHex(code) {
      const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));
      if (iso === "XRP") {
        return null;
      }
      if (isIsoCode(iso)) {
        return iso;
      }
      return null;
    }
    function isHex(hex) {
      return HEX_REGEX.test(hex);
    }
    function isStringRepresentation(input) {
      return input.length === 3 || isHex(input);
    }
    function isBytesArray(bytes) {
      return bytes.byteLength === 20;
    }
    function isValidRepresentation(input) {
      return input instanceof Uint8Array ? isBytesArray(input) : isStringRepresentation(input);
    }
    function bytesFromRepresentation(input) {
      if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
      }
      return input.length === 3 ? isoToBytes(input) : (0, utils_1.hexToBytes)(input);
    }
    var Currency = class _Currency extends hash_160_1.Hash160 {
      constructor(byteBuf) {
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : _Currency.XRP.bytes);
        const hex = (0, utils_1.bytesToHex)(this.bytes);
        if (XRP_HEX_REGEX.test(hex)) {
          this._iso = "XRP";
        } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
          this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        } else {
          this._iso = null;
        }
      }
      /**
       * Return the ISO code of this currency
       *
       * @returns ISO code if it exists, else null
       */
      iso() {
        return this._iso;
      }
      /**
       * Constructs a Currency object
       *
       * @param val Currency object or a string representation of a currency
       */
      static from(value) {
        if (value instanceof _Currency) {
          return value;
        }
        if (typeof value === "string") {
          return new _Currency(bytesFromRepresentation(value));
        }
        throw new Error("Cannot construct Currency from value given");
      }
      /**
       * Gets the JSON representation of a currency
       *
       * @returns JSON representation
       */
      toJSON() {
        const iso = this.iso();
        if (iso !== null) {
          return iso;
        }
        return (0, utils_1.bytesToHex)(this.bytes);
      }
    };
    exports.Currency = Currency;
    Currency.XRP = new Currency(new Uint8Array(20));
  }
});

// node_modules/.pnpm/bignumber.js@9.3.0/node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/.pnpm/bignumber.js@9.3.0/node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-192.js
var require_hash_192 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-192.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash192 = void 0;
    var hash_1 = require_hash();
    var Hash192 = class _Hash192 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash192.ZERO_192.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash192.ZERO_192.bytes);
      }
    };
    exports.Hash192 = Hash192;
    Hash192.width = 24;
    Hash192.ZERO_192 = new Hash192(new Uint8Array(Hash192.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/amount.js
var require_amount = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/amount.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Amount = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var hash_192_1 = require_hash_192();
    var MIN_IOU_EXPONENT = -96;
    var MAX_IOU_EXPONENT = 80;
    var MAX_IOU_PRECISION = 16;
    var MAX_DROPS = new bignumber_js_1.default("1e17");
    var MIN_XRP = new bignumber_js_1.default("1e-6");
    var mask = BigInt(4294967295);
    var mptMask = BigInt(9223372036854776e3);
    bignumber_js_1.default.config({
      EXPONENTIAL_AT: [
        MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
        MAX_IOU_EXPONENT + MAX_IOU_PRECISION
      ]
    });
    function isAmountObjectIOU(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 3 && keys[0] === "currency" && keys[1] === "issuer" && keys[2] === "value";
    }
    function isAmountObjectMPT(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 2 && keys[0] === "mpt_issuance_id" && keys[1] === "value";
    }
    var Amount = class _Amount extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Amount.defaultAmount.bytes);
      }
      /**
       * Construct an amount from an IOU, MPT or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Amount) {
          return value;
        }
        let amount = new Uint8Array(8);
        if (typeof value === "string") {
          _Amount.assertXrpIsValid(value);
          const number = BigInt(value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
          amount = (0, utils_1.concat)(intBuf);
          amount[0] |= 64;
          return new _Amount(amount);
        }
        if (isAmountObjectIOU(value)) {
          const number = new bignumber_js_1.default(value.value);
          _Amount.assertIouIsValid(number);
          if (number.isZero()) {
            amount[0] |= 128;
          } else {
            const integerNumberString = number.times(`1e${-((number.e || 0) - 15)}`).abs().toString();
            const num = BigInt(integerNumberString);
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
            amount = (0, utils_1.concat)(intBuf);
            amount[0] |= 128;
            if (number.gt(new bignumber_js_1.default(0))) {
              amount[0] |= 64;
            }
            const exponent = (number.e || 0) - 15;
            const exponentByte = 97 + exponent;
            amount[0] |= exponentByte >>> 2;
            amount[1] |= (exponentByte & 3) << 6;
          }
          const currency = currency_1.Currency.from(value.currency).toBytes();
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Amount((0, utils_1.concat)([amount, currency, issuer]));
        }
        if (isAmountObjectMPT(value)) {
          _Amount.assertMptIsValid(value.value);
          let leadingByte = new Uint8Array(1);
          leadingByte[0] |= 96;
          const num = BigInt(value.value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
          amount = (0, utils_1.concat)(intBuf);
          const mptIssuanceID = hash_192_1.Hash192.from(value.mpt_issuance_id).toBytes();
          return new _Amount((0, utils_1.concat)([leadingByte, amount, mptIssuanceID]));
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const isIOU = parser.peek() & 128;
        if (isIOU)
          return new _Amount(parser.read(48));
        const isMPT = parser.peek() & 32;
        const numBytes = isMPT ? 33 : 8;
        return new _Amount(parser.read(numBytes));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.isNative()) {
          const bytes = this.bytes;
          const isPositive = bytes[0] & 64;
          const sign = isPositive ? "" : "-";
          bytes[0] &= 63;
          const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));
          const num = msb << BigInt(32) | lsb;
          return `${sign}${num.toString()}`;
        }
        if (this.isIOU()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const mantissa = parser.read(8);
          const currency = currency_1.Currency.fromParser(parser);
          const issuer = account_id_1.AccountID.fromParser(parser);
          const b1 = mantissa[0];
          const b2 = mantissa[1];
          const isPositive = b1 & 64;
          const sign = isPositive ? "" : "-";
          const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
          mantissa[0] = 0;
          mantissa[1] &= 63;
          const value = new bignumber_js_1.default(`${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);
          _Amount.assertIouIsValid(value);
          return {
            value: value.toString(),
            currency: currency.toJSON(),
            issuer: issuer.toJSON()
          };
        }
        if (this.isMPT()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const leadingByte = parser.read(1);
          const amount = parser.read(8);
          const mptID = hash_192_1.Hash192.fromParser(parser);
          const isPositive = leadingByte[0] & 64;
          const sign = isPositive ? "" : "-";
          const msb = BigInt((0, utils_2.readUInt32BE)(amount.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(amount.slice(4), 0));
          const num = msb << BigInt(32) | lsb;
          return {
            value: `${sign}${num.toString()}`,
            mpt_issuance_id: mptID.toString()
          };
        }
        throw new Error("Invalid amount to construct JSON");
      }
      /**
       * Validate XRP amount
       *
       * @param amount String representing XRP amount
       * @returns void, but will throw if invalid amount
       */
      static assertXrpIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Validate IOU.value amount
       *
       * @param decimal BigNumber object representing IOU.value
       * @returns void, but will throw if invalid amount
       */
      static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
          const p = decimal.precision();
          const e = (decimal.e || 0) - 15;
          if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {
            throw new Error("Decimal precision out of range");
          }
          this.verifyNoDecimal(decimal);
        }
      }
      /**
       * Validate MPT.value amount
       *
       * @param decimal BigNumber object representing MPT.value
       * @returns void, but will throw if invalid amount
       */
      static assertMptIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal < (0, bignumber_js_1.default)(0)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
          if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Ensure that the value after being multiplied by the exponent does not
       * contain a decimal.
       *
       * @param decimal a Decimal object
       * @returns a string of the object without a decimal
       */
      static verifyNoDecimal(decimal) {
        const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();
        if (integerNumberString.indexOf(".") !== -1) {
          throw new Error("Decimal place found in integerNumberString");
        }
      }
      /**
       * Test if this amount is in units of Native Currency(XRP)
       *
       * @returns true if Native (XRP)
       */
      isNative() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) === 0;
      }
      /**
       * Test if this amount is in units of MPT
       *
       * @returns true if MPT
       */
      isMPT() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) !== 0;
      }
      /**
       * Test if this amount is in units of IOU
       *
       * @returns true if IOU
       */
      isIOU() {
        return (this.bytes[0] & 128) !== 0;
      }
    };
    exports.Amount = Amount;
    Amount.defaultAmount = new Amount((0, utils_1.hexToBytes)("4000000000000000"));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/blob.js
var require_blob = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/blob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Blob = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var Blob = class _Blob extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Defines how to read a Blob from a BinaryParser
       *
       * @param parser The binary parser to read the Blob from
       * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
       * @returns A Blob object
       */
      static fromParser(parser, hint) {
        return new _Blob(parser.read(hint));
      }
      /**
       * Create a Blob object from a hex-string
       *
       * @param value existing Blob object or a hex-string
       * @returns A Blob object
       */
      static from(value) {
        if (value instanceof _Blob) {
          return value;
        }
        if (typeof value === "string") {
          if (!/^[A-F0-9]*$/iu.test(value)) {
            throw new Error("Cannot construct Blob from a non-hex string");
          }
          return new _Blob((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Blob from value given");
      }
    };
    exports.Blob = Blob;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-128.js
var require_hash_128 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-128.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash128 = void 0;
    var hash_1 = require_hash();
    var utils_1 = require_browser();
    var Hash128 = class _Hash128 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash128.ZERO_128.bytes);
      }
      /**
       * Get the hex representation of a hash-128 bytes, allowing unset
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        const hex = (0, utils_1.bytesToHex)(this.toBytes());
        if (/^0+$/.exec(hex)) {
          return "";
        }
        return hex;
      }
    };
    exports.Hash128 = Hash128;
    Hash128.width = 16;
    Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-256.js
var require_hash_256 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/hash-256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash256 = void 0;
    var hash_1 = require_hash();
    var Hash256 = class _Hash256 extends hash_1.Hash {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash256.ZERO_256.bytes);
      }
    };
    exports.Hash256 = Hash256;
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/issue.js
var require_issue = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/issue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Issue = void 0;
    var utils_1 = require_browser();
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    function isIssueObject(arg) {
      const keys = Object.keys(arg).sort();
      if (keys.length === 1) {
        return keys[0] === "currency";
      }
      return keys.length === 2 && keys[0] === "currency" && keys[1] === "issuer";
    }
    var Issue = class _Issue extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Issue.ZERO_ISSUED_CURRENCY.bytes);
      }
      /**
       * Construct an amount from an IOU or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Issue) {
          return value;
        }
        if (isIssueObject(value)) {
          const currency = currency_1.Currency.from(value.currency).toBytes();
          if (value.issuer == null) {
            return new _Issue(currency);
          }
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Issue((0, utils_1.concat)([currency, issuer]));
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const currency = parser.read(20);
        if (new currency_1.Currency(currency).toJSON() === "XRP") {
          return new _Issue(currency);
        }
        const currencyAndIssuer = [currency, parser.read(20)];
        return new _Issue((0, utils_1.concat)(currencyAndIssuer));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === "XRP") {
          return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
          currency: currency.toJSON(),
          issuer: issuer.toJSON()
        };
      }
    };
    exports.Issue = Issue;
    Issue.ZERO_ISSUED_CURRENCY = new Issue(new Uint8Array(20));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/path-set.js
var require_path_set = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/path-set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathSet = void 0;
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var binary_parser_1 = require_binary_parser();
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var PATHSET_END_BYTE = 0;
    var PATH_SEPARATOR_BYTE = 255;
    var TYPE_ACCOUNT = 1;
    var TYPE_CURRENCY = 16;
    var TYPE_ISSUER = 32;
    function isHopObject(arg) {
      return arg.issuer !== void 0 || arg.account !== void 0 || arg.currency !== void 0;
    }
    function isPathSet(arg) {
      return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
    }
    var Hop = class _Hop extends serialized_type_1.SerializedType {
      /**
       * Create a Hop from a HopObject
       *
       * @param value Either a hop or HopObject to create a hop with
       * @returns a Hop
       */
      static from(value) {
        if (value instanceof _Hop) {
          return value;
        }
        const bytes = [Uint8Array.from([0])];
        if (value.account) {
          bytes.push(account_id_1.AccountID.from(value.account).toBytes());
          bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
          bytes.push(currency_1.Currency.from(value.currency).toBytes());
          bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
          bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
          bytes[0][0] |= TYPE_ISSUER;
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Construct a Hop from a BinaryParser
       *
       * @param parser BinaryParser to read the Hop from
       * @returns a Hop
       */
      static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [Uint8Array.from([type])];
        if (type & TYPE_ACCOUNT) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
          bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON interpretation of this hop
       *
       * @returns a HopObject, an JS object with optional account, issuer, and currency
       */
      toJSON() {
        const hopParser = new binary_parser_1.BinaryParser((0, utils_1.bytesToHex)(this.bytes));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
          account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
          currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
          issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
          result.account = account;
        }
        if (issuer) {
          result.issuer = issuer;
        }
        if (currency) {
          result.currency = currency;
        }
        return result;
      }
      /**
       * get a number representing the type of this hop
       *
       * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
       */
      type() {
        return this.bytes[0];
      }
    };
    var Path = class _Path extends serialized_type_1.SerializedType {
      /**
       * construct a Path from an array of Hops
       *
       * @param value Path or array of HopObjects to construct a Path
       * @returns the Path
       */
      static from(value) {
        if (value instanceof _Path) {
          return value;
        }
        const bytes = [];
        value.forEach((hop) => {
          bytes.push(Hop.from(hop).toBytes());
        });
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Read a Path from a BinaryParser
       *
       * @param parser BinaryParser to read Path from
       * @returns the Path represented by the bytes read from the BinaryParser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Hop.fromParser(parser).toBytes());
          if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {
            break;
          }
        }
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this Path
       *
       * @returns an Array of HopObject constructed from this.bytes
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
      }
    };
    var PathSet = class _PathSet extends serialized_type_1.SerializedType {
      /**
       * Construct a PathSet from an Array of Arrays representing paths
       *
       * @param value A PathSet or Array of Array of HopObjects
       * @returns the PathSet constructed from value
       */
      static from(value) {
        if (value instanceof _PathSet) {
          return value;
        }
        if (isPathSet(value)) {
          const bytes = [];
          value.forEach((path) => {
            bytes.push(Path.from(path).toBytes());
            bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));
          });
          bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);
          return new _PathSet((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct PathSet from given value");
      }
      /**
       * Construct a PathSet from a BinaryParser
       *
       * @param parser A BinaryParser to read PathSet from
       * @returns the PathSet read from parser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Path.fromParser(parser).toBytes());
          bytes.push(parser.read(1));
          if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
            break;
          }
        }
        return new _PathSet((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this PathSet
       *
       * @returns an Array of Array of HopObjects, representing this PathSet
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Path.fromParser(pathParser).toJSON());
          pathParser.skip(1);
        }
        return json;
      }
    };
    exports.PathSet = PathSet;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint.js
var require_uint = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt = void 0;
    var serialized_type_1 = require_serialized_type();
    function compare(n1, n2) {
      return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
    }
    var UInt = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Overload of compareTo for Comparable
       *
       * @param other other UInt to compare this to
       * @returns -1, 0, or 1 depending on how the objects relate to each other
       */
      compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
      }
      /**
       * Convert a UInt object to JSON
       *
       * @returns number or string represented by this.bytes
       */
      toJSON() {
        const val = this.valueOf();
        return typeof val === "number" ? val : val.toString();
      }
      static checkUintRange(val, min, max) {
        if (val < min || val > max) {
          throw new Error(`Invalid ${this.constructor.name}: ${val} must be >= ${min} and <= ${max}`);
        }
      }
    };
    exports.UInt = UInt;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-64.js
var require_uint_64 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt64 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var enums_1 = require_enums();
    var HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
    var BASE10_REGEX = /^[0-9]{1,20}$/;
    var mask = BigInt(4294967295);
    function useBase10(fieldName) {
      return fieldName === "MaximumAmount" || fieldName === "OutstandingAmount" || fieldName === "MPTAmount";
    }
    var UInt64 = class _UInt64 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt64.defaultUInt64.bytes);
      }
      static fromParser(parser) {
        return new _UInt64(parser.read(_UInt64.width));
      }
      /**
       * Construct a UInt64 object
       *
       * @param val A UInt64, hex-string, bigInt, or number
       * @returns A UInt64 object
       */
      static from(val, fieldName = "") {
        if (val instanceof _UInt64) {
          return val;
        }
        let buf = new Uint8Array(_UInt64.width);
        if (typeof val === "number") {
          if (val < 0) {
            throw new Error("value must be an unsigned integer");
          }
          const number = BigInt(val);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        if (typeof val === "string") {
          if (useBase10(fieldName)) {
            if (!BASE10_REGEX.test(val)) {
              throw new Error(`${fieldName} ${val} is not a valid base 10 string`);
            }
            val = BigInt(val).toString(16);
          }
          if (typeof val === "string" && !HEX_REGEX.test(val)) {
            throw new Error(`${val} is not a valid hex-string`);
          }
          const strBuf = val.padStart(16, "0");
          buf = (0, utils_1.hexToBytes)(strBuf);
          return new _UInt64(buf);
        }
        if (typeof val === "bigint") {
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        throw new Error("Cannot construct UInt64 from given value");
      }
      /**
       * The JSON representation of a UInt64 object
       *
       * @returns a hex-string
       */
      toJSON(_definitions = enums_1.DEFAULT_DEFINITIONS, fieldName = "") {
        const hexString = (0, utils_1.bytesToHex)(this.bytes);
        if (useBase10(fieldName)) {
          return BigInt("0x" + hexString).toString(10);
        }
        return hexString;
      }
      /**
       * Get the value of the UInt64
       *
       * @returns the number represented buy this.bytes
       */
      valueOf() {
        const msb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));
        return msb << BigInt(32) | lsb;
      }
      /**
       * Get the bytes representation of the UInt64 object
       *
       * @returns 8 bytes representing the UInt64
       */
      toBytes() {
        return this.bytes;
      }
    };
    exports.UInt64 = UInt64;
    UInt64.width = 64 / 8;
    UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/st-object.js
var require_st_object = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/st-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STObject = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var ripple_address_codec_1 = require_dist();
    var binary_parser_1 = require_binary_parser();
    var binary_serializer_1 = require_binary_serializer();
    var st_array_1 = require_st_array();
    var uint_64_1 = require_uint_64();
    var OBJECT_END_MARKER_BYTE = Uint8Array.from([225]);
    var OBJECT_END_MARKER = "ObjectEndMarker";
    var ST_OBJECT = "STObject";
    var DESTINATION = "Destination";
    var ACCOUNT = "Account";
    var SOURCE_TAG = "SourceTag";
    var DEST_TAG = "DestinationTag";
    function handleXAddress(field, xAddress) {
      const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
      let tagName;
      if (field === DESTINATION)
        tagName = DEST_TAG;
      else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
      else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
      return decoded.tag !== false ? { [field]: decoded.classicAddress, [tagName]: decoded.tag } : { [field]: decoded.classicAddress };
    }
    function checkForDuplicateTags(obj1, obj2) {
      if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0))
        throw new Error("Cannot have Account X-Address and SourceTag");
      if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0))
        throw new Error("Cannot have Destination X-Address and DestinationTag");
    }
    var STObject = class _STObject extends serialized_type_1.SerializedType {
      /**
       * Construct a STObject from a BinaryParser
       *
       * @param parser BinaryParser to read STObject from
       * @returns A STObject object
       */
      static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          const associatedValue = parser.readFieldValue(field);
          bytes.writeFieldAndValue(field, associatedValue);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        }
        return new _STObject(list.toBytes());
      }
      /**
       * Construct a STObject from a JSON object
       *
       * @param value An object to include
       * @param filter optional, denote which field to include in serialized object
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns a STObject object
       */
      static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STObject) {
          return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
          let handled = void 0;
          if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
            handled = handleXAddress(key, val.toString());
            checkForDuplicateTags(handled, value);
          }
          return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
        }, {});
        let sorted = Object.keys(xAddressDecoded).map((f) => definitions.field[f]).filter((f) => f !== void 0 && xAddressDecoded[f.name] !== void 0 && f.isSerialized).sort((a, b) => {
          return a.ordinal - b.ordinal;
        });
        if (filter !== void 0) {
          sorted = sorted.filter(filter);
        }
        sorted.forEach((field) => {
          const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], void 0, definitions) : field.type.name === "STArray" ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions) : field.type.name === "UInt64" ? uint_64_1.UInt64.from(xAddressDecoded[field.name], field.name) : field.associatedType.from(xAddressDecoded[field.name]);
          if (associatedValue == void 0) {
            throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
          }
          if (associatedValue.name === "UNLModify") {
            isUnlModify = true;
          }
          const isUnlModifyWorkaround = field.name == "Account" && isUnlModify;
          bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        });
        return new _STObject(list.toBytes());
      }
      /**
       * Get the JSON interpretation of this.bytes
       * @param definitions rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       * @returns a JSON object
       */
      toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while (!objectParser.end()) {
          const field = objectParser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions, field.name);
        }
        return accumulator;
      }
    };
    exports.STObject = STObject;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/st-array.js
var require_st_array = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/st-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STArray = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var st_object_1 = require_st_object();
    var binary_parser_1 = require_binary_parser();
    var utils_1 = require_browser();
    var ARRAY_END_MARKER = Uint8Array.from([241]);
    var ARRAY_END_MARKER_NAME = "ArrayEndMarker";
    var OBJECT_END_MARKER = Uint8Array.from([225]);
    function isObjects(args) {
      return Array.isArray(args) && args.every((arg) => typeof arg === "object" && Object.keys(arg).length === 1 && typeof Object.values(arg)[0] === "object");
    }
    var STArray = class _STArray extends serialized_type_1.SerializedType {
      /**
       * Construct an STArray from a BinaryParser
       *
       * @param parser BinaryParser to parse an STArray from
       * @returns An STArray Object
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new _STArray((0, utils_1.concat)(bytes));
      }
      /**
       * Construct an STArray from an Array of JSON Objects
       *
       * @param value STArray or Array of Objects to parse into an STArray
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An STArray object
       */
      static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STArray) {
          return value;
        }
        if (isObjects(value)) {
          const bytes = [];
          value.forEach((obj) => {
            bytes.push(st_object_1.STObject.from(obj, void 0, definitions).toBytes());
          });
          bytes.push(ARRAY_END_MARKER);
          return new _STArray((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct STArray from value given");
      }
      /**
       * Return the JSON representation of this.bytes
       *
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An Array of JSON objects
       */
      toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while (!arrayParser.end()) {
          const field = arrayParser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          const outer = {};
          outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
          result.push(outer);
        }
        return result;
      }
    };
    exports.STArray = STArray;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-16.js
var require_uint_16 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt16 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils3();
    var UInt16 = class _UInt16 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt16.defaultUInt16.bytes);
      }
      static fromParser(parser) {
        return new _UInt16(parser.read(_UInt16.width));
      }
      /**
       * Construct a UInt16 object from a number
       *
       * @param val UInt16 object or number
       */
      static from(val) {
        if (val instanceof _UInt16) {
          return val;
        }
        if (typeof val === "number") {
          _UInt16.checkUintRange(val, 0, 65535);
          const buf = new Uint8Array(_UInt16.width);
          (0, utils_1.writeUInt16BE)(buf, val, 0);
          return new _UInt16(buf);
        }
        throw new Error("Can not construct UInt16 with given value");
      }
      /**
       * get the value of a UInt16 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt16BE)(this.bytes, 0));
      }
    };
    exports.UInt16 = UInt16;
    UInt16.width = 16 / 8;
    UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-32.js
var require_uint_32 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt32 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils3();
    var UInt32 = class _UInt32 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt32.defaultUInt32.bytes);
      }
      static fromParser(parser) {
        return new _UInt32(parser.read(_UInt32.width));
      }
      /**
       * Construct a UInt32 object from a number
       *
       * @param val UInt32 object or number
       */
      static from(val) {
        if (val instanceof _UInt32) {
          return val;
        }
        const buf = new Uint8Array(_UInt32.width);
        if (typeof val === "string") {
          const num = Number.parseInt(val);
          (0, utils_1.writeUInt32BE)(buf, num, 0);
          return new _UInt32(buf);
        }
        if (typeof val === "number") {
          _UInt32.checkUintRange(val, 0, 4294967295);
          (0, utils_1.writeUInt32BE)(buf, val, 0);
          return new _UInt32(buf);
        }
        throw new Error("Cannot construct UInt32 from given value");
      }
      /**
       * get the value of a UInt32 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt32BE)(this.bytes, 0), 10);
      }
    };
    exports.UInt32 = UInt32;
    UInt32.width = 32 / 8;
    UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-8.js
var require_uint_8 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/uint-8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt8 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var UInt8 = class _UInt8 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt8.defaultUInt8.bytes);
      }
      static fromParser(parser) {
        return new _UInt8(parser.read(_UInt8.width));
      }
      /**
       * Construct a UInt8 object from a number
       *
       * @param val UInt8 object or number
       */
      static from(val) {
        if (val instanceof _UInt8) {
          return val;
        }
        if (typeof val === "number") {
          _UInt8.checkUintRange(val, 0, 255);
          const buf = new Uint8Array(_UInt8.width);
          (0, utils_2.writeUInt8)(buf, val, 0);
          return new _UInt8(buf);
        }
        throw new Error("Cannot construct UInt8 from given value");
      }
      /**
       * get the value of a UInt8 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.bytesToHex)(this.bytes), 16);
      }
    };
    exports.UInt8 = UInt8;
    UInt8.width = 8 / 8;
    UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/vector-256.js
var require_vector_256 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/vector-256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = void 0;
    var serialized_type_1 = require_serialized_type();
    var hash_256_1 = require_hash_256();
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_browser();
    function isStrings(arg) {
      return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string");
    }
    var Vector256 = class _Vector256 extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Construct a Vector256 from a BinaryParser
       *
       * @param parser BinaryParser to
       * @param hint length of the vector, in bytes, optional
       * @returns a Vector256 object
       */
      static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
          hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new _Vector256(bytesList.toBytes());
      }
      /**
       * Construct a Vector256 object from an array of hashes
       *
       * @param value A Vector256 object or array of hex-strings representing Hash256's
       * @returns a Vector256 object
       */
      static from(value) {
        if (value instanceof _Vector256) {
          return value;
        }
        if (isStrings(value)) {
          const bytesList = new binary_serializer_1.BytesList();
          value.forEach((hash) => {
            hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
          });
          return new _Vector256(bytesList.toBytes());
        }
        throw new Error("Cannot construct Vector256 from given value");
      }
      /**
       * Return an Array of hex-strings represented by this.bytes
       *
       * @returns An Array of strings representing the Hash256 objects
       */
      toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
          throw new Error("Invalid bytes for Vector256");
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
          result.push((0, utils_1.bytesToHex)(this.bytes.slice(i, i + 32)));
        }
        return result;
      }
    };
    exports.Vector256 = Vector256;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js
var require_xchain_bridge = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XChainBridge = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var serialized_type_1 = require_serialized_type();
    var issue_1 = require_issue();
    var utils_1 = require_browser();
    function isXChainBridgeObject(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 4 && keys[0] === "IssuingChainDoor" && keys[1] === "IssuingChainIssue" && keys[2] === "LockingChainDoor" && keys[3] === "LockingChainIssue";
    }
    var XChainBridge = class _XChainBridge extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
      }
      /**
       * Construct a cross-chain bridge from a JSON
       *
       * @param value XChainBridge or JSON to parse into an XChainBridge
       * @returns An XChainBridge object
       */
      static from(value) {
        if (value instanceof _XChainBridge) {
          return value;
        }
        if (!isXChainBridgeObject(value)) {
          throw new Error("Invalid type to construct an XChainBridge");
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            bytes.push(Uint8Array.from([20]));
          }
          const object = type.from(value[name]);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Read an XChainBridge from a BinaryParser
       *
       * @param parser BinaryParser to read the XChainBridge from
       * @returns An XChainBridge object
       */
      static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
            bytes.push(Uint8Array.from([20]));
          }
          const object = type.fromParser(parser);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this XChainBridge
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        _XChainBridge.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
          }
          const object = type.fromParser(parser).toJSON();
          json[name] = object;
        });
        return json;
      }
    };
    exports.XChainBridge = XChainBridge;
    XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1.concat)([
      Uint8Array.from([20]),
      new Uint8Array(40),
      Uint8Array.from([20]),
      new Uint8Array(40)
    ]));
    XChainBridge.TYPE_ORDER = [
      { name: "LockingChainDoor", type: account_id_1.AccountID },
      { name: "LockingChainIssue", type: issue_1.Issue },
      { name: "IssuingChainDoor", type: account_id_1.AccountID },
      { name: "IssuingChainIssue", type: issue_1.Issue }
    ];
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/index.js
var require_types = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash192 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
    var account_id_1 = require_account_id();
    Object.defineProperty(exports, "AccountID", { enumerable: true, get: function() {
      return account_id_1.AccountID;
    } });
    var amount_1 = require_amount();
    Object.defineProperty(exports, "Amount", { enumerable: true, get: function() {
      return amount_1.Amount;
    } });
    var blob_1 = require_blob();
    Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
      return blob_1.Blob;
    } });
    var currency_1 = require_currency();
    Object.defineProperty(exports, "Currency", { enumerable: true, get: function() {
      return currency_1.Currency;
    } });
    var hash_128_1 = require_hash_128();
    Object.defineProperty(exports, "Hash128", { enumerable: true, get: function() {
      return hash_128_1.Hash128;
    } });
    var hash_160_1 = require_hash_160();
    Object.defineProperty(exports, "Hash160", { enumerable: true, get: function() {
      return hash_160_1.Hash160;
    } });
    var hash_192_1 = require_hash_192();
    Object.defineProperty(exports, "Hash192", { enumerable: true, get: function() {
      return hash_192_1.Hash192;
    } });
    var hash_256_1 = require_hash_256();
    Object.defineProperty(exports, "Hash256", { enumerable: true, get: function() {
      return hash_256_1.Hash256;
    } });
    var issue_1 = require_issue();
    var path_set_1 = require_path_set();
    Object.defineProperty(exports, "PathSet", { enumerable: true, get: function() {
      return path_set_1.PathSet;
    } });
    var st_array_1 = require_st_array();
    Object.defineProperty(exports, "STArray", { enumerable: true, get: function() {
      return st_array_1.STArray;
    } });
    var st_object_1 = require_st_object();
    Object.defineProperty(exports, "STObject", { enumerable: true, get: function() {
      return st_object_1.STObject;
    } });
    var uint_16_1 = require_uint_16();
    Object.defineProperty(exports, "UInt16", { enumerable: true, get: function() {
      return uint_16_1.UInt16;
    } });
    var uint_32_1 = require_uint_32();
    Object.defineProperty(exports, "UInt32", { enumerable: true, get: function() {
      return uint_32_1.UInt32;
    } });
    var uint_64_1 = require_uint_64();
    Object.defineProperty(exports, "UInt64", { enumerable: true, get: function() {
      return uint_64_1.UInt64;
    } });
    var uint_8_1 = require_uint_8();
    Object.defineProperty(exports, "UInt8", { enumerable: true, get: function() {
      return uint_8_1.UInt8;
    } });
    var vector_256_1 = require_vector_256();
    Object.defineProperty(exports, "Vector256", { enumerable: true, get: function() {
      return vector_256_1.Vector256;
    } });
    var xchain_bridge_1 = require_xchain_bridge();
    var enums_1 = require_enums();
    var coreTypes = {
      AccountID: account_id_1.AccountID,
      Amount: amount_1.Amount,
      Blob: blob_1.Blob,
      Currency: currency_1.Currency,
      Hash128: hash_128_1.Hash128,
      Hash160: hash_160_1.Hash160,
      Hash192: hash_192_1.Hash192,
      Hash256: hash_256_1.Hash256,
      Issue: issue_1.Issue,
      PathSet: path_set_1.PathSet,
      STArray: st_array_1.STArray,
      STObject: st_object_1.STObject,
      UInt8: uint_8_1.UInt8,
      UInt16: uint_16_1.UInt16,
      UInt32: uint_32_1.UInt32,
      UInt64: uint_64_1.UInt64,
      Vector256: vector_256_1.Vector256,
      XChainBridge: xchain_bridge_1.XChainBridge
    };
    exports.coreTypes = coreTypes;
    enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/hash-prefixes.js
var require_hash_prefixes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/hash-prefixes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashPrefix = void 0;
    var utils_1 = require_utils3();
    function bytes(uint32) {
      const result = new Uint8Array(4);
      (0, utils_1.writeUInt32BE)(result, uint32, 0);
      return result;
    }
    var HashPrefix = {
      transactionID: bytes(1415073280),
      // transaction plus metadata
      transaction: bytes(1397638144),
      // account state
      accountStateEntry: bytes(1296846336),
      // inner node in tree
      innerNode: bytes(1296649728),
      // ledger master data for signing
      ledgerHeader: bytes(1280791040),
      // inner transaction to sign
      transactionSig: bytes(1398036480),
      // inner transaction to sign
      transactionMultiSig: bytes(1397576704),
      // validation for signing
      validation: bytes(1447119872),
      // proposal for signing
      proposal: bytes(1347571712),
      // payment channel claim
      paymentChannelClaim: bytes(1129073920)
    };
    exports.HashPrefix = HashPrefix;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
    var sha2_ts_1 = require_sha2();
    exports.SHA512 = sha2_ts_1.SHA512;
    exports.sha512 = sha2_ts_1.sha512;
    exports.SHA384 = sha2_ts_1.SHA384;
    exports.sha384 = sha2_ts_1.sha384;
    exports.SHA512_224 = sha2_ts_1.SHA512_224;
    exports.sha512_224 = sha2_ts_1.sha512_224;
    exports.SHA512_256 = sha2_ts_1.SHA512_256;
    exports.sha512_256 = sha2_ts_1.sha512_256;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/sha512/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/sha512/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = void 0;
    var sha512_1 = require_sha512();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.sha512 = (0, wrapNoble_1.default)(sha512_1.sha512);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/hashes.js
var require_hashes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
    var hash_prefixes_1 = require_hash_prefixes();
    var types_1 = require_types();
    var binary_serializer_1 = require_binary_serializer();
    var sha512_1 = require_browser3();
    var Sha512Half = class _Sha512Half extends binary_serializer_1.BytesList {
      constructor() {
        super(...arguments);
        this.hash = sha512_1.sha512.create();
      }
      /**
       * Construct a new Sha512Hash and write bytes this.hash
       *
       * @param bytes bytes to write to this.hash
       * @returns the new Sha512Hash object
       */
      static put(bytes) {
        return new _Sha512Half().put(bytes);
      }
      /**
       * Write bytes to an existing Sha512Hash
       *
       * @param bytes bytes to write to object
       * @returns the Sha512 object
       */
      put(bytes) {
        this.hash.update(bytes);
        return this;
      }
      /**
       * Compute SHA512 hash and slice in half
       *
       * @returns half of a SHA512 hash
       */
      finish256() {
        return Uint8Array.from(this.hash.digest().slice(0, 32));
      }
      /**
       * Constructs a Hash256 from the Sha512Half object
       *
       * @returns a Hash256 object
       */
      finish() {
        return new types_1.Hash256(this.finish256());
      }
    };
    exports.Sha512Half = Sha512Half;
    function sha512Half(...args) {
      const hash = new Sha512Half();
      args.forEach((a) => hash.put(a));
      return hash.finish256();
    }
    exports.sha512Half = sha512Half;
    function transactionID(serialized) {
      return new types_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
    }
    exports.transactionID = transactionID;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
    var utils_1 = require_browser();
    var types_1 = require_types();
    var binary_parser_1 = require_binary_parser();
    Object.defineProperty(exports, "BinaryParser", { enumerable: true, get: function() {
      return binary_parser_1.BinaryParser;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    var binary_serializer_1 = require_binary_serializer();
    Object.defineProperty(exports, "BinarySerializer", { enumerable: true, get: function() {
      return binary_serializer_1.BinarySerializer;
    } });
    Object.defineProperty(exports, "BytesList", { enumerable: true, get: function() {
      return binary_serializer_1.BytesList;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "sha512Half", { enumerable: true, get: function() {
      return hashes_1.sha512Half;
    } });
    Object.defineProperty(exports, "transactionID", { enumerable: true, get: function() {
      return hashes_1.transactionID;
    } });
    var enums_1 = require_enums();
    var makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes, definitions);
    exports.makeParser = makeParser;
    var readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
    exports.readJSON = readJSON;
    var binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);
    exports.binaryToJSON = binaryToJSON;
    function serializeObject(object, opts = {}) {
      const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
      const bytesList = new binary_serializer_1.BytesList();
      if (prefix) {
        bytesList.put(prefix);
      }
      const filter = signingFieldsOnly ? (f) => f.isSigningField : void 0;
      types_1.coreTypes.STObject.from(object, filter, definitions).toBytesSink(bytesList);
      if (suffix) {
        bytesList.put(suffix);
      }
      return bytesList.toBytes();
    }
    exports.serializeObject = serializeObject;
    function signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
      return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.signingData = signingData;
    function signingClaimData(claim) {
      const num = BigInt(String(claim.amount));
      const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
      const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
      const amount = types_1.coreTypes.UInt64.from(num).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix);
      bytesList.put(channel);
      bytesList.put(amount);
      return bytesList.toBytes();
    }
    exports.signingClaimData = signingClaimData;
    function multiSigningData(transaction, signingAccount, opts = {
      definitions: enums_1.DEFAULT_DEFINITIONS
    }) {
      const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
      const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
      return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.multiSigningData = multiSigningData;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/shamap.js
var require_shamap = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/shamap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
    var types_1 = require_types();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var ShaMapNode = class {
    };
    exports.ShaMapNode = ShaMapNode;
    var ShaMapLeaf = class extends ShaMapNode {
      constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
      }
      /**
       * @returns true as ShaMapLeaf is a leaf node
       */
      isLeaf() {
        return true;
      }
      /**
       * @returns false as ShaMapLeaf is not an inner node
       */
      isInner() {
        return false;
      }
      /**
       * Get the prefix of the this.item
       *
       * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
       */
      hashPrefix() {
        return this.item === void 0 ? new Uint8Array(0) : this.item.hashPrefix();
      }
      /**
       * Hash the bytes representation of this
       *
       * @returns hash of this.item concatenated with this.index
       */
      hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Write the bytes representation of this to a BytesList
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        if (this.item !== void 0) {
          this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
      }
    };
    exports.ShaMapLeaf = ShaMapLeaf;
    var ShaMapInner = class _ShaMapInner extends ShaMapNode {
      constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
      }
      /**
       * @returns true as ShaMapInner is an inner node
       */
      isInner() {
        return true;
      }
      /**
       * @returns false as ShaMapInner is not a leaf node
       */
      isLeaf() {
        return false;
      }
      /**
       * Get the hash prefix for this node
       *
       * @returns hash prefix describing an inner node
       */
      hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
      }
      /**
       * Set a branch of this node to be another node
       *
       * @param slot Slot to add branch to this.branches
       * @param branch Branch to add
       */
      setBranch(slot, branch) {
        this.slotBits = this.slotBits | 1 << slot;
        this.branches[slot] = branch;
      }
      /**
       * @returns true if node is empty
       */
      empty() {
        return this.slotBits === 0;
      }
      /**
       * Compute the hash of this node
       *
       * @returns The hash of this node
       */
      hash() {
        if (this.empty()) {
          return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Writes the bytes representation of this node to a BytesList
       *
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
          const branch = this.branches[i];
          const hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;
          hash.toBytesSink(list);
        }
      }
      /**
       * Add item to the SHAMap
       *
       * @param index Hash of the index of the item being inserted
       * @param item Item to insert in the map
       * @param leaf Leaf node to insert when branch doesn't exist
       */
      addItem(index, item, leaf) {
        if (index === void 0) {
          throw new Error();
        }
        if (index !== void 0) {
          const nibble = index.nibblet(this.depth);
          const existing = this.branches[nibble];
          if (existing === void 0) {
            this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
          } else if (existing instanceof ShaMapLeaf) {
            const newInner = new _ShaMapInner(this.depth + 1);
            newInner.addItem(existing.index, void 0, existing);
            newInner.addItem(index, item, leaf);
            this.setBranch(nibble, newInner);
          } else if (existing instanceof _ShaMapInner) {
            existing.addItem(index, item, leaf);
          } else {
            throw new Error("invalid ShaMap.addItem call");
          }
        }
      }
    };
    var ShaMap = class extends ShaMapInner {
    };
    exports.ShaMap = ShaMap;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/ledger-hashes.js
var require_ledger_hashes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/ledger-hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
    var shamap_1 = require_shamap();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var binary_1 = require_binary();
    var hash_256_1 = require_hash_256();
    var st_object_1 = require_st_object();
    var uint_64_1 = require_uint_64();
    var uint_32_1 = require_uint_32();
    var uint_8_1 = require_uint_8();
    var binary_parser_1 = require_binary_parser();
    function computeHash(itemizer, itemsJson) {
      const map = new shamap_1.ShaMap();
      itemsJson.forEach((item) => map.addItem(...itemizer(item)));
      return map.hash();
    }
    function transactionItemizer(json) {
      if (!json.hash) {
        throw new Error();
      }
      const index = hash_256_1.Hash256.from(json.hash);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
          const serializer = new binary_1.BinarySerializer(sink);
          serializer.writeLengthEncoded(st_object_1.STObject.from(json));
          serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        }
      };
      return [index, item, void 0];
    }
    function entryItemizer(json) {
      const index = hash_256_1.Hash256.from(json.index);
      const bytes = (0, binary_1.serializeObject)(json);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
          sink.put(bytes);
        }
      };
      return [index, item, void 0];
    }
    function transactionTreeHash(param) {
      const itemizer = transactionItemizer;
      return computeHash(itemizer, param);
    }
    exports.transactionTreeHash = transactionTreeHash;
    function accountStateHash(param) {
      const itemizer = entryItemizer;
      return computeHash(itemizer, param);
    }
    exports.accountStateHash = accountStateHash;
    function ledgerHash(header) {
      const hash = new hashes_1.Sha512Half();
      hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
      if (header.parent_close_time === void 0 || header.close_flags === void 0) {
        throw new Error();
      }
      uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
      uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash);
      hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
      uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
      uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
      return hash.finish();
    }
    exports.ledgerHash = ledgerHash;
    function decodeLedgerData(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      const parser = new binary_parser_1.BinaryParser(binary, definitions);
      return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8()
      };
    }
    exports.decodeLedgerData = decodeLedgerData;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/quality.js
var require_quality = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/quality.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.quality = void 0;
    var types_1 = require_types();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_browser();
    var quality = class {
      /**
       * Encode quality amount
       *
       * @param arg string representation of an amount
       * @returns Serialized quality
       */
      static encode(quality2) {
        const decimal = (0, bignumber_js_1.default)(quality2);
        const exponent = ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(BigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
      }
      /**
       * Decode quality amount
       *
       * @param arg hex-string denoting serialized quality
       * @returns deserialized quality
       */
      static decode(quality2) {
        const bytes = (0, utils_1.hexToBytes)(quality2).slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new bignumber_js_1.default(`0x${(0, utils_1.bytesToHex)(bytes.slice(1))}`);
        return mantissa.times(`1e${exponent}`);
      }
    };
    exports.quality = quality;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/coretypes.js
var require_coretypes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/coretypes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
    var enums_1 = require_enums();
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return enums_1.Field;
    } });
    Object.defineProperty(exports, "TransactionType", { enumerable: true, get: function() {
      return enums_1.TransactionType;
    } });
    Object.defineProperty(exports, "LedgerEntryType", { enumerable: true, get: function() {
      return enums_1.LedgerEntryType;
    } });
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return enums_1.Type;
    } });
    Object.defineProperty(exports, "TransactionResult", { enumerable: true, get: function() {
      return enums_1.TransactionResult;
    } });
    var types = __importStar(require_types());
    exports.types = types;
    var binary = __importStar(require_binary());
    exports.binary = binary;
    var shamap_1 = require_shamap();
    Object.defineProperty(exports, "ShaMap", { enumerable: true, get: function() {
      return shamap_1.ShaMap;
    } });
    var ledgerHashes = __importStar(require_ledger_hashes());
    exports.ledgerHashes = ledgerHashes;
    var hashes = __importStar(require_hashes());
    exports.hashes = hashes;
    var quality_1 = require_quality();
    Object.defineProperty(exports, "quality", { enumerable: true, get: function() {
      return quality_1.quality;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    Object.defineProperty(exports, "HashPrefix", { enumerable: true, get: function() {
      return hash_prefixes_1.HashPrefix;
    } });
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js
var require_xrpl_definitions = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XrplDefinitions = void 0;
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    var types_1 = require_types();
    var XrplDefinitions = class extends xrpl_definitions_base_1.XrplDefinitionsBase {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
       *              These types will be included in addition to the coreTypes used on mainnet.
       */
      constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
      }
    };
    exports.XrplDefinitions = XrplDefinitions;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.3.0/node_modules/ripple-binary-codec/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
    var coretypes_1 = require_coretypes();
    var ledger_hashes_1 = require_ledger_hashes();
    Object.defineProperty(exports, "decodeLedgerData", { enumerable: true, get: function() {
      return ledger_hashes_1.decodeLedgerData;
    } });
    var enums_1 = require_enums();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return enums_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "TRANSACTION_TYPES", { enumerable: true, get: function() {
      return enums_1.TRANSACTION_TYPES;
    } });
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    var xrpl_definitions_1 = require_xrpl_definitions();
    Object.defineProperty(exports, "XrplDefinitions", { enumerable: true, get: function() {
      return xrpl_definitions_1.XrplDefinitions;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "coreTypes", { enumerable: true, get: function() {
      return types_1.coreTypes;
    } });
    var utils_1 = require_browser();
    var { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject } = coretypes_1.binary;
    function decode(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      return binaryToJSON(binary, definitions);
    }
    exports.decode = decode;
    function encode(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(serializeObject(json, { definitions }));
    }
    exports.encode = encode;
    function encodeForSigning(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions
      }));
    }
    exports.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(json) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(signingClaimData(json));
    }
    exports.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultisigning(json, signer, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      if (json["SigningPubKey"] !== "") {
        throw new Error();
      }
      const definitionsOpt = definitions ? { definitions } : void 0;
      return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));
    }
    exports.encodeForMultisigning = encodeForMultisigning;
    function encodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));
    }
    exports.encodeQuality = encodeQuality;
    function decodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return coretypes_1.quality.decode(value).toString();
    }
    exports.decodeQuality = decodeQuality;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHex = exports.isFlagEnabled = exports.onlyHasFields = exports.INTEGER_SANITY_CHECK = void 0;
    var HEX_REGEX = /^[0-9A-Fa-f]+$/u;
    exports.INTEGER_SANITY_CHECK = /^[0-9]+$/u;
    function onlyHasFields(obj, fields) {
      return Object.keys(obj).every((key) => fields.includes(key));
    }
    exports.onlyHasFields = onlyHasFields;
    function isFlagEnabled(Flags, checkFlag) {
      return (BigInt(checkFlag) & BigInt(Flags)) === BigInt(checkFlag);
    }
    exports.isFlagEnabled = isFlagEnabled;
    function isHex(str) {
      return HEX_REGEX.test(str);
    }
    exports.isHex = isHex;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.containsDuplicates = exports.validateCredentialsList = exports.validateCredentialType = exports.parseAmountValue = exports.validateBaseTransaction = exports.validateOptionalField = exports.validateRequiredField = exports.isXChainBridge = exports.isAmount = exports.isAccount = exports.isMPTAmount = exports.isAuthorizeCredential = exports.isIssuedCurrency = exports.isCurrency = exports.isNumber = exports.isString = exports.MAX_AUTHORIZED_CREDENTIALS = void 0;
    var utils_1 = require_browser();
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var utils_2 = require_utils4();
    var MEMO_SIZE = 3;
    exports.MAX_AUTHORIZED_CREDENTIALS = 8;
    var MAX_CREDENTIAL_BYTE_LENGTH = 64;
    var MAX_CREDENTIAL_TYPE_LENGTH = MAX_CREDENTIAL_BYTE_LENGTH * 2;
    function isMemo(obj) {
      if (obj.Memo == null) {
        return false;
      }
      const memo = obj.Memo;
      const size = Object.keys(memo).length;
      const validData = memo.MemoData == null || typeof memo.MemoData === "string";
      const validFormat = memo.MemoFormat == null || typeof memo.MemoFormat === "string";
      const validType = memo.MemoType == null || typeof memo.MemoType === "string";
      return size >= 1 && size <= MEMO_SIZE && validData && validFormat && validType && (0, utils_2.onlyHasFields)(memo, ["MemoFormat", "MemoData", "MemoType"]);
    }
    var SIGNER_SIZE = 3;
    function isSigner(obj) {
      const signerWrapper = obj;
      if (signerWrapper.Signer == null) {
        return false;
      }
      const signer = signerWrapper.Signer;
      return Object.keys(signer).length === SIGNER_SIZE && typeof signer.Account === "string" && typeof signer.TxnSignature === "string" && typeof signer.SigningPubKey === "string";
    }
    var XRP_CURRENCY_SIZE = 1;
    var ISSUE_SIZE = 2;
    var ISSUED_CURRENCY_SIZE = 3;
    var XCHAIN_BRIDGE_SIZE = 4;
    var MPTOKEN_SIZE = 2;
    var AUTHORIZE_CREDENTIAL_SIZE = 1;
    function isRecord(value) {
      return value !== null && typeof value === "object";
    }
    function isString(str) {
      return typeof str === "string";
    }
    exports.isString = isString;
    function isNumber(num) {
      return typeof num === "number";
    }
    exports.isNumber = isNumber;
    function isCurrency(input) {
      return isRecord(input) && (Object.keys(input).length === ISSUE_SIZE && typeof input.issuer === "string" && typeof input.currency === "string" || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === "XRP");
    }
    exports.isCurrency = isCurrency;
    function isIssuedCurrency(input) {
      return isRecord(input) && Object.keys(input).length === ISSUED_CURRENCY_SIZE && typeof input.value === "string" && typeof input.issuer === "string" && typeof input.currency === "string";
    }
    exports.isIssuedCurrency = isIssuedCurrency;
    function isAuthorizeCredential(input) {
      return isRecord(input) && isRecord(input.Credential) && Object.keys(input).length === AUTHORIZE_CREDENTIAL_SIZE && typeof input.Credential.CredentialType === "string" && typeof input.Credential.Issuer === "string";
    }
    exports.isAuthorizeCredential = isAuthorizeCredential;
    function isMPTAmount(input) {
      return isRecord(input) && Object.keys(input).length === MPTOKEN_SIZE && typeof input.value === "string" && typeof input.mpt_issuance_id === "string";
    }
    exports.isMPTAmount = isMPTAmount;
    function isAccount(account) {
      return typeof account === "string" && ((0, ripple_address_codec_1.isValidClassicAddress)(account) || (0, ripple_address_codec_1.isValidXAddress)(account));
    }
    exports.isAccount = isAccount;
    function isAmount(amount) {
      return typeof amount === "string" || isIssuedCurrency(amount) || isMPTAmount(amount);
    }
    exports.isAmount = isAmount;
    function isXChainBridge(input) {
      return isRecord(input) && Object.keys(input).length === XCHAIN_BRIDGE_SIZE && typeof input.LockingChainDoor === "string" && isCurrency(input.LockingChainIssue) && typeof input.IssuingChainDoor === "string" && isCurrency(input.IssuingChainIssue);
    }
    exports.isXChainBridge = isXChainBridge;
    function validateRequiredField(tx, paramName, checkValidity) {
      if (tx[paramName] == null) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: missing field ${paramName}`);
      }
      if (!checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
      }
    }
    exports.validateRequiredField = validateRequiredField;
    function validateOptionalField(tx, paramName, checkValidity) {
      if (tx[paramName] !== void 0 && !checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
      }
    }
    exports.validateOptionalField = validateOptionalField;
    function validateBaseTransaction(common) {
      if (common.TransactionType === void 0) {
        throw new errors_1.ValidationError("BaseTransaction: missing field TransactionType");
      }
      if (typeof common.TransactionType !== "string") {
        throw new errors_1.ValidationError("BaseTransaction: TransactionType not string");
      }
      if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {
        throw new errors_1.ValidationError("BaseTransaction: Unknown TransactionType");
      }
      validateRequiredField(common, "Account", isString);
      validateOptionalField(common, "Fee", isString);
      validateOptionalField(common, "Sequence", isNumber);
      validateOptionalField(common, "AccountTxnID", isString);
      validateOptionalField(common, "LastLedgerSequence", isNumber);
      const memos = common.Memos;
      if (memos !== void 0 && !memos.every(isMemo)) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Memos");
      }
      const signers = common.Signers;
      if (signers !== void 0 && (signers.length === 0 || !signers.every(isSigner))) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Signers");
      }
      validateOptionalField(common, "SourceTag", isNumber);
      validateOptionalField(common, "SigningPubKey", isString);
      validateOptionalField(common, "TicketSequence", isNumber);
      validateOptionalField(common, "TxnSignature", isString);
      validateOptionalField(common, "NetworkID", isNumber);
    }
    exports.validateBaseTransaction = validateBaseTransaction;
    function parseAmountValue(amount) {
      if (!isAmount(amount)) {
        return NaN;
      }
      if (typeof amount === "string") {
        return parseFloat(amount);
      }
      return parseFloat(amount.value);
    }
    exports.parseAmountValue = parseAmountValue;
    function validateCredentialType(tx) {
      if (typeof tx.TransactionType !== "string") {
        throw new errors_1.ValidationError("Invalid TransactionType");
      }
      if (tx.CredentialType === void 0) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: missing field CredentialType`);
      }
      if (!isString(tx.CredentialType)) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be a string`);
      }
      if (tx.CredentialType.length === 0) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType cannot be an empty string`);
      } else if (tx.CredentialType.length > MAX_CREDENTIAL_TYPE_LENGTH) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType length cannot be > ${MAX_CREDENTIAL_TYPE_LENGTH}`);
      }
      if (!utils_1.HEX_REGEX.test(tx.CredentialType)) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be encoded in hex`);
      }
    }
    exports.validateCredentialType = validateCredentialType;
    function validateCredentialsList(credentials, transactionType, isStringID, maxCredentials) {
      if (credentials == null) {
        return;
      }
      if (!Array.isArray(credentials)) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials must be an array`);
      }
      if (credentials.length > maxCredentials) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials length cannot exceed ${maxCredentials} elements`);
      } else if (credentials.length === 0) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials cannot be an empty array`);
      }
      credentials.forEach((credential) => {
        if (isStringID) {
          if (!isString(credential)) {
            throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials ID list format`);
          }
        } else if (!isAuthorizeCredential(credential)) {
          throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials format`);
        }
      });
      if (containsDuplicates(credentials)) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials cannot contain duplicate elements`);
      }
    }
    exports.validateCredentialsList = validateCredentialsList;
    function isAuthorizeCredentialArray(list) {
      return typeof list[0] !== "string";
    }
    function containsDuplicates(objectList) {
      if (typeof objectList[0] === "string") {
        const objSet = new Set(objectList.map((obj) => JSON.stringify(obj)));
        return objSet.size !== objectList.length;
      }
      const seen = /* @__PURE__ */ new Set();
      if (isAuthorizeCredentialArray(objectList)) {
        for (const item of objectList) {
          const key = `${item.Credential.Issuer}-${item.Credential.CredentialType}`;
          if (seen.has(key)) {
            return true;
          }
          seen.add(key);
        }
      }
      return false;
    }
    exports.containsDuplicates = containsDuplicates;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/accountSet.js
var require_accountSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/accountSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAccountSet = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var AccountSetAsfFlags;
    (function(AccountSetAsfFlags2) {
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfRequireDest"] = 1] = "asfRequireDest";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfRequireAuth"] = 2] = "asfRequireAuth";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowXRP"] = 3] = "asfDisallowXRP";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisableMaster"] = 4] = "asfDisableMaster";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAccountTxnID"] = 5] = "asfAccountTxnID";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfNoFreeze"] = 6] = "asfNoFreeze";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfGlobalFreeze"] = 7] = "asfGlobalFreeze";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDefaultRipple"] = 8] = "asfDefaultRipple";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDepositAuth"] = 9] = "asfDepositAuth";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAuthorizedNFTokenMinter"] = 10] = "asfAuthorizedNFTokenMinter";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingNFTokenOffer"] = 12] = "asfDisallowIncomingNFTokenOffer";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingCheck"] = 13] = "asfDisallowIncomingCheck";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingPayChan"] = 14] = "asfDisallowIncomingPayChan";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingTrustline"] = 15] = "asfDisallowIncomingTrustline";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAllowTrustLineClawback"] = 16] = "asfAllowTrustLineClawback";
    })(AccountSetAsfFlags || (exports.AccountSetAsfFlags = AccountSetAsfFlags = {}));
    var AccountSetTfFlags;
    (function(AccountSetTfFlags2) {
      AccountSetTfFlags2[AccountSetTfFlags2["tfRequireDestTag"] = 65536] = "tfRequireDestTag";
      AccountSetTfFlags2[AccountSetTfFlags2["tfOptionalDestTag"] = 131072] = "tfOptionalDestTag";
      AccountSetTfFlags2[AccountSetTfFlags2["tfRequireAuth"] = 262144] = "tfRequireAuth";
      AccountSetTfFlags2[AccountSetTfFlags2["tfOptionalAuth"] = 524288] = "tfOptionalAuth";
      AccountSetTfFlags2[AccountSetTfFlags2["tfDisallowXRP"] = 1048576] = "tfDisallowXRP";
      AccountSetTfFlags2[AccountSetTfFlags2["tfAllowXRP"] = 2097152] = "tfAllowXRP";
    })(AccountSetTfFlags || (exports.AccountSetTfFlags = AccountSetTfFlags = {}));
    var MIN_TICK_SIZE = 3;
    var MAX_TICK_SIZE = 15;
    function validateAccountSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "NFTokenMinter", common_1.isAccount);
      if (tx.ClearFlag !== void 0) {
        if (typeof tx.ClearFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.ClearFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
      }
      if (tx.Domain !== void 0 && typeof tx.Domain !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid Domain");
      }
      if (tx.EmailHash !== void 0 && typeof tx.EmailHash !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid EmailHash");
      }
      if (tx.MessageKey !== void 0 && typeof tx.MessageKey !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid MessageKey");
      }
      if (tx.SetFlag !== void 0) {
        if (typeof tx.SetFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.SetFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
      }
      if (tx.TransferRate !== void 0 && typeof tx.TransferRate !== "number") {
        throw new errors_1.ValidationError("AccountSet: invalid TransferRate");
      }
      if (tx.TickSize !== void 0) {
        if (typeof tx.TickSize !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
        if (tx.TickSize !== 0 && (tx.TickSize < MIN_TICK_SIZE || tx.TickSize > MAX_TICK_SIZE)) {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
      }
    }
    exports.validateAccountSet = validateAccountSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMClawback.js
var require_AMMClawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMClawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMClawback = exports.AMMClawbackFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var AMMClawbackFlags;
    (function(AMMClawbackFlags2) {
      AMMClawbackFlags2[AMMClawbackFlags2["tfClawTwoAssets"] = 1] = "tfClawTwoAssets";
    })(AMMClawbackFlags || (exports.AMMClawbackFlags = AMMClawbackFlags = {}));
    function validateAMMClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Holder", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Asset", common_1.isCurrency);
      const asset = tx.Asset;
      const amount = tx.Amount;
      if (tx.Holder === asset.issuer) {
        throw new errors_1.ValidationError("AMMClawback: Holder and Asset.issuer must be distinct");
      }
      if (tx.Account !== asset.issuer) {
        throw new errors_1.ValidationError("AMMClawback: Account must be the same as Asset.issuer");
      }
      (0, common_1.validateRequiredField)(tx, "Asset2", common_1.isCurrency);
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isAmount);
      if (tx.Amount != null) {
        if (amount.currency !== asset.currency) {
          throw new errors_1.ValidationError("AMMClawback: Amount.currency must match Asset.currency");
        }
        if (amount.issuer !== asset.issuer) {
          throw new errors_1.ValidationError("AMMClawback: Amount.issuer must match Amount.issuer");
        }
      }
    }
    exports.validateAMMClawback = validateAMMClawback;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js
var require_AMMDeposit = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMDeposit = exports.AMMDepositFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var AMMDepositFlags;
    (function(AMMDepositFlags2) {
      AMMDepositFlags2[AMMDepositFlags2["tfLPToken"] = 65536] = "tfLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfSingleAsset"] = 524288] = "tfSingleAsset";
      AMMDepositFlags2[AMMDepositFlags2["tfTwoAsset"] = 1048576] = "tfTwoAsset";
      AMMDepositFlags2[AMMDepositFlags2["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfTwoAssetIfEmpty"] = 8388608] = "tfTwoAssetIfEmpty";
    })(AMMDepositFlags || (exports.AMMDepositFlags = AMMDepositFlags = {}));
    function validateAMMDeposit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMDeposit: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMDeposit: Asset2 must be a Currency");
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set Amount with Amount2");
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set Amount with EPrice");
      } else if (tx.LPTokenOut == null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set at least LPTokenOut or Amount");
      }
      if (tx.LPTokenOut != null && !(0, common_1.isIssuedCurrency)(tx.LPTokenOut)) {
        throw new errors_1.ValidationError("AMMDeposit: LPTokenOut must be an IssuedCurrencyAmount");
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMDeposit: Amount must be an Amount");
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMDeposit: Amount2 must be an Amount");
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError("AMMDeposit: EPrice must be an Amount");
      }
    }
    exports.validateAMMDeposit = validateAMMDeposit;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js
var require_AMMWithdraw = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMWithdraw = exports.AMMWithdrawFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var AMMWithdrawFlags;
    (function(AMMWithdrawFlags2) {
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfLPToken"] = 65536] = "tfLPToken";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfWithdrawAll"] = 131072] = "tfWithdrawAll";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfOneAssetWithdrawAll"] = 262144] = "tfOneAssetWithdrawAll";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfSingleAsset"] = 524288] = "tfSingleAsset";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfTwoAsset"] = 1048576] = "tfTwoAsset";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
    })(AMMWithdrawFlags || (exports.AMMWithdrawFlags = AMMWithdrawFlags = {}));
    function validateAMMWithdraw(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMWithdraw: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMWithdraw: Asset2 must be a Currency");
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMWithdraw: must set Amount with Amount2");
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMWithdraw: must set Amount with EPrice");
      }
      if (tx.LPTokenIn != null && !(0, common_1.isIssuedCurrency)(tx.LPTokenIn)) {
        throw new errors_1.ValidationError("AMMWithdraw: LPTokenIn must be an IssuedCurrencyAmount");
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMWithdraw: Amount must be an Amount");
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMWithdraw: Amount2 must be an Amount");
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError("AMMWithdraw: EPrice must be an Amount");
      }
    }
    exports.validateAMMWithdraw = validateAMMWithdraw;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenAuthorize.js
var require_MPTokenAuthorize = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenAuthorize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenAuthorize = exports.MPTokenAuthorizeFlags = void 0;
    var common_1 = require_common2();
    var MPTokenAuthorizeFlags;
    (function(MPTokenAuthorizeFlags2) {
      MPTokenAuthorizeFlags2[MPTokenAuthorizeFlags2["tfMPTUnauthorize"] = 1] = "tfMPTUnauthorize";
    })(MPTokenAuthorizeFlags || (exports.MPTokenAuthorizeFlags = MPTokenAuthorizeFlags = {}));
    function validateMPTokenAuthorize(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
    }
    exports.validateMPTokenAuthorize = validateMPTokenAuthorize;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceCreate.js
var require_MPTokenIssuanceCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceCreate = exports.MPTokenIssuanceCreateFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var MAX_AMT = "9223372036854775807";
    var MAX_TRANSFER_FEE = 5e4;
    var MPTokenIssuanceCreateFlags;
    (function(MPTokenIssuanceCreateFlags2) {
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanLock"] = 2] = "tfMPTCanLock";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTRequireAuth"] = 4] = "tfMPTRequireAuth";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanEscrow"] = 8] = "tfMPTCanEscrow";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanTrade"] = 16] = "tfMPTCanTrade";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanTransfer"] = 32] = "tfMPTCanTransfer";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanClawback"] = 64] = "tfMPTCanClawback";
    })(MPTokenIssuanceCreateFlags || (exports.MPTokenIssuanceCreateFlags = MPTokenIssuanceCreateFlags = {}));
    function validateMPTokenIssuanceCreate(tx) {
      var _a;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "MaximumAmount", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "MPTokenMetadata", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "TransferFee", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "AssetScale", common_1.isNumber);
      if (typeof tx.MPTokenMetadata === "string" && tx.MPTokenMetadata === "") {
        throw new errors_1.ValidationError("MPTokenIssuanceCreate: MPTokenMetadata must not be empty string");
      }
      if (typeof tx.MPTokenMetadata === "string" && !(0, utils_1.isHex)(tx.MPTokenMetadata)) {
        throw new errors_1.ValidationError("MPTokenIssuanceCreate: MPTokenMetadata must be in hex format");
      }
      if (typeof tx.MaximumAmount === "string") {
        if (!utils_1.INTEGER_SANITY_CHECK.exec(tx.MaximumAmount)) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: Invalid MaximumAmount");
        } else if (BigInt(tx.MaximumAmount) > BigInt(MAX_AMT) || BigInt(tx.MaximumAmount) < BigInt(`0`)) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: MaximumAmount out of range");
        }
      }
      if (typeof tx.TransferFee === "number") {
        const flags = tx.Flags;
        const isTfMPTCanTransfer = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceCreateFlags.tfMPTCanTransfer) : (_a = flags.tfMPTCanTransfer) !== null && _a !== void 0 ? _a : false;
        if (tx.TransferFee < 0 || tx.TransferFee > MAX_TRANSFER_FEE) {
          throw new errors_1.ValidationError(`MPTokenIssuanceCreate: TransferFee must be between 0 and ${MAX_TRANSFER_FEE}`);
        }
        if (tx.TransferFee && !isTfMPTCanTransfer) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: TransferFee cannot be provided without enabling tfMPTCanTransfer flag");
        }
      }
    }
    exports.validateMPTokenIssuanceCreate = validateMPTokenIssuanceCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceSet.js
var require_MPTokenIssuanceSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceSet = exports.MPTokenIssuanceSetFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var MPTokenIssuanceSetFlags;
    (function(MPTokenIssuanceSetFlags2) {
      MPTokenIssuanceSetFlags2[MPTokenIssuanceSetFlags2["tfMPTLock"] = 1] = "tfMPTLock";
      MPTokenIssuanceSetFlags2[MPTokenIssuanceSetFlags2["tfMPTUnlock"] = 2] = "tfMPTUnlock";
    })(MPTokenIssuanceSetFlags || (exports.MPTokenIssuanceSetFlags = MPTokenIssuanceSetFlags = {}));
    function validateMPTokenIssuanceSet(tx) {
      var _a, _b;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
      const flags = tx.Flags;
      const isTfMPTLock = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTLock) : (_a = flags.tfMPTLock) !== null && _a !== void 0 ? _a : false;
      const isTfMPTUnlock = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTUnlock) : (_b = flags.tfMPTUnlock) !== null && _b !== void 0 ? _b : false;
      if (isTfMPTLock && isTfMPTUnlock) {
        throw new errors_1.ValidationError("MPTokenIssuanceSet: flag conflict");
      }
    }
    exports.validateMPTokenIssuanceSet = validateMPTokenIssuanceSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js
var require_NFTokenCreateOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenCreateOffer = exports.NFTokenCreateOfferFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var NFTokenCreateOfferFlags;
    (function(NFTokenCreateOfferFlags2) {
      NFTokenCreateOfferFlags2[NFTokenCreateOfferFlags2["tfSellNFToken"] = 1] = "tfSellNFToken";
    })(NFTokenCreateOfferFlags || (exports.NFTokenCreateOfferFlags = NFTokenCreateOfferFlags = {}));
    function validateNFTokenSellOfferCases(tx) {
      if (tx.Owner != null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner must not be present for sell offers");
      }
    }
    function validateNFTokenBuyOfferCases(tx) {
      if (tx.Owner == null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner must be present for buy offers");
      }
      if ((0, common_1.parseAmountValue)(tx.Amount) <= 0) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Amount must be greater than 0 for buy offers");
      }
    }
    function validateNFTokenCreateOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Owner) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner and Account must not be equal");
      }
      if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Destination and Account must not be equal");
      }
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
      if (tx.NFTokenID == null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: missing field NFTokenID");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: invalid Amount");
      }
      if (typeof tx.Flags === "number" && (0, utils_1.isFlagEnabled)(tx.Flags, NFTokenCreateOfferFlags.tfSellNFToken)) {
        validateNFTokenSellOfferCases(tx);
      } else {
        validateNFTokenBuyOfferCases(tx);
      }
    }
    exports.validateNFTokenCreateOffer = validateNFTokenCreateOffer;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js
var require_NFTokenMint = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenMint = exports.NFTokenMintFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var NFTokenMintFlags;
    (function(NFTokenMintFlags2) {
      NFTokenMintFlags2[NFTokenMintFlags2["tfBurnable"] = 1] = "tfBurnable";
      NFTokenMintFlags2[NFTokenMintFlags2["tfOnlyXRP"] = 2] = "tfOnlyXRP";
      NFTokenMintFlags2[NFTokenMintFlags2["tfTrustLine"] = 4] = "tfTrustLine";
      NFTokenMintFlags2[NFTokenMintFlags2["tfTransferable"] = 8] = "tfTransferable";
      NFTokenMintFlags2[NFTokenMintFlags2["tfMutable"] = 16] = "tfMutable";
    })(NFTokenMintFlags || (exports.NFTokenMintFlags = NFTokenMintFlags = {}));
    function validateNFTokenMint(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Issuer) {
        throw new errors_1.ValidationError("NFTokenMint: Issuer must not be equal to Account");
      }
      (0, common_1.validateOptionalField)(tx, "Issuer", common_1.isAccount);
      if (typeof tx.URI === "string" && tx.URI === "") {
        throw new errors_1.ValidationError("NFTokenMint: URI must not be empty string");
      }
      if (typeof tx.URI === "string" && !(0, utils_1.isHex)(tx.URI)) {
        throw new errors_1.ValidationError("NFTokenMint: URI must be in hex format");
      }
      if (tx.NFTokenTaxon == null) {
        throw new errors_1.ValidationError("NFTokenMint: missing field NFTokenTaxon");
      }
      if (tx.Amount == null) {
        if (tx.Expiration != null || tx.Destination != null) {
          throw new errors_1.ValidationError("NFTokenMint: Amount is required when Expiration or Destination is present");
        }
      }
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "Expiration", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
    }
    exports.validateNFTokenMint = validateNFTokenMint;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/offerCreate.js
var require_offerCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/offerCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOfferCreate = exports.OfferCreateFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var OfferCreateFlags;
    (function(OfferCreateFlags2) {
      OfferCreateFlags2[OfferCreateFlags2["tfPassive"] = 65536] = "tfPassive";
      OfferCreateFlags2[OfferCreateFlags2["tfImmediateOrCancel"] = 131072] = "tfImmediateOrCancel";
      OfferCreateFlags2[OfferCreateFlags2["tfFillOrKill"] = 262144] = "tfFillOrKill";
      OfferCreateFlags2[OfferCreateFlags2["tfSell"] = 524288] = "tfSell";
    })(OfferCreateFlags || (exports.OfferCreateFlags = OfferCreateFlags = {}));
    function validateOfferCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.TakerGets === void 0) {
        throw new errors_1.ValidationError("OfferCreate: missing field TakerGets");
      }
      if (tx.TakerPays === void 0) {
        throw new errors_1.ValidationError("OfferCreate: missing field TakerPays");
      }
      if (typeof tx.TakerGets !== "string" && !(0, common_1.isAmount)(tx.TakerGets)) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerGets");
      }
      if (typeof tx.TakerPays !== "string" && !(0, common_1.isAmount)(tx.TakerPays)) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerPays");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("OfferCreate: invalid Expiration");
      }
      if (tx.OfferSequence !== void 0 && typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError("OfferCreate: invalid OfferSequence");
      }
    }
    exports.validateOfferCreate = validateOfferCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/payment.js
var require_payment = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/payment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePayment = exports.PaymentFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var PaymentFlags;
    (function(PaymentFlags2) {
      PaymentFlags2[PaymentFlags2["tfNoRippleDirect"] = 65536] = "tfNoRippleDirect";
      PaymentFlags2[PaymentFlags2["tfPartialPayment"] = 131072] = "tfPartialPayment";
      PaymentFlags2[PaymentFlags2["tfLimitQuality"] = 262144] = "tfLimitQuality";
    })(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));
    function validatePayment(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentTransaction: missing field Amount");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid Amount");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError("PaymentTransaction: InvoiceID must be a string");
      }
      if (tx.Paths !== void 0 && !isPaths(tx.Paths)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid Paths");
      }
      if (tx.SendMax !== void 0 && !(0, common_1.isAmount)(tx.SendMax)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid SendMax");
      }
      checkPartialPayment(tx);
    }
    exports.validatePayment = validatePayment;
    function checkPartialPayment(tx) {
      var _a;
      if (tx.DeliverMin != null) {
        if (tx.Flags == null) {
          throw new errors_1.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
        }
        const flags = tx.Flags;
        const isTfPartialPayment = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment) : (_a = flags.tfPartialPayment) !== null && _a !== void 0 ? _a : false;
        if (!isTfPartialPayment) {
          throw new errors_1.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
        }
        if (!(0, common_1.isAmount)(tx.DeliverMin)) {
          throw new errors_1.ValidationError("PaymentTransaction: invalid DeliverMin");
        }
      }
    }
    function isPathStep(pathStep) {
      if (pathStep.account !== void 0 && typeof pathStep.account !== "string") {
        return false;
      }
      if (pathStep.currency !== void 0 && typeof pathStep.currency !== "string") {
        return false;
      }
      if (pathStep.issuer !== void 0 && typeof pathStep.issuer !== "string") {
        return false;
      }
      if (pathStep.account !== void 0 && pathStep.currency === void 0 && pathStep.issuer === void 0) {
        return true;
      }
      if (pathStep.currency !== void 0 || pathStep.issuer !== void 0) {
        return true;
      }
      return false;
    }
    function isPath(path) {
      for (const pathStep of path) {
        if (!isPathStep(pathStep)) {
          return false;
        }
      }
      return true;
    }
    function isPaths(paths) {
      if (!Array.isArray(paths) || paths.length === 0) {
        return false;
      }
      for (const path of paths) {
        if (!Array.isArray(path) || path.length === 0) {
          return false;
        }
        if (!isPath(path)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js
var require_paymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelClaim = exports.PaymentChannelClaimFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var PaymentChannelClaimFlags;
    (function(PaymentChannelClaimFlags2) {
      PaymentChannelClaimFlags2[PaymentChannelClaimFlags2["tfRenew"] = 65536] = "tfRenew";
      PaymentChannelClaimFlags2[PaymentChannelClaimFlags2["tfClose"] = 131072] = "tfClose";
    })(PaymentChannelClaimFlags || (exports.PaymentChannelClaimFlags = PaymentChannelClaimFlags = {}));
    function validatePaymentChannelClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError("PaymentChannelClaim: missing Channel");
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Channel must be a string");
      }
      if (tx.Balance !== void 0 && typeof tx.Balance !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Balance must be a string");
      }
      if (tx.Amount !== void 0 && typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Amount must be a string");
      }
      if (tx.Signature !== void 0 && typeof tx.Signature !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Signature must be a string");
      }
      if (tx.PublicKey !== void 0 && typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: PublicKey must be a string");
      }
    }
    exports.validatePaymentChannelClaim = validatePaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/trustSet.js
var require_trustSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/trustSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTrustSet = exports.TrustSetFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var TrustSetFlags;
    (function(TrustSetFlags2) {
      TrustSetFlags2[TrustSetFlags2["tfSetfAuth"] = 65536] = "tfSetfAuth";
      TrustSetFlags2[TrustSetFlags2["tfSetNoRipple"] = 131072] = "tfSetNoRipple";
      TrustSetFlags2[TrustSetFlags2["tfClearNoRipple"] = 262144] = "tfClearNoRipple";
      TrustSetFlags2[TrustSetFlags2["tfSetFreeze"] = 1048576] = "tfSetFreeze";
      TrustSetFlags2[TrustSetFlags2["tfClearFreeze"] = 2097152] = "tfClearFreeze";
      TrustSetFlags2[TrustSetFlags2["tfSetDeepFreeze"] = 4194304] = "tfSetDeepFreeze";
      TrustSetFlags2[TrustSetFlags2["tfClearDeepFreeze"] = 8388608] = "tfClearDeepFreeze";
    })(TrustSetFlags || (exports.TrustSetFlags = TrustSetFlags = {}));
    function validateTrustSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { LimitAmount, QualityIn, QualityOut } = tx;
      if (LimitAmount === void 0) {
        throw new errors_1.ValidationError("TrustSet: missing field LimitAmount");
      }
      if (!(0, common_1.isAmount)(LimitAmount)) {
        throw new errors_1.ValidationError("TrustSet: invalid LimitAmount");
      }
      if (QualityIn !== void 0 && typeof QualityIn !== "number") {
        throw new errors_1.ValidationError("TrustSet: QualityIn must be a number");
      }
      if (QualityOut !== void 0 && typeof QualityOut !== "number") {
        throw new errors_1.ValidationError("TrustSet: QualityOut must be a number");
      }
    }
    exports.validateTrustSet = validateTrustSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js
var require_XChainModifyBridge = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainModifyBridge = exports.XChainModifyBridgeFlags = void 0;
    var common_1 = require_common2();
    var XChainModifyBridgeFlags;
    (function(XChainModifyBridgeFlags2) {
      XChainModifyBridgeFlags2[XChainModifyBridgeFlags2["tfClearAccountCreateAmount"] = 65536] = "tfClearAccountCreateAmount";
    })(XChainModifyBridgeFlags || (exports.XChainModifyBridgeFlags = XChainModifyBridgeFlags = {}));
    function validateXChainModifyBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateOptionalField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "MinAccountCreateAmount", common_1.isAmount);
    }
    exports.validateXChainModifyBridge = validateXChainModifyBridge;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/utils/flags.js
var require_flags = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/utils/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = void 0;
    var errors_1 = require_errors();
    var AccountRoot_1 = require_AccountRoot();
    var accountSet_1 = require_accountSet();
    var AMMClawback_1 = require_AMMClawback();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var offerCreate_1 = require_offerCreate();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var trustSet_1 = require_trustSet();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    var _1 = require_utils4();
    function parseAccountRootFlags(flags) {
      const flagsInterface = {};
      Object.values(AccountRoot_1.AccountRootFlags).forEach((flag) => {
        if (typeof flag === "string" && (0, _1.isFlagEnabled)(flags, AccountRoot_1.AccountRootFlags[flag])) {
          flagsInterface[flag] = true;
        }
      });
      return flagsInterface;
    }
    exports.parseAccountRootFlags = parseAccountRootFlags;
    var txToFlag = {
      AccountSet: accountSet_1.AccountSetTfFlags,
      AMMClawback: AMMClawback_1.AMMClawbackFlags,
      AMMDeposit: AMMDeposit_1.AMMDepositFlags,
      AMMWithdraw: AMMWithdraw_1.AMMWithdrawFlags,
      MPTokenAuthorize: MPTokenAuthorize_1.MPTokenAuthorizeFlags,
      MPTokenIssuanceCreate: MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags,
      MPTokenIssuanceSet: MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags,
      NFTokenCreateOffer: NFTokenCreateOffer_1.NFTokenCreateOfferFlags,
      NFTokenMint: NFTokenMint_1.NFTokenMintFlags,
      OfferCreate: offerCreate_1.OfferCreateFlags,
      PaymentChannelClaim: paymentChannelClaim_1.PaymentChannelClaimFlags,
      Payment: payment_1.PaymentFlags,
      TrustSet: trustSet_1.TrustSetFlags,
      XChainModifyBridge: XChainModifyBridge_1.XChainModifyBridgeFlags
    };
    function isTxToFlagKey(transactionType) {
      return transactionType in txToFlag;
    }
    function setTransactionFlagsToNumber(tx) {
      console.warn("This function is deprecated. Use convertTxFlagsToNumber() instead and use the returned value to modify the Transaction.Flags from the caller.");
      if (tx.Flags) {
        tx.Flags = convertTxFlagsToNumber(tx);
      }
    }
    exports.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
    function convertTxFlagsToNumber(tx) {
      if (!tx.Flags) {
        return 0;
      }
      if (typeof tx.Flags === "number") {
        return tx.Flags;
      }
      if (isTxToFlagKey(tx.TransactionType)) {
        const flagEnum = txToFlag[tx.TransactionType];
        return Object.keys(tx.Flags).reduce((resultFlags, flag) => {
          var _a;
          if (flagEnum[flag] == null) {
            throw new errors_1.ValidationError(`Invalid flag ${flag}. Valid flags are ${JSON.stringify(flagEnum)}`);
          }
          return ((_a = tx.Flags) === null || _a === void 0 ? void 0 : _a[flag]) ? resultFlags | flagEnum[flag] : resultFlags;
        }, 0);
      }
      return 0;
    }
    exports.convertTxFlagsToNumber = convertTxFlagsToNumber;
    function parseTransactionFlags(tx) {
      const flags = convertTxFlagsToNumber(tx);
      if (flags === 0) {
        return {};
      }
      const booleanFlagMap = {};
      if (isTxToFlagKey(tx.TransactionType)) {
        const transactionTypeFlags = txToFlag[tx.TransactionType];
        Object.values(transactionTypeFlags).forEach((flag) => {
          if (typeof flag === "string" && (0, _1.isFlagEnabled)(flags, transactionTypeFlags[flag])) {
            booleanFlagMap[flag] = true;
          }
        });
      }
      return booleanFlagMap;
    }
    exports.parseTransactionFlags = parseTransactionFlags;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K2;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K2 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K2 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K2 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K2 = 3395469782;
          }
          const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K2 + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA1 = SHA1;
    exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = Math.pow(2, 32);
    var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
    var MD5_IV = SHA1_IV.slice(0, 4);
    var MD5_W = new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = 7 * i % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.MD5 = MD5;
    exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
    var idxLR = (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    var idxL = (() => idxLR[0])();
    var idxR = (() => idxLR[1])();
    var shifts160 = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var Kl160 = Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr160 = Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      if (group === 1)
        return x & y | ~x & z;
      if (group === 2)
        return (x | ~y) ^ z;
      if (group === 3)
        return x & z | y & ~z;
      return x ^ (y | ~z);
    }
    var BUF_160 = new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var legacy_ts_1 = require_legacy();
    exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
    exports.ripemd160 = legacy_ts_1.ripemd160;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/ripemd160/browser.js
var require_browser4 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/ripemd160/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.ripemd160 = (0, wrapNoble_1.default)(ripemd160_1.ripemd160);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    exports.abool = abool;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.equalBytes = equalBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.isHash = isHash;
    exports._validateObject = _validateObject;
    exports.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_1n << BigInt(n)) - _1n;
    exports.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils5();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      return FpPow(Field(modulo), num, power);
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n2 = Fp.mul(n, _2n);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    }
    function tonelliShanks(P) {
      if (P < BigInt(3))
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n;
      let S = 0;
      while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
      }
      let Z = _2n;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
          return n;
        if (FpLegendre(Fp, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n)
        return sqrt3mod4;
      if (P % _8n === _5n)
        return sqrt5mod8;
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return Fp.ONE;
      if (power === _1n)
        return num;
      let p = Fp.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_ts_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.negateCt = negateCt;
    exports.normalizeZ = normalizeZ;
    exports.wNAF = wNAF;
    exports.mulEndoUnsafe = mulEndoUnsafe;
    exports.pippenger = pippenger;
    exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports.validateBasic = validateBasic;
    exports._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, property, points) {
      const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
      const toInv = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(getz));
      const affined = points.map((p, i) => p.toAffine(toInv[i]));
      return affined.map(c.fromAffine);
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n)
        throw new Error("invalid wNAF");
    }
    function wNAF(c, bits) {
      return {
        constTimeNegate: negateCt,
        hasPrecomputes(elm) {
          return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder(elm, n, p = c.ZERO) {
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = calcWOpts(W, bits);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          let p = c.ZERO;
          let f = c.BASE;
          const wo = calcWOpts(W, bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              f = f.add(negateCt(isNegF, precomputes[offsetF]));
            } else {
              p = p.add(negateCt(isNeg, precomputes[offset]));
            }
          }
          assert0(n);
          return { p, f };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
          const wo = calcWOpts(W, bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            if (n === _0n)
              break;
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              continue;
            } else {
              const item = precomputes[offset];
              acc = acc.add(isNeg ? item.negate() : item);
            }
          }
          assert0(n);
          return acc;
        },
        getPrecomputes(W, P, transform) {
          let comp = pointPrecomputes.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              if (typeof transform === "function")
                comp = transform(comp);
              pointPrecomputes.set(P, comp);
            }
          }
          return comp;
        },
        wNAFCached(P, n, transform) {
          const W = getW(P);
          return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe(P, n, transform, prev) {
          const W = getW(P);
          if (W === 1)
            return this.unsafeLadder(P, n, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
          validateW(W, bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
      };
    }
    function mulEndoUnsafe(c, point, k1, k2) {
      let acc = point;
      let p1 = c.ZERO;
      let p2 = c.ZERO;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
          p1 = p1.add(acc);
        if (k2 & _1n)
          p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      return { p1, p2 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order);
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}) {
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE[p];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp);
      const Fn = createField(CURVE.n, curveOpts.Fn);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp.isValid(CURVE[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      return { Fp, Fn };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = exports.DERErr = void 0;
    exports._legacyHelperEquat = _legacyHelperEquat;
    exports._legacyHelperNormPriv = _legacyHelperNormPriv;
    exports.weierstrassN = weierstrassN;
    exports.weierstrassPoints = weierstrassPoints;
    exports.ecdsa = ecdsa;
    exports.weierstrass = weierstrass;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var hmac_js_1 = require_hmac();
    var utils_ts_1 = require_utils5();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    function validateSigVerOpts(opts) {
      if (opts.lowS !== void 0)
        (0, utils_ts_1.abool)("lowS", opts.lowS);
      if (opts.prehash !== void 0)
        (0, utils_ts_1.abool)("prehash", opts.prehash);
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports.DERErr = DERErr;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports.DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
      const { BYTES: expected } = Fn;
      function normPrivateKeyToScalar(key) {
        let num;
        if (typeof key === "bigint") {
          num = key;
        } else {
          let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
          if (allowedPrivateKeyLengths) {
            if (!allowedPrivateKeyLengths.includes(bytes.length * 2))
              throw new Error("invalid private key");
            const padded = new Uint8Array(expected);
            padded.set(bytes, padded.length - bytes.length);
            bytes = padded;
          }
          try {
            num = Fn.fromBytes(bytes);
          } catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
          }
        }
        if (wrapPrivateKey)
          num = Fn.create(num);
        if (!Fn.isValidNot0(num))
          throw new Error("invalid private key: out of range [1..N-1]");
        return num;
      }
      return normPrivateKeyToScalar;
    }
    function weierstrassN(CURVE, curveOpts = {}) {
      const { Fp, Fn } = (0, curve_ts_1._createCurveFields)("weierstrass", CURVE, curveOpts);
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(curveOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = curveOpts;
      if (endo) {
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        }
      }
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1.abool)("isCompressed", isCompressed);
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1.abytes)(bytes);
        const L = Fp.BYTES;
        const LC = L + 1;
        const LU = 2 * L + 1;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === LC && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (length === LU && head === 4) {
          const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));
          const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));
          if (!isValidXY(x, y))
            throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
        }
      }
      const toBytes = curveOpts.toBytes || pointToBytes;
      const fromBytes = curveOpts.fromBytes || pointFromBytes;
      const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        if (Fp.eql(z, Fp.ONE))
          return { x, y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
          if (curveOpts.allowInfinityPoint && !Fp.is0(p.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(px, py, pz) {
          this.px = acoord("x", px);
          this.py = acoord("y", py, true);
          this.pz = acoord("z", pz);
          Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, "pz", points);
        }
        static fromBytes(bytes) {
          (0, utils_ts_1.abytes)(bytes);
          return Point.fromHex(bytes);
        }
        /** Converts hash string or Uint8Array to Point. */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        /** Multiplies generator point by privateKey. */
        static fromPrivateKey(privateKey) {
          const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        /** Multiscalar Multiplication */
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.setWindowSize(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        /** "Private method", don't use it directly */
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = curveOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) => wnaf.wNAFCached(this, n, Point.normalizeZ);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p, f } = mul(scalar);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = curveOpts;
          const p = this;
          if (!Fn.isValid(sc))
            throw new Error("invalid scalar: out of range");
          if (sc === _0n || p.is0())
            return Point.ZERO;
          if (sc === _1n)
            return p;
          if (wnaf.hasPrecomputes(this))
            return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
            const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
            return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
          } else {
            return wnaf.wNAFCachedUnsafe(p, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = curveOpts;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = curveOpts;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1.abool)("isCompressed", isCompressed);
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        /** @deprecated use `toBytes` */
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = (0, curve_ts_1.wNAF)(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);
      return Point;
    }
    function weierstrassPoints(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point);
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function ecdsa(Point, ecdsaOpts, curveOpts = {}) {
      (0, utils_ts_1._validateObject)(ecdsaOpts, { hash: "function" }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
      }
      function aValidRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
      }
      class Signature {
        constructor(r, s, recovery) {
          aValidRS("r", r);
          aValidRS("s", s);
          this.r = r;
          this.s = s;
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const L = Fn.BYTES;
          const b = (0, utils_ts_1.ensureBytes)("compactSignature", hex, L * 2);
          return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        /**
         * @todo remove
         * @deprecated
         */
        assertValidity() {
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        // ProjPointType<bigint>
        recoverPublicKey(msgHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point.fromHex((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
          const ir = Fn.inv(radj);
          const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", msgHash));
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0())
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toBytes(format) {
          if (format === "compact")
            return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
          throw new Error("invalid format");
        }
        // DER-encoded
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const n = CURVE_ORDER;
          return (0, modular_ts_1.mapHashToField)(randomBytes_((0, modular_ts_1.getMinHashLength)(n)), n);
        },
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toBytes(isCompressed);
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point)
          return true;
        const arr = (0, utils_ts_1.ensureBytes)("key", item);
        const length = arr.length;
        const L = Fp.BYTES;
        const LC = L + 1;
        const LU = 2 * L + 1;
        if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
          return void 0;
        } else {
          return length === LC || length === LU;
        }
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicB) === false)
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
      }
      const bits2int = ecdsaOpts.bits2int || function(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
        const delta = bytes.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes) {
        return Fn.create(bits2int(bytes));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash } = ecdsaOpts;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash)
          msgHash = (0, utils_ts_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes_(Fp.BYTES) : ent;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k))
            return;
          const ik = Fn.inv(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n)
            return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
      const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
        return drbg(seed, k2sig);
      }
      Point.BASE.precompute(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        validateSigVerOpts(opts);
        const { lowS, prehash, format } = opts;
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        if (format !== void 0 && !["compact", "der", "js"].includes(format))
          throw new Error('format must be "compact", "der" or "js"');
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let _sig = void 0;
        let P;
        try {
          if (isObj) {
            if (format === void 0 || format === "js") {
              _sig = new Signature(sg.r, sg.s);
            } else {
              throw new Error("invalid format");
            }
          }
          if (isHex) {
            try {
              if (format !== "compact")
                _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
            }
            if (!_sig && format !== "der")
              _sig = Signature.fromCompact(sg);
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          return false;
        }
        if (!_sig)
          return false;
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = ecdsaOpts.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = Fn.inv(s);
        const u1 = Fn.create(h * is);
        const u2 = Fn.create(r * is);
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn.create(R.x);
        return v === r;
      }
      return Object.freeze({
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        utils,
        Point,
        Signature
      });
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength);
      const curveOpts = {
        Fp,
        Fn,
        allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        wrapPrivateKey: c.wrapPrivateKey,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hash: c.hash,
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
      };
      return { CURVE, curveOpts, ecdsaOpts };
    }
    function _weierstrass_new_output_to_legacy(c, Point) {
      const { Fp, Fn } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
      return Object.assign({}, {
        CURVE: c,
        Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c, ecdsa2) {
      return Object.assign({}, ecdsa2, {
        ProjectivePoint: ecdsa2.Point,
        CURVE: c
      });
    }
    function weierstrass(c) {
      const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, ecdsaOpts, curveOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash) {
      return { hash };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash });
      return { ...create(defHash), create };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      (0, utils_ts_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      (0, utils_ts_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      if (!(0, utils_ts_1.isBytes)(_DST) && typeof _DST !== "string")
        throw new Error("DST must be string or uint8array");
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
          return Point.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const dst = defaults.DST ? defaults.DST : {};
          const opts = Object.assign({}, defaults, dst, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map(u[0]);
          const u1 = map(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const dst = defaults.encodeDST ? defaults.encodeDST : {};
          const opts = Object.assign({}, defaults, dst, options);
          const u = hash_to_field(msg, 1, opts);
          return clear(map(u[0]));
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        }
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils5();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
      ...secp256k1_CURVE,
      Fp: Fpk1,
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1_CURVE.n;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_ts_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_ts_1.mod)(x, secp256k1_CURVE.p);
    var modN = (x) => (0, modular_ts_1.mod)(x, secp256k1_CURVE.n);
    var Point = (() => exports.secp256k1.Point)();
    var hasEven = (y) => y % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = hasEven(p.y) ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      (0, utils_ts_1.aInRange)("x", x, _1n, secp256k1_CURVE.p);
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (!hasEven(y))
        y = modP(-y);
      const p = Point.fromAffine({ x, y });
      p.assertValidity();
      return p;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return modN(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN(num(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_ts_1.numberToBytesBE,
        bytesToNumberBE: utils_ts_1.bytesToNumberBE,
        taggedHash,
        mod: modular_ts_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_utils5(), exports);
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/Sha512.js
var require_Sha512 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/Sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha512_1 = require_browser3();
    var utils_1 = require_utils6();
    var Sha512 = class _Sha512 {
      constructor() {
        this.hash = sha512_1.sha512.create();
      }
      static half(input) {
        return new _Sha512().add(input).first256();
      }
      add(bytes) {
        this.hash.update(bytes);
        return this;
      }
      addU32(i) {
        const buffer = new Uint8Array(4);
        new DataView(buffer.buffer).setUint32(0, i);
        return this.add(buffer);
      }
      finish() {
        return this.hash.digest();
      }
      first256() {
        return this.finish().slice(0, 32);
      }
      first256BigInt() {
        return (0, utils_1.bytesToNumberBE)(this.first256());
      }
    };
    exports.default = Sha512;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js
var require_utils7 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
    var secp256k1_1 = require_secp256k1();
    var Sha512_1 = __importDefault(require_Sha512());
    var ZERO = BigInt(0);
    function deriveScalar(bytes, discrim) {
      const order = secp256k1_1.secp256k1.CURVE.n;
      for (let i = 0; i <= 4294967295; i++) {
        const hasher = new Sha512_1.default().add(bytes);
        if (discrim !== void 0) {
          hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BigInt();
        if (key > ZERO && key < order) {
          return key;
        }
      }
      throw new Error("impossible unicorn ;)");
    }
    function derivePrivateKey(seed, opts = {}) {
      const root = opts.validator;
      const order = secp256k1_1.secp256k1.CURVE.n;
      const privateGen = deriveScalar(seed);
      if (root) {
        return privateGen;
      }
      const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
      const accountIndex = opts.accountIndex || 0;
      return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
    }
    exports.derivePrivateKey = derivePrivateKey;
    function accountPublicFromPublicGenerator(publicGenBytes) {
      const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
      const scalar = deriveScalar(publicGenBytes, 0);
      const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);
      const offset = rootPubPoint.add(point);
      return offset.toRawBytes(true);
    }
    exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assertHelper = {
      ok(cond, message) {
        if (!cond) {
          throw new Error(message);
        }
      }
    };
    exports.default = assertHelper;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js
var require_getAlgorithmFromKey = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
    var Prefix;
    (function(Prefix2) {
      Prefix2[Prefix2["NONE"] = -1] = "NONE";
      Prefix2[Prefix2["ED25519"] = 237] = "ED25519";
      Prefix2[Prefix2["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
      Prefix2[Prefix2["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
      Prefix2[Prefix2["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
      Prefix2[Prefix2["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
    })(Prefix || (Prefix = {}));
    var KEY_TYPES = {
      [`private_${Prefix.NONE}_32`]: "ecdsa-secp256k1",
      [`private_${Prefix.SECP256K1_PRIVATE}_33`]: "ecdsa-secp256k1",
      [`private_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.SECP256K1_PUB_X}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_XY}_65`]: "ecdsa-secp256k1"
    };
    function getKeyInfo(key) {
      return {
        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
        len: key.length / 2
      };
    }
    function prefixRepr(prefix) {
      return prefix === Prefix.NONE ? "None" : `0x${prefix.toString(16).padStart(2, "0")}`;
    }
    function getValidFormatsTable(type) {
      const padding = 2;
      const colWidth = {
        algorithm: "ecdsa-secp256k1".length + padding,
        prefix: "0x00".length + padding
      };
      return Object.entries(KEY_TYPES).filter(([key]) => key.startsWith(type)).map(([key, algorithm]) => {
        const [, prefix, length] = key.split("_");
        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
        const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);
        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
      }).join("\n");
    }
    function keyError({ key, type, prefix, len }) {
      const validFormats = getValidFormatsTable(type);
      return `invalid_key:

Type: ${type}
Key: ${key}
Prefix: ${prefixRepr(prefix)} 
Length: ${len} bytes

Acceptable ${type} formats are:
${validFormats}
`;
    }
    function getAlgorithmFromKey(key, type) {
      const { prefix, len } = getKeyInfo(key);
      const usedPrefix = type === "private" && len === 32 ? Prefix.NONE : prefix;
      const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];
      if (!algorithm) {
        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));
      }
      return algorithm;
    }
    exports.getAlgorithmFromKey = getAlgorithmFromKey;
    function getAlgorithmFromPublicKey(key) {
      return getAlgorithmFromKey(key, "public");
    }
    exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
    function getAlgorithmFromPrivateKey(key) {
      return getAlgorithmFromKey(key, "private");
    }
    exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js
var require_secp256k12 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils6();
    var secp256k1_1 = require_secp256k1();
    var utils_2 = require_browser();
    var utils_3 = require_utils7();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var SECP256K1_PREFIX = "00";
    var secp256k1 = {
      deriveKeypair(entropy, options) {
        const derived = (0, utils_3.derivePrivateKey)(entropy, options);
        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));
        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX) || privateKey.length === 64);
        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
        return secp256k1_1.secp256k1.sign(Sha512_1.default.half(message), normedPrivateKey, {
          // "Canonical" signatures
          lowS: true,
          // Would fail tests if signatures aren't deterministic
          extraEntropy: void 0
        }).toDERHex(true).toUpperCase();
      },
      verify(message, signature, publicKey) {
        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);
        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);
      }
    };
    exports.default = secp256k1;
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edwards = edwards;
    exports.eddsa = eddsa;
    exports.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils5();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    var VERIFY_DEFAULT = { zip215: true };
    function isEdValidXY(Fp, CURVE, x, y) {
      const x2 = Fp.sqr(x);
      const y2 = Fp.sqr(y);
      const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
      return Fp.eql(left, right);
    }
    function edwards(CURVE, curveOpts = {}) {
      const { Fp, Fn } = (0, curve_ts_1._createCurveFields)("edwards", CURVE, curveOpts);
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(curveOpts, {}, { uvRatio: "function" });
      const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
      const modP = (n) => Fp.create(n);
      const uvRatio = curveOpts.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
        } catch (e) {
          return { isValid: false, value: _0n };
        }
      });
      if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(ex, ey, ez, et) {
          this.ex = acoord("x", ex);
          this.ey = acoord("y", ey);
          this.ez = acoord("z", ez, true);
          this.et = acoord("t", et);
          Object.freeze(this);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static fromAffine(p) {
          if (p instanceof Point)
            throw new Error("extended point not allowed");
          const { x, y } = p || {};
          acoord("x", x);
          acoord("y", y);
          return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, "ez", points);
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.setWindowSize(this, windowSize);
          if (!isLazy)
            this.multiply(_2n);
          return this;
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { ex: X1, ey: Y1, ez: Z1 } = this;
          const { ex: X2, ey: Y2, ez: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { ex: X1, ey: Y1, ez: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE;
          const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
          const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          const n = scalar;
          (0, utils_ts_1.aInRange)("scalar", n, _1n, CURVE_ORDER);
          const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);
          return Point.normalizeZ([p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          const n = scalar;
          (0, utils_ts_1.aInRange)("scalar", n, _0n, CURVE_ORDER);
          if (n === _0n)
            return Point.ZERO;
          if (this.is0() || n === _1n)
            return this;
          return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        static fromBytes(bytes, zip215 = false) {
          (0, utils_ts_1.abytes)(bytes);
          return this.fromHex(bytes, zip215);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
          const { d, a } = CURVE;
          const len = Fp.BYTES;
          hex = (0, utils_ts_1.ensureBytes)("pointHex", hex, len);
          (0, utils_ts_1.abool)("zip215", zip215);
          const normed = hex.slice();
          const lastByte = hex[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("pointHex.y", y, _0n, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid)
            throw new Error("Point.fromHex: invalid y coordinate");
          const isXOdd = (x & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n && isLastByteOdd)
            throw new Error("Point.fromHex: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        static fromPrivateScalar(scalar) {
          return Point.BASE.multiply(scalar);
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = (0, utils_ts_1.numberToBytesLE)(y, Fp.BYTES);
          bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
          return bytes;
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
          return this.toBytes();
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const wnaf = (0, curve_ts_1.wNAF)(Point, Fn.BYTES * 8);
      return Point;
    }
    function eddsa(Point, eddsaOpts) {
      (0, utils_ts_1._validateObject)(eddsaOpts, {
        hash: "function"
      }, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash, hash: cHash } = eddsaOpts;
      const { BASE: G, Fp, Fn } = Point;
      const CURVE_ORDER = Fn.ORDER;
      const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
        (0, utils_ts_1.abool)("phflag", phflag);
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data;
      });
      function modN(a) {
        return Fn.create(a);
      }
      function modN_LE(hash) {
        return modN((0, utils_ts_1.bytesToNumberLE)(hash));
      }
      function getPrivateScalar(key) {
        const len = Fp.BYTES;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(key) {
        const { head, prefix, scalar } = getPrivateScalar(key);
        const point = G.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign(msg, privKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg);
        const R = G.multiply(r).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = modN(r + k * scalar);
        (0, utils_ts_1.aInRange)("signature.s", s, _0n, CURVE_ORDER);
        const L = Fp.BYTES;
        const res = (0, utils_ts_1.concatBytes)(R, (0, utils_ts_1.numberToBytesLE)(s, L));
        return (0, utils_ts_1.ensureBytes)("result", res, L * 2);
      }
      const verifyOpts = VERIFY_DEFAULT;
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, 2 * len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, len);
        if (zip215 !== void 0)
          (0, utils_ts_1.abool)("zip215", zip215);
        if (prehash)
          msg = prehash(msg);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.slice(len, 2 * len));
        let A, R, SB;
        try {
          A = Point.fromHex(publicKey, zip215);
          R = Point.fromHex(sig.slice(0, len), zip215);
          SB = G.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      G.precompute(8);
      const utils = {
        getExtendedPublicKey,
        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
        randomPrivateKey: () => randomBytes_(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return { getPublicKey, sign, verify, utils, Point };
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
      const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        hash: c.hash,
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
      };
      return { CURVE, curveOpts, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.montgomery = montgomery;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
      const maxScalar = minScalar + maxAdded + _1n;
      const modP = (n) => (0, modular_ts_1.mod)(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)("u", u, _0n, P);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k >> t & _1n;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey) => scalarMultBase(privateKey),
        utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
        GuBytes: GuBytes.slice()
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
    exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils5();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var ed25519_CURVE = {
      p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    };
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ed25519_CURVE.p;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
      const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
      const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
      const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
      const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
      const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
      const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
      const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
      const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio(u, v) {
      const P = ed25519_CURVE.p;
      const v3 = (0, modular_ts_1.mod)(v * v * v, P);
      const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_ts_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    exports.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    var Fp = (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, void 0, true))();
    var ed25519Defaults = (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
    }
    exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha2_js_1.sha512
    })))();
    exports.x25519 = (() => {
      const P = ed25519_CURVE.p;
      return (0, montgomery_ts_1.montgomery)({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    function edwardsToMontgomeryPub(edwardsPub) {
      const bpub = (0, utils_ts_1.ensureBytes)("pub", edwardsPub);
      const { y } = exports.ed25519.Point.fromHex(bpub);
      const _1n2 = BigInt(1);
      return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
    }
    exports.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
      return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
    }
    var ELL2_C1 = (() => (Fp.ORDER + _3n) / _8n)();
    var ELL2_C2 = (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (Fp.ORDER - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
      return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
    }
    exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha512
    }))();
    exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
    function aristp(other) {
      if (!(other instanceof RistPoint))
        throw new Error("RistrettoPoint expected");
    }
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
    function calcElligatorRistrettoMap(r0) {
      const { d } = exports.ed25519.CURVE;
      const P = exports.ed25519.CURVE.Fp.ORDER;
      const mod = exports.ed25519.CURVE.Fp.create;
      const r = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r) * mod(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
      let s_ = mod(s * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
      const s2 = s * s;
      const W0 = mod((s + s) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s2);
      const W3 = mod(_1n + s2);
      return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    var RistPoint = class _RistPoint {
      // Private property to discourage combining ExtendedPoint + RistrettoPoint
      // Always use Ristretto encoding/decoding instead.
      constructor(ep) {
        this.ep = ep;
      }
      static fromAffine(ap) {
        return new _RistPoint(exports.ed25519.Point.fromAffine(ap));
      }
      /**
       * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
       * The hash-to-group operation applies Elligator twice and adds the results.
       * **Note:** this is one-way map, there is no conversion from point to hash.
       * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
       * the [website](https://ristretto.group/formulas/elligator.html).
       * @param hex 64-byte output of a hash function
       */
      static hashToCurve(hex) {
        hex = (0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new _RistPoint(R1.add(R2));
      }
      static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return this.fromHex(bytes);
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        hex = (0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P))
          throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
          throw new Error(emsg);
        return new _RistPoint(new exports.ed25519.Point(x, y, _1n, t));
      }
      static msm(points, scalars) {
        const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
        return (0, curve_ts_1.pippenger)(_RistPoint, Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = Fp.ORDER;
        const mod = Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {
          let _x = mod(y * SQRT_M1);
          let _y = mod(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if ((0, modular_ts_1.isNegativeLE)(x * zInv, P))
          y = mod(-y);
        let s = mod((z - y) * D);
        if ((0, modular_ts_1.isNegativeLE)(s, P))
          s = mod(-s);
        return (0, utils_ts_1.numberToBytesLE)(s, 32);
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        aristp(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = Fp.create;
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
      }
      add(other) {
        aristp(other);
        return new _RistPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        aristp(other);
        return new _RistPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new _RistPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new _RistPoint(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return new _RistPoint(this.ep.double());
      }
      negate() {
        return new _RistPoint(this.ep.negate());
      }
    };
    exports.RistrettoPoint = (() => {
      if (!RistPoint.BASE)
        RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
      if (!RistPoint.ZERO)
        RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
      return RistPoint;
    })();
    var hashToRistretto255 = (msg, options) => {
      const d = options.DST;
      const DST = typeof d === "string" ? (0, utils_js_1.utf8ToBytes)(d) : d;
      const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
      const P = RistPoint.hashToCurve(uniform_bytes);
      return P;
    };
    exports.hashToRistretto255 = hashToRistretto255;
    exports.hash_to_ristretto255 = exports.hashToRistretto255;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js
var require_ed255192 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ed25519_1 = require_ed25519();
    var utils_1 = require_browser();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var ED_PREFIX = "ED";
    var ed25519 = {
      deriveKeypair(entropy) {
        const rawPrivateKey = Sha512_1.default.half(entropy);
        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);
        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(message instanceof Uint8Array, "message must be array of octets");
        assert_1.default.ok(privateKey.length === 66, "private key must be 33 bytes including prefix");
        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));
      },
      verify(message, signature, publicKey) {
        assert_1.default.ok(publicKey.length === 66, "public key must be 33 bytes including prefix");
        return ed25519_1.ed25519.verify(
          signature,
          message,
          // Remove the 0xED prefix
          publicKey.slice(2),
          // By default, set zip215 to false for compatibility reasons.
          // ZIP 215 is a stricter Ed25519 signature verification scheme.
          // However, setting it to false adheres to the more commonly used
          // RFC8032 / NIST186-5 standards, making it compatible with systems
          // like the XRP Ledger.
          { zip215: false }
        );
      }
    };
    exports.default = ed25519;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0/node_modules/ripple-keypairs/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
    var ripple_address_codec_1 = require_dist();
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeSeed;
    } });
    var ripemd160_1 = require_browser4();
    var sha256_1 = require_browser2();
    var utils_1 = require_browser();
    var utils_2 = require_utils7();
    var Sha512_1 = __importDefault(require_Sha512());
    var assert_1 = __importDefault(require_assert());
    var getAlgorithmFromKey_1 = require_getAlgorithmFromKey();
    var secp256k1_1 = __importDefault(require_secp256k12());
    var ed25519_1 = __importDefault(require_ed255192());
    function getSigningScheme(algorithm) {
      const schemes = { "ecdsa-secp256k1": secp256k1_1.default, ed25519: ed25519_1.default };
      return schemes[algorithm];
    }
    function generateSeed(options = {}) {
      assert_1.default.ok(!options.entropy || options.entropy.length >= 16, "entropy too short");
      const entropy = options.entropy ? options.entropy.slice(0, 16) : (0, utils_1.randomBytes)(16);
      const type = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
      return (0, ripple_address_codec_1.encodeSeed)(entropy, type);
    }
    exports.generateSeed = generateSeed;
    function deriveKeypair(seed, options) {
      var _a;
      const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);
      const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;
      const algorithm = proposedAlgorithm === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
      const scheme = getSigningScheme(algorithm);
      const keypair = scheme.deriveKeypair(decoded.bytes, options);
      const messageToVerify = Sha512_1.default.half("This test message should verify.");
      const signature = scheme.sign(messageToVerify, keypair.privateKey);
      if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {
        throw new Error("derived keypair did not generate verifiable signature");
      }
      return keypair;
    }
    exports.deriveKeypair = deriveKeypair;
    function sign(messageHex, privateKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
      return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);
    }
    exports.sign = sign;
    function verify(messageHex, signature, publicKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
      return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);
    }
    exports.verify = verify;
    function computePublicKeyHash(publicKeyBytes) {
      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
    }
    function deriveAddressFromBytes(publicKeyBytes) {
      return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
    }
    function deriveAddress(publicKey) {
      return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
    }
    exports.deriveAddress = deriveAddress;
    function deriveNodeAddress(publicKey) {
      const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);
      const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);
      return deriveAddressFromBytes(accountPublicBytes);
    }
    exports.deriveNodeAddress = deriveNodeAddress;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/derive.js
var require_derive = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/derive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
    var ripple_address_codec_1 = require_dist();
    var ripple_keypairs_1 = require_dist3();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveAddress;
    } });
    function deriveXAddress(options) {
      const classicAddress = (0, ripple_keypairs_1.deriveAddress)(options.publicKey);
      return (0, ripple_address_codec_1.classicAddressToXAddress)(classicAddress, options.tag, options.test);
    }
    exports.deriveXAddress = deriveXAddress;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/collections.js
var require_collections = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitBy = exports.groupBy = void 0;
    function groupBy(array, iteratee) {
      function predicate(acc, value, index, arrayReference) {
        const key = iteratee(value, index, arrayReference) || 0;
        const group = acc[key] || [];
        group.push(value);
        acc[key] = group;
        return acc;
      }
      return array.reduce(predicate, {});
    }
    exports.groupBy = groupBy;
    function omitBy(obj, predicate) {
      const keys = Object.keys(obj);
      const keysToKeep = keys.filter((kb) => !predicate(obj[kb], kb));
      return keysToKeep.reduce((acc, key) => {
        acc[key] = obj[key];
        return acc;
      }, {});
    }
    exports.omitBy = omitBy;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/xrpConversion.js
var require_xrpConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/xrpConversion.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xrpToDrops = exports.dropsToXrp = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var DROPS_PER_XRP = 1e6;
    var MAX_FRACTION_LENGTH = 6;
    var BASE_TEN = 10;
    var SANITY_CHECK = /^-?[0-9.]+$/u;
    function dropsToXrp(dropsToConvert) {
      const drops = new bignumber_js_1.default(dropsToConvert).toString(BASE_TEN);
      if (typeof dropsToConvert === "string" && drops === "NaN") {
        throw new errors_1.ValidationError(`dropsToXrp: invalid value '${dropsToConvert}', should be a BigNumber or string-encoded number.`);
      }
      if (drops.includes(".")) {
        throw new errors_1.ValidationError(`dropsToXrp: value '${drops}' has too many decimal places.`);
      }
      if (!SANITY_CHECK.exec(drops)) {
        throw new errors_1.ValidationError(`dropsToXrp: failed sanity check - value '${drops}', does not match (^-?[0-9]+$).`);
      }
      return new bignumber_js_1.default(drops).dividedBy(DROPS_PER_XRP).toNumber();
    }
    exports.dropsToXrp = dropsToXrp;
    function xrpToDrops(xrpToConvert) {
      const xrp = new bignumber_js_1.default(xrpToConvert).toString(BASE_TEN);
      if (typeof xrpToConvert === "string" && xrp === "NaN") {
        throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrpToConvert}', should be a BigNumber or string-encoded number.`);
      }
      if (!SANITY_CHECK.exec(xrp)) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`);
      }
      const components = xrp.split(".");
      if (components.length > 2) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}' has too many decimal points.`);
      }
      const fraction = components[1] || "0";
      if (fraction.length > MAX_FRACTION_LENGTH) {
        throw new errors_1.ValidationError(`xrpToDrops: value '${xrp}' has too many decimal places.`);
      }
      return new bignumber_js_1.default(xrp).times(DROPS_PER_XRP).integerValue(bignumber_js_1.default.ROUND_FLOOR).toString(BASE_TEN);
    }
    exports.xrpToDrops = xrpToDrops;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getBalanceChanges.js
var require_getBalanceChanges = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getBalanceChanges.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var collections_1 = require_collections();
    var xrpConversion_1 = require_xrpConversion();
    function normalizeNode(affectedNode) {
      const diffType = Object.keys(affectedNode)[0];
      const node = affectedNode[diffType];
      return Object.assign(Object.assign({}, node), { NodeType: diffType, LedgerEntryType: node.LedgerEntryType, LedgerIndex: node.LedgerIndex, NewFields: node.NewFields, FinalFields: node.FinalFields, PreviousFields: node.PreviousFields });
    }
    function normalizeNodes(metadata) {
      if (metadata.AffectedNodes.length === 0) {
        return [];
      }
      return metadata.AffectedNodes.map(normalizeNode);
    }
    function groupByAccount(balanceChanges) {
      const grouped = (0, collections_1.groupBy)(balanceChanges, (node) => node.account);
      return Object.entries(grouped).map(([account, items]) => {
        return { account, balances: items.map((item) => item.balance) };
      });
    }
    function getValue(balance) {
      if (typeof balance === "string") {
        return new bignumber_js_1.default(balance);
      }
      return new bignumber_js_1.default(balance.value);
    }
    function computeBalanceChange(node) {
      var _a, _b, _c;
      let value = null;
      if ((_a = node.NewFields) === null || _a === void 0 ? void 0 : _a.Balance) {
        value = getValue(node.NewFields.Balance);
      } else if (((_b = node.PreviousFields) === null || _b === void 0 ? void 0 : _b.Balance) && ((_c = node.FinalFields) === null || _c === void 0 ? void 0 : _c.Balance)) {
        value = getValue(node.FinalFields.Balance).minus(getValue(node.PreviousFields.Balance));
      }
      if (value === null || value.isZero()) {
        return null;
      }
      return value;
    }
    function getXRPQuantity(node) {
      var _a, _b, _c;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      return {
        account: (_b = (_a = node.FinalFields) === null || _a === void 0 ? void 0 : _a.Account) !== null && _b !== void 0 ? _b : (_c = node.NewFields) === null || _c === void 0 ? void 0 : _c.Account,
        balance: {
          currency: "XRP",
          value: (0, xrpConversion_1.dropsToXrp)(value).toString()
        }
      };
    }
    function flipTrustlinePerspective(balanceChange) {
      const negatedBalance = new bignumber_js_1.default(balanceChange.balance.value).negated();
      return {
        account: balanceChange.balance.issuer,
        balance: {
          issuer: balanceChange.account,
          currency: balanceChange.balance.currency,
          value: negatedBalance.toString()
        }
      };
    }
    function getTrustlineQuantity(node) {
      var _a, _b;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      const fields = node.NewFields == null ? node.FinalFields : node.NewFields;
      const result = {
        account: (_a = fields === null || fields === void 0 ? void 0 : fields.LowLimit) === null || _a === void 0 ? void 0 : _a.issuer,
        balance: {
          issuer: (_b = fields === null || fields === void 0 ? void 0 : fields.HighLimit) === null || _b === void 0 ? void 0 : _b.issuer,
          currency: (fields === null || fields === void 0 ? void 0 : fields.Balance).currency,
          value: value.toString()
        }
      };
      return [result, flipTrustlinePerspective(result)];
    }
    function getBalanceChanges(metadata) {
      const quantities = normalizeNodes(metadata).map((node) => {
        if (node.LedgerEntryType === "AccountRoot") {
          const xrpQuantity = getXRPQuantity(node);
          if (xrpQuantity == null) {
            return [];
          }
          return [xrpQuantity];
        }
        if (node.LedgerEntryType === "RippleState") {
          const trustlineQuantity = getTrustlineQuantity(node);
          if (trustlineQuantity == null) {
            return [];
          }
          return trustlineQuantity;
        }
        return [];
      });
      return groupByAccount(quantities.flat());
    }
    exports.default = getBalanceChanges;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/metadata.js
var require_metadata = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDeletedNode = exports.isModifiedNode = exports.isCreatedNode = void 0;
    function isCreatedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `CreatedNode`);
    }
    exports.isCreatedNode = isCreatedNode;
    function isModifiedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `ModifiedNode`);
    }
    exports.isModifiedNode = isModifiedNode;
    function isDeletedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `DeletedNode`);
    }
    exports.isDeletedNode = isDeletedNode;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getNFTokenID.js
var require_getNFTokenID = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getNFTokenID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta) {
      if (typeof meta === "string") {
        return (0, ripple_binary_codec_1.decode)(meta);
      }
      return meta;
    }
    function getNFTokenID(meta) {
      if (typeof meta !== "string" && (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) === void 0) {
        throw new TypeError(`Unable to parse the parameter given to getNFTokenID.
      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta)} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta);
      const affectedNodes = decodedMeta.AffectedNodes.filter((node) => {
        var _a;
        if ((0, metadata_1.isCreatedNode)(node)) {
          return node.CreatedNode.LedgerEntryType === "NFTokenPage";
        }
        if ((0, metadata_1.isModifiedNode)(node)) {
          return node.ModifiedNode.LedgerEntryType === "NFTokenPage" && Boolean((_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens);
        }
        return false;
      });
      const previousTokenIDSet = new Set(affectedNodes.flatMap((node) => {
        var _a;
        const nftokens = (0, metadata_1.isModifiedNode)(node) ? (_a = node.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens : [];
        return nftokens.map((token) => token.NFToken.NFTokenID);
      }).filter((id) => Boolean(id)));
      const finalTokenIDs = affectedNodes.flatMap((node) => {
        var _a, _b, _c, _d, _e, _f;
        return ((_f = (_c = (_b = (_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens) !== null && _f !== void 0 ? _f : []).map((token) => token.NFToken.NFTokenID);
      }).filter((nftokenID2) => Boolean(nftokenID2));
      const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id));
      return nftokenID;
    }
    exports.default = getNFTokenID;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getXChainClaimID.js
var require_getXChainClaimID = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/getXChainClaimID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta) {
      if (typeof meta === "string") {
        return (0, ripple_binary_codec_1.decode)(meta);
      }
      return meta;
    }
    function getXChainClaimID(meta) {
      if (typeof meta !== "string" && (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) === void 0) {
        throw new TypeError(`Unable to parse the parameter given to getXChainClaimID.
      'meta' must be the metadata from an XChainCreateClaimID transaction. Received ${JSON.stringify(meta)} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta);
      if (!decodedMeta.TransactionResult) {
        throw new TypeError("Cannot get XChainClaimID from un-validated transaction");
      }
      if (decodedMeta.TransactionResult !== "tesSUCCESS") {
        return void 0;
      }
      const createdNode = decodedMeta.AffectedNodes.find((node) => (0, metadata_1.isCreatedNode)(node) && node.CreatedNode.LedgerEntryType === "XChainOwnedClaimID");
      return createdNode.CreatedNode.NewFields.XChainClaimID;
    }
    exports.default = getXChainClaimID;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js
var require_HashPrefix = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HashPrefix;
    (function(HashPrefix2) {
      HashPrefix2[HashPrefix2["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
      HashPrefix2[HashPrefix2["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
      HashPrefix2[HashPrefix2["INNER_NODE"] = 1296649728] = "INNER_NODE";
      HashPrefix2[HashPrefix2["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
      HashPrefix2[HashPrefix2["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
      HashPrefix2[HashPrefix2["LEDGER"] = 1280791040] = "LEDGER";
    })(HashPrefix || (HashPrefix = {}));
    exports.default = HashPrefix;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js
var require_sha512Half = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha512_1 = require_browser3();
    var utils_1 = require_browser();
    var HASH_BYTES = 32;
    function sha512Half(hex) {
      return (0, utils_1.bytesToHex)((0, sha512_1.sha512)((0, utils_1.hexToBytes)(hex)).slice(0, HASH_BYTES));
    }
    exports.default = sha512Half;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Node = exports.NodeType = void 0;
    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["INNER"] = 1] = "INNER";
      NodeType2[NodeType2["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
      NodeType2[NodeType2["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
      NodeType2[NodeType2["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
    })(NodeType || (exports.NodeType = NodeType = {}));
    var Node = class {
    };
    exports.Node = Node;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js
var require_LeafNode = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var node_1 = require_node();
    var HEX = 16;
    var LeafNode = class extends node_1.Node {
      constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
      }
      get hash() {
        switch (this.type) {
          case node_1.NodeType.ACCOUNT_STATE: {
            const leafPrefix = HashPrefix_1.default.LEAF_NODE.toString(HEX);
            return (0, sha512Half_1.default)(leafPrefix + this.data + this.tag);
          }
          case node_1.NodeType.TRANSACTION_NO_METADATA: {
            const txIDPrefix = HashPrefix_1.default.TRANSACTION_ID.toString(HEX);
            return (0, sha512Half_1.default)(txIDPrefix + this.data);
          }
          case node_1.NodeType.TRANSACTION_METADATA: {
            const txNodePrefix = HashPrefix_1.default.TRANSACTION_NODE.toString(HEX);
            return (0, sha512Half_1.default)(txNodePrefix + this.data + this.tag);
          }
          default:
            throw new errors_1.XrplError("Tried to hash a SHAMap node of unknown type.");
        }
      }
      addItem(tag, node) {
        throw new errors_1.XrplError("Cannot call addItem on a LeafNode");
        this.addItem(tag, node);
      }
    };
    exports.default = LeafNode;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js
var require_InnerNode = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var node_1 = require_node();
    var HEX_ZERO = "0000000000000000000000000000000000000000000000000000000000000000";
    var SLOT_MAX = 15;
    var HEX = 16;
    var InnerNode = class _InnerNode extends node_1.Node {
      constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = node_1.NodeType.INNER;
        this.depth = depth;
        this.empty = true;
      }
      get hash() {
        if (this.empty) {
          return HEX_ZERO;
        }
        let hex = "";
        for (let iter = 0; iter <= SLOT_MAX; iter++) {
          const child = this.leaves[iter];
          const hash = child == null ? HEX_ZERO : child.hash;
          hex += hash;
        }
        const prefix = HashPrefix_1.default.INNER_NODE.toString(HEX);
        return (0, sha512Half_1.default)(prefix + hex);
      }
      addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], HEX));
        if (existingNode === void 0) {
          this.setNode(parseInt(tag[this.depth], HEX), node);
          return;
        }
        if (existingNode instanceof _InnerNode) {
          existingNode.addItem(tag, node);
        } else if (existingNode instanceof LeafNode_1.default) {
          if (existingNode.tag === tag) {
            throw new errors_1.XrplError("Tried to add a node to a SHAMap that was already in there.");
          } else {
            const newInnerNode = new _InnerNode(this.depth + 1);
            newInnerNode.addItem(existingNode.tag, existingNode);
            newInnerNode.addItem(tag, node);
            this.setNode(parseInt(tag[this.depth], HEX), newInnerNode);
          }
        }
      }
      setNode(slot, node) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError("Invalid slot: slot must be between 0-15.");
        }
        this.leaves[slot] = node;
        this.empty = false;
      }
      getNode(slot) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError("Invalid slot: slot must be between 0-15.");
        }
        return this.leaves[slot];
      }
    };
    exports.default = InnerNode;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js
var require_SHAMap = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var InnerNode_1 = __importDefault(require_InnerNode());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var SHAMap = class {
      constructor() {
        this.root = new InnerNode_1.default(0);
      }
      get hash() {
        return this.root.hash;
      }
      addItem(tag, data, type) {
        this.root.addItem(tag, new LeafNode_1.default(tag, data, type));
      }
    };
    __exportStar(require_node(), exports);
    exports.default = SHAMap;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js
var require_hashLedger = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashStateTree = exports.hashTxTree = exports.hashLedgerHeader = exports.hashSignedTx = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var SHAMap_1 = __importStar(require_SHAMap());
    var HEX = 16;
    function intToHex(integer, byteLength) {
      const foo = Number(integer).toString(HEX).padStart(byteLength * 2, "0");
      return foo;
    }
    function bigintToHex(integerString, byteLength) {
      const hex = new bignumber_js_1.default(integerString).toString(HEX);
      return hex.padStart(byteLength * 2, "0");
    }
    function addLengthPrefix(hex) {
      const length = hex.length / 2;
      if (length <= 192) {
        return (0, utils_1.bytesToHex)([length]) + hex;
      }
      if (length <= 12480) {
        const prefix = length - 193;
        return (0, utils_1.bytesToHex)([193 + (prefix >>> 8), prefix & 255]) + hex;
      }
      if (length <= 918744) {
        const prefix = length - 12481;
        return (0, utils_1.bytesToHex)([
          241 + (prefix >>> 16),
          prefix >>> 8 & 255,
          prefix & 255
        ]) + hex;
      }
      throw new errors_1.XrplError("Variable integer overflow.");
    }
    function hashSignedTx(tx) {
      let txBlob;
      let txObject;
      if (typeof tx === "string") {
        txBlob = tx;
        txObject = (0, ripple_binary_codec_1.decode)(tx);
      } else {
        txBlob = (0, ripple_binary_codec_1.encode)(tx);
        txObject = tx;
      }
      if (txObject.TxnSignature === void 0 && txObject.Signers === void 0 && txObject.SigningPubKey === void 0) {
        throw new errors_1.ValidationError("The transaction must be signed to hash it.");
      }
      const prefix = HashPrefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
      return (0, sha512Half_1.default)(prefix.concat(txBlob));
    }
    exports.hashSignedTx = hashSignedTx;
    function hashLedgerHeader(ledgerHeader) {
      const prefix = HashPrefix_1.default.LEDGER.toString(HEX).toUpperCase();
      const ledger = prefix + intToHex(Number(ledgerHeader.ledger_index), 4) + bigintToHex(ledgerHeader.total_coins, 8) + ledgerHeader.parent_hash + ledgerHeader.transaction_hash + ledgerHeader.account_hash + intToHex(ledgerHeader.parent_close_time, 4) + intToHex(ledgerHeader.close_time, 4) + intToHex(ledgerHeader.close_time_resolution, 1) + intToHex(ledgerHeader.close_flags, 1);
      return (0, sha512Half_1.default)(ledger);
    }
    exports.hashLedgerHeader = hashLedgerHeader;
    function hashTxTree(transactions) {
      var _a;
      const shamap = new SHAMap_1.default();
      for (const txJSON of transactions) {
        const txBlobHex = (0, ripple_binary_codec_1.encode)(txJSON);
        const metaHex = (0, ripple_binary_codec_1.encode)((_a = txJSON.metaData) !== null && _a !== void 0 ? _a : {});
        const txHash = hashSignedTx(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, SHAMap_1.NodeType.TRANSACTION_METADATA);
      }
      return shamap.hash;
    }
    exports.hashTxTree = hashTxTree;
    function hashStateTree(entries) {
      const shamap = new SHAMap_1.default();
      entries.forEach((ledgerEntry) => {
        const data = (0, ripple_binary_codec_1.encode)(ledgerEntry);
        shamap.addItem(ledgerEntry.index, data, SHAMap_1.NodeType.ACCOUNT_STATE);
      });
      return shamap.hash;
    }
    exports.hashStateTree = hashStateTree;
    function computeTransactionHash(ledger, options) {
      const { transaction_hash } = ledger;
      if (!options.computeTreeHashes) {
        return transaction_hash;
      }
      if (ledger.transactions == null) {
        throw new errors_1.ValidationError("transactions is missing from the ledger");
      }
      const transactionHash = hashTxTree(ledger.transactions);
      if (transaction_hash !== transactionHash) {
        throw new errors_1.ValidationError("transactionHash in header does not match computed hash of transactions", {
          transactionHashInHeader: transaction_hash,
          computedHashOfTransactions: transactionHash
        });
      }
      return transactionHash;
    }
    function computeStateHash(ledger, options) {
      const { account_hash } = ledger;
      if (!options.computeTreeHashes) {
        return account_hash;
      }
      if (ledger.accountState == null) {
        throw new errors_1.ValidationError("accountState is missing from the ledger");
      }
      const stateHash = hashStateTree(ledger.accountState);
      if (account_hash !== stateHash) {
        throw new errors_1.ValidationError("stateHash in header does not match computed hash of state");
      }
      return stateHash;
    }
    function hashLedger(ledger, options = {}) {
      const subhashes = {
        transaction_hash: computeTransactionHash(ledger, options),
        account_hash: computeStateHash(ledger, options)
      };
      return hashLedgerHeader(Object.assign(Object.assign({}, ledger), subhashes));
    }
    exports.default = hashLedger;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js
var require_ledgerSpaces = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ledgerSpaces = {
      account: "a",
      dirNode: "d",
      generatorMap: "g",
      rippleState: "r",
      offer: "o",
      ownerDir: "O",
      bookDir: "B",
      contract: "c",
      skipList: "s",
      escrow: "u",
      amendment: "f",
      feeSettings: "e",
      ticket: "T",
      signerList: "S",
      paychan: "x",
      check: "C",
      depositPreauth: "p"
    };
    exports.default = ledgerSpaces;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/index.js
var require_hashes2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/hashes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTxTree = exports.hashStateTree = exports.hashLedger = exports.hashSignedTx = exports.hashLedgerHeader = exports.hashPaymentChannel = exports.hashEscrow = exports.hashTrustline = exports.hashOfferId = exports.hashSignerListId = exports.hashAccountRoot = exports.hashTx = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var hashLedger_1 = __importStar(require_hashLedger());
    exports.hashLedger = hashLedger_1.default;
    Object.defineProperty(exports, "hashLedgerHeader", { enumerable: true, get: function() {
      return hashLedger_1.hashLedgerHeader;
    } });
    Object.defineProperty(exports, "hashSignedTx", { enumerable: true, get: function() {
      return hashLedger_1.hashSignedTx;
    } });
    Object.defineProperty(exports, "hashTxTree", { enumerable: true, get: function() {
      return hashLedger_1.hashTxTree;
    } });
    Object.defineProperty(exports, "hashStateTree", { enumerable: true, get: function() {
      return hashLedger_1.hashStateTree;
    } });
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var ledgerSpaces_1 = __importDefault(require_ledgerSpaces());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var HEX = 16;
    var BYTE_LENGTH = 4;
    function addressToHex(address) {
      return (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));
    }
    function ledgerSpaceHex(name) {
      return ledgerSpaces_1.default[name].charCodeAt(0).toString(HEX).padStart(4, "0");
    }
    var MASK = 255;
    function currencyToHex(currency) {
      if (currency.length !== 3) {
        return currency;
      }
      const bytes = Array(20).fill(0);
      bytes[12] = currency.charCodeAt(0) & MASK;
      bytes[13] = currency.charCodeAt(1) & MASK;
      bytes[14] = currency.charCodeAt(2) & MASK;
      return (0, utils_1.bytesToHex)(Uint8Array.from(bytes));
    }
    function hashTx(txBlobHex) {
      const prefix = HashPrefix_1.default.TRANSACTION_SIGN.toString(HEX).toUpperCase();
      return (0, sha512Half_1.default)(prefix + txBlobHex);
    }
    exports.hashTx = hashTx;
    function hashAccountRoot(address) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("account") + addressToHex(address));
    }
    exports.hashAccountRoot = hashAccountRoot;
    function hashSignerListId(address) {
      return (0, sha512Half_1.default)(`${ledgerSpaceHex("signerList") + addressToHex(address)}00000000`);
    }
    exports.hashSignerListId = hashSignerListId;
    function hashOfferId(address, sequence) {
      const hexPrefix = ledgerSpaces_1.default.offer.charCodeAt(0).toString(HEX).padStart(2, "0");
      const hexSequence = sequence.toString(HEX).padStart(8, "0");
      const prefix = `00${hexPrefix}`;
      return (0, sha512Half_1.default)(prefix + addressToHex(address) + hexSequence);
    }
    exports.hashOfferId = hashOfferId;
    function hashTrustline(address1, address2, currency) {
      const address1Hex = addressToHex(address1);
      const address2Hex = addressToHex(address2);
      const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(new bignumber_js_1.default(address2Hex, 16));
      const lowAddressHex = swap ? address2Hex : address1Hex;
      const highAddressHex = swap ? address1Hex : address2Hex;
      const prefix = ledgerSpaceHex("rippleState");
      return (0, sha512Half_1.default)(prefix + lowAddressHex + highAddressHex + currencyToHex(currency));
    }
    exports.hashTrustline = hashTrustline;
    function hashEscrow(address, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("escrow") + addressToHex(address) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashEscrow = hashEscrow;
    function hashPaymentChannel(address, dstAddress, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("paychan") + addressToHex(address) + addressToHex(dstAddress) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashPaymentChannel = hashPaymentChannel;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/parseNFTokenID.js
var require_parseNFTokenID = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/parseNFTokenID.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    function unscrambleTaxon(taxon, tokenSeq) {
      const seed = 384160001;
      const increment = 2459;
      const max = 4294967296;
      const scramble = new bignumber_js_1.default(seed).multipliedBy(tokenSeq).modulo(max).plus(increment).modulo(max).toNumber();
      return (taxon ^ scramble) >>> 0;
    }
    function parseNFTokenID(nftokenID) {
      const expectedLength = 64;
      if (nftokenID.length !== expectedLength) {
        throw new errors_1.XrplError(`Attempting to parse a nftokenID with length ${nftokenID.length}
    , but expected a token with length ${expectedLength}`);
      }
      const scrambledTaxon = new bignumber_js_1.default(nftokenID.substring(48, 56), 16).toNumber();
      const sequence = new bignumber_js_1.default(nftokenID.substring(56, 64), 16).toNumber();
      const NFTokenIDData = {
        NFTokenID: nftokenID,
        Flags: new bignumber_js_1.default(nftokenID.substring(0, 4), 16).toNumber(),
        TransferFee: new bignumber_js_1.default(nftokenID.substring(4, 8), 16).toNumber(),
        Issuer: (0, ripple_address_codec_1.encodeAccountID)((0, utils_1.hexToBytes)(nftokenID.substring(8, 48))),
        Taxon: unscrambleTaxon(scrambledTaxon, sequence),
        Sequence: sequence
      };
      return NFTokenIDData;
    }
    exports.default = parseNFTokenID;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/quality.js
var require_quality2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/quality.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.percentToQuality = exports.transferRateToDecimal = exports.qualityToDecimal = exports.decimalToQuality = exports.percentToTransferRate = exports.decimalToTransferRate = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var BASE_TEN = 10;
    var ONE_BILLION = "1000000000";
    var TWO_BILLION = "2000000000";
    function percentToDecimal(percent) {
      if (!percent.endsWith("%")) {
        throw new errors_1.ValidationError(`Value ${percent} must end with %`);
      }
      const split = percent.split("%").filter((str) => str !== "");
      if (split.length !== 1) {
        throw new errors_1.ValidationError(`Value ${percent} contains too many % signs`);
      }
      return new bignumber_js_1.default(split[0]).dividedBy("100").toString(BASE_TEN);
    }
    function decimalToTransferRate(decimal) {
      const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION).plus(ONE_BILLION);
      if (rate.isLessThan(ONE_BILLION) || rate.isGreaterThan(TWO_BILLION)) {
        throw new errors_1.ValidationError(`Decimal value must be between 0 and 1.00.`);
      }
      const billionths = rate.toString(BASE_TEN);
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
      }
      return Number(billionths);
    }
    exports.decimalToTransferRate = decimalToTransferRate;
    function percentToTransferRate(percent) {
      return decimalToTransferRate(percentToDecimal(percent));
    }
    exports.percentToTransferRate = percentToTransferRate;
    function decimalToQuality(decimal) {
      const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION);
      const billionths = rate.toString(BASE_TEN);
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes("-")) {
        throw new errors_1.ValidationError("Cannot have negative Quality");
      }
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
      }
      return Number(billionths);
    }
    exports.decimalToQuality = decimalToQuality;
    function qualityToDecimal(quality) {
      if (!Number.isInteger(quality)) {
        throw new errors_1.ValidationError("Quality must be an integer");
      }
      if (quality < 0) {
        throw new errors_1.ValidationError("Negative quality not allowed");
      }
      if (quality === 0) {
        return "1";
      }
      const decimal = new bignumber_js_1.default(quality).dividedBy(ONE_BILLION);
      return decimal.toString(BASE_TEN);
    }
    exports.qualityToDecimal = qualityToDecimal;
    function transferRateToDecimal(rate) {
      if (!Number.isInteger(rate)) {
        throw new errors_1.ValidationError("Error decoding, transfer Rate must be an integer");
      }
      if (rate === 0) {
        return "0";
      }
      const decimal = new bignumber_js_1.default(rate).minus(ONE_BILLION).dividedBy(ONE_BILLION);
      if (decimal.isLessThan(0)) {
        throw new errors_1.ValidationError("Error decoding, negative transfer rate");
      }
      return decimal.toString(BASE_TEN);
    }
    exports.transferRateToDecimal = transferRateToDecimal;
    function percentToQuality(percent) {
      return decimalToQuality(percentToDecimal(percent));
    }
    exports.percentToQuality = percentToQuality;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js
var require_signPaymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var xrpConversion_1 = require_xrpConversion();
    function signPaymentChannelClaim(channel, xrpAmount, privateKey) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount)
      });
      return (0, ripple_keypairs_1.sign)(signingData, privateKey);
    }
    exports.default = signPaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/stringConversion.js
var require_stringConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/stringConversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertStringToHex = exports.convertHexToString = void 0;
    var utils_1 = require_browser();
    function convertStringToHex(string) {
      return (0, utils_1.stringToHex)(string);
    }
    exports.convertStringToHex = convertStringToHex;
    function convertHexToString(hex, encoding = "utf8") {
      return (0, utils_1.hexToString)(hex, encoding);
    }
    exports.convertHexToString = convertHexToString;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/timeConversion.js
var require_timeConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/timeConversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = void 0;
    var RIPPLE_EPOCH_DIFF = 946684800;
    function rippleTimeToUnixTime(rpepoch) {
      return (rpepoch + RIPPLE_EPOCH_DIFF) * 1e3;
    }
    exports.rippleTimeToUnixTime = rippleTimeToUnixTime;
    function unixTimeToRippleTime(timestamp) {
      return Math.round(timestamp / 1e3) - RIPPLE_EPOCH_DIFF;
    }
    exports.unixTimeToRippleTime = unixTimeToRippleTime;
    function rippleTimeToISOTime(rippleTime) {
      return new Date(rippleTimeToUnixTime(rippleTime)).toISOString();
    }
    exports.rippleTimeToISOTime = rippleTimeToISOTime;
    function isoTimeToRippleTime(iso8601) {
      const isoDate = typeof iso8601 === "string" ? new Date(iso8601) : iso8601;
      return unixTimeToRippleTime(isoDate.getTime());
    }
    exports.isoTimeToRippleTime = isoTimeToRippleTime;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js
var require_verifyPaymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var xrpConversion_1 = require_xrpConversion();
    function verifyPaymentChannelClaim(channel, xrpAmount, signature, publicKey) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount)
      });
      return (0, ripple_keypairs_1.verify)(signingData, signature, publicKey);
    }
    exports.default = verifyPaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/index.js
var require_utils8 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/utils/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getXChainClaimID = exports.parseNFTokenID = exports.getNFTokenID = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encodeForMultiSigning = exports.decode = exports.encode = exports.decodeXAddress = exports.encodeXAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.isValidClassicAddress = exports.isValidXAddress = exports.xAddressToClassicAddress = exports.classicAddressToXAddress = exports.convertHexToString = exports.convertStringToHex = exports.verifyPaymentChannelClaim = exports.verifyKeypairSignature = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.hashes = exports.isValidAddress = exports.isValidSecret = exports.qualityToDecimal = exports.transferRateToDecimal = exports.decimalToTransferRate = exports.percentToTransferRate = exports.decimalToQuality = exports.percentToQuality = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.hasNextPage = exports.xrpToDrops = exports.dropsToXrp = exports.getBalanceChanges = void 0;
    var ripple_address_codec_1 = require_dist();
    Object.defineProperty(exports, "classicAddressToXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.classicAddressToXAddress;
    } });
    Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeAccountID;
    } });
    Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeAccountPublic;
    } });
    Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeNodePublic;
    } });
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeSeed;
    } });
    Object.defineProperty(exports, "decodeXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeXAddress;
    } });
    Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeAccountID;
    } });
    Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeAccountPublic;
    } });
    Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeNodePublic;
    } });
    Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeSeed;
    } });
    Object.defineProperty(exports, "encodeXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeXAddress;
    } });
    Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.isValidClassicAddress;
    } });
    Object.defineProperty(exports, "isValidXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.isValidXAddress;
    } });
    Object.defineProperty(exports, "xAddressToClassicAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.xAddressToClassicAddress;
    } });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    Object.defineProperty(exports, "verifyKeypairSignature", { enumerable: true, get: function() {
      return ripple_keypairs_1.verify;
    } });
    var derive_1 = require_derive();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return derive_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return derive_1.deriveAddress;
    } });
    Object.defineProperty(exports, "deriveXAddress", { enumerable: true, get: function() {
      return derive_1.deriveXAddress;
    } });
    var getBalanceChanges_1 = __importDefault(require_getBalanceChanges());
    exports.getBalanceChanges = getBalanceChanges_1.default;
    var getNFTokenID_1 = __importDefault(require_getNFTokenID());
    exports.getNFTokenID = getNFTokenID_1.default;
    var getXChainClaimID_1 = __importDefault(require_getXChainClaimID());
    exports.getXChainClaimID = getXChainClaimID_1.default;
    var hashes_1 = require_hashes2();
    var parseNFTokenID_1 = __importDefault(require_parseNFTokenID());
    exports.parseNFTokenID = parseNFTokenID_1.default;
    var quality_1 = require_quality2();
    Object.defineProperty(exports, "percentToTransferRate", { enumerable: true, get: function() {
      return quality_1.percentToTransferRate;
    } });
    Object.defineProperty(exports, "decimalToTransferRate", { enumerable: true, get: function() {
      return quality_1.decimalToTransferRate;
    } });
    Object.defineProperty(exports, "transferRateToDecimal", { enumerable: true, get: function() {
      return quality_1.transferRateToDecimal;
    } });
    Object.defineProperty(exports, "percentToQuality", { enumerable: true, get: function() {
      return quality_1.percentToQuality;
    } });
    Object.defineProperty(exports, "decimalToQuality", { enumerable: true, get: function() {
      return quality_1.decimalToQuality;
    } });
    Object.defineProperty(exports, "qualityToDecimal", { enumerable: true, get: function() {
      return quality_1.qualityToDecimal;
    } });
    var signPaymentChannelClaim_1 = __importDefault(require_signPaymentChannelClaim());
    exports.signPaymentChannelClaim = signPaymentChannelClaim_1.default;
    var stringConversion_1 = require_stringConversion();
    Object.defineProperty(exports, "convertHexToString", { enumerable: true, get: function() {
      return stringConversion_1.convertHexToString;
    } });
    Object.defineProperty(exports, "convertStringToHex", { enumerable: true, get: function() {
      return stringConversion_1.convertStringToHex;
    } });
    var timeConversion_1 = require_timeConversion();
    Object.defineProperty(exports, "rippleTimeToISOTime", { enumerable: true, get: function() {
      return timeConversion_1.rippleTimeToISOTime;
    } });
    Object.defineProperty(exports, "isoTimeToRippleTime", { enumerable: true, get: function() {
      return timeConversion_1.isoTimeToRippleTime;
    } });
    Object.defineProperty(exports, "rippleTimeToUnixTime", { enumerable: true, get: function() {
      return timeConversion_1.rippleTimeToUnixTime;
    } });
    Object.defineProperty(exports, "unixTimeToRippleTime", { enumerable: true, get: function() {
      return timeConversion_1.unixTimeToRippleTime;
    } });
    var verifyPaymentChannelClaim_1 = __importDefault(require_verifyPaymentChannelClaim());
    exports.verifyPaymentChannelClaim = verifyPaymentChannelClaim_1.default;
    var xrpConversion_1 = require_xrpConversion();
    Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function() {
      return xrpConversion_1.xrpToDrops;
    } });
    Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function() {
      return xrpConversion_1.dropsToXrp;
    } });
    function isValidSecret(secret) {
      try {
        (0, derive_1.deriveKeypair)(secret);
        return true;
      } catch (_err) {
        return false;
      }
    }
    exports.isValidSecret = isValidSecret;
    function encode(object) {
      return (0, ripple_binary_codec_1.encode)(object);
    }
    exports.encode = encode;
    function encodeForSigning(object) {
      return (0, ripple_binary_codec_1.encodeForSigning)(object);
    }
    exports.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(object) {
      return (0, ripple_binary_codec_1.encodeForSigningClaim)(object);
    }
    exports.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultiSigning(object, signer) {
      return (0, ripple_binary_codec_1.encodeForMultisigning)(object, signer);
    }
    exports.encodeForMultiSigning = encodeForMultiSigning;
    function decode(hex) {
      return (0, ripple_binary_codec_1.decode)(hex);
    }
    exports.decode = decode;
    function isValidAddress(address) {
      return (0, ripple_address_codec_1.isValidXAddress)(address) || (0, ripple_address_codec_1.isValidClassicAddress)(address);
    }
    exports.isValidAddress = isValidAddress;
    function hasNextPage(response) {
      return Boolean(response.result["marker"]);
    }
    exports.hasNextPage = hasNextPage;
    var hashes = {
      hashSignedTx: hashes_1.hashSignedTx,
      hashTx: hashes_1.hashTx,
      hashAccountRoot: hashes_1.hashAccountRoot,
      hashSignerListId: hashes_1.hashSignerListId,
      hashOfferId: hashes_1.hashOfferId,
      hashTrustline: hashes_1.hashTrustline,
      hashTxTree: hashes_1.hashTxTree,
      hashStateTree: hashes_1.hashStateTree,
      hashLedger: hashes_1.hashLedger,
      hashLedgerHeader: hashes_1.hashLedgerHeader,
      hashEscrow: hashes_1.hashEscrow,
      hashPaymentChannel: hashes_1.hashPaymentChannel
    };
    exports.hashes = hashes;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/submit.js
var require_submit = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/submit.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils8();
    var LEDGER_CLOSE_TIME = 1e3;
    function sleep(ms) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
          setTimeout(resolve, ms);
        });
      });
    }
    function submitRequest(client, signedTransaction, failHard = false) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!isSigned(signedTransaction)) {
          throw new errors_1.ValidationError("Transaction must be signed.");
        }
        const signedTxEncoded = typeof signedTransaction === "string" ? signedTransaction : (0, utils_1.encode)(signedTransaction);
        const request = {
          command: "submit",
          tx_blob: signedTxEncoded,
          fail_hard: isAccountDelete(signedTransaction) || failHard
        };
        return client.request(request);
      });
    }
    exports.submitRequest = submitRequest;
    function waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {
      return __awaiter(this, void 0, void 0, function* () {
        yield sleep(LEDGER_CLOSE_TIME);
        const latestLedger = yield client.getLedgerIndex();
        if (lastLedger < latestLedger) {
          throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).
Preliminary result: ${submissionResult}`);
        }
        const txResponse = yield client.request({
          command: "tx",
          transaction: txHash
        }).catch((error) => __awaiter(this, void 0, void 0, function* () {
          var _a;
          const message = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;
          if (message === "txnNotFound") {
            return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
          }
          throw new Error(`${message} 
 Preliminary result: ${submissionResult}.
Full error details: ${String(error)}`);
        }));
        if (txResponse.result.validated) {
          return txResponse;
        }
        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
      });
    }
    exports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;
    function isSigned(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      if (typeof tx === "string") {
        return false;
      }
      if (tx.Signers != null) {
        const signers = tx.Signers;
        for (const signer of signers) {
          if (signer.Signer.SigningPubKey == null || signer.Signer.TxnSignature == null) {
            return false;
          }
        }
        return true;
      }
      return tx.SigningPubKey != null && tx.TxnSignature != null;
    }
    function getSignedTx(client, transaction, { autofill = true, wallet } = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (isSigned(transaction)) {
          return transaction;
        }
        if (!wallet) {
          throw new errors_1.ValidationError("Wallet must be provided when submitting an unsigned transaction");
        }
        let tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
        if (autofill) {
          tx = yield client.autofill(tx);
        }
        return wallet.sign(tx).tx_blob;
      });
    }
    exports.getSignedTx = getSignedTx;
    function getLastLedgerSequence(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      return tx.LastLedgerSequence;
    }
    exports.getLastLedgerSequence = getLastLedgerSequence;
    function isAccountDelete(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      return tx.TransactionType === "AccountDelete";
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/utils.js
var require_utils9 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureClassicAddress = void 0;
    var ripple_address_codec_1 = require_dist();
    function ensureClassicAddress(account) {
      if ((0, ripple_address_codec_1.isValidXAddress)(account)) {
        const { classicAddress, tag } = (0, ripple_address_codec_1.xAddressToClassicAddress)(account);
        if (tag !== false) {
          throw new Error("This command does not support the use of a tag. Use an address without a tag.");
        }
        return classicAddress;
      }
      return account;
    }
    exports.ensureClassicAddress = ensureClassicAddress;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/index.js
var require_sugar = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_submit(), exports);
    __exportStar(require_utils9(), exports);
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/getFeeXrp.js
var require_getFeeXrp = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/getFeeXrp.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var NUM_DECIMAL_PLACES = 6;
    var BASE_10 = 10;
    function getFeeXrp(client, cushion) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const feeCushion = cushion !== null && cushion !== void 0 ? cushion : client.feeCushion;
        const serverInfo = (yield client.request({
          command: "server_info"
        })).result.info;
        const baseFee = (_a = serverInfo.validated_ledger) === null || _a === void 0 ? void 0 : _a.base_fee_xrp;
        if (baseFee == null) {
          throw new errors_1.XrplError("getFeeXrp: Could not get base_fee_xrp from server_info");
        }
        const baseFeeXrp = new bignumber_js_1.default(baseFee);
        if (serverInfo.load_factor == null) {
          serverInfo.load_factor = 1;
        }
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(feeCushion);
        fee = bignumber_js_1.default.min(fee, client.maxFeeXRP);
        return new bignumber_js_1.default(fee.toFixed(NUM_DECIMAL_PLACES)).toString(BASE_10);
      });
    }
    exports.default = getFeeXrp;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/autofill.js
var require_autofill = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/autofill.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkAccountDeleteBlockers = exports.setLatestValidatedLedgerSequence = exports.calculateFeePerTransactionType = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    var utils_1 = require_utils8();
    var getFeeXrp_1 = __importDefault(require_getFeeXrp());
    var LEDGER_OFFSET = 20;
    var RESTRICTED_NETWORKS = 1024;
    var REQUIRED_NETWORKID_VERSION = "1.11.0";
    function isNotLaterRippledVersion(source, target) {
      if (source === target) {
        return true;
      }
      const sourceDecomp = source.split(".");
      const targetDecomp = target.split(".");
      const sourceMajor = parseInt(sourceDecomp[0], 10);
      const sourceMinor = parseInt(sourceDecomp[1], 10);
      const targetMajor = parseInt(targetDecomp[0], 10);
      const targetMinor = parseInt(targetDecomp[1], 10);
      if (sourceMajor !== targetMajor) {
        return sourceMajor < targetMajor;
      }
      if (sourceMinor !== targetMinor) {
        return sourceMinor < targetMinor;
      }
      const sourcePatch = sourceDecomp[2].split("-");
      const targetPatch = targetDecomp[2].split("-");
      const sourcePatchVersion = parseInt(sourcePatch[0], 10);
      const targetPatchVersion = parseInt(targetPatch[0], 10);
      if (sourcePatchVersion !== targetPatchVersion) {
        return sourcePatchVersion < targetPatchVersion;
      }
      if (sourcePatch.length !== targetPatch.length) {
        return sourcePatch.length > targetPatch.length;
      }
      if (sourcePatch.length === 2) {
        if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {
          return sourcePatch[1] < targetPatch[1];
        }
        if (sourcePatch[1].startsWith("b")) {
          return parseInt(sourcePatch[1].slice(1), 10) < parseInt(targetPatch[1].slice(1), 10);
        }
        return parseInt(sourcePatch[1].slice(2), 10) < parseInt(targetPatch[1].slice(2), 10);
      }
      return false;
    }
    function txNeedsNetworkID(client) {
      if (client.networkID !== void 0 && client.networkID > RESTRICTED_NETWORKS) {
        if (client.buildVersion && isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client.buildVersion)) {
          return true;
        }
      }
      return false;
    }
    exports.txNeedsNetworkID = txNeedsNetworkID;
    function setValidAddresses(tx) {
      validateAccountAddress(tx, "Account", "SourceTag");
      if (tx["Destination"] != null) {
        validateAccountAddress(tx, "Destination", "DestinationTag");
      }
      convertToClassicAddress(tx, "Authorize");
      convertToClassicAddress(tx, "Unauthorize");
      convertToClassicAddress(tx, "Owner");
      convertToClassicAddress(tx, "RegularKey");
    }
    exports.setValidAddresses = setValidAddresses;
    function validateAccountAddress(tx, accountField, tagField) {
      const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField]);
      tx[accountField] = classicAccount;
      if (tag != null && tag !== false) {
        if (tx[tagField] && tx[tagField] !== tag) {
          throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);
        }
        tx[tagField] = tag;
      }
    }
    function getClassicAccountAndTag(Account, expectedTag) {
      if ((0, ripple_address_codec_1.isValidXAddress)(Account)) {
        const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(Account);
        if (expectedTag != null && classic.tag !== expectedTag) {
          throw new errors_1.ValidationError("address includes a tag that does not match the tag specified in the transaction");
        }
        return {
          classicAccount: classic.classicAddress,
          tag: classic.tag
        };
      }
      return {
        classicAccount: Account,
        tag: expectedTag
      };
    }
    function convertToClassicAddress(tx, fieldName) {
      const account = tx[fieldName];
      if (typeof account === "string") {
        const { classicAccount } = getClassicAccountAndTag(account);
        tx[fieldName] = classicAccount;
      }
    }
    function setNextValidSequenceNumber(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_info",
          account: tx.Account,
          ledger_index: "current"
        };
        const data = yield client.request(request);
        tx.Sequence = data.result.account_data.Sequence;
      });
    }
    exports.setNextValidSequenceNumber = setNextValidSequenceNumber;
    function fetchOwnerReserveFee(client) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield client.request({ command: "server_state" });
        const fee = (_a = response.result.state.validated_ledger) === null || _a === void 0 ? void 0 : _a.reserve_inc;
        if (fee == null) {
          return Promise.reject(new Error("Could not fetch Owner Reserve."));
        }
        return new bignumber_js_1.default(fee);
      });
    }
    function calculateFeePerTransactionType(client, tx, signersCount = 0) {
      return __awaiter(this, void 0, void 0, function* () {
        const netFeeXRP = yield (0, getFeeXrp_1.default)(client);
        const netFeeDrops = (0, utils_1.xrpToDrops)(netFeeXRP);
        let baseFee = new bignumber_js_1.default(netFeeDrops);
        if (tx.TransactionType === "EscrowFinish" && tx.Fulfillment != null) {
          const fulfillmentBytesSize = Math.ceil(tx.Fulfillment.length / 2);
          baseFee = new bignumber_js_1.default(scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16));
        }
        const isSpecialTxCost = ["AccountDelete", "AMMCreate"].includes(tx.TransactionType);
        if (isSpecialTxCost) {
          baseFee = yield fetchOwnerReserveFee(client);
        }
        if (signersCount > 0) {
          baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, 1 + signersCount));
        }
        const maxFeeDrops = (0, utils_1.xrpToDrops)(client.maxFeeXRP);
        const totalFee = isSpecialTxCost ? baseFee : bignumber_js_1.default.min(baseFee, maxFeeDrops);
        tx.Fee = totalFee.dp(0, bignumber_js_1.default.ROUND_CEIL).toString(10);
      });
    }
    exports.calculateFeePerTransactionType = calculateFeePerTransactionType;
    function scaleValue(value, multiplier) {
      return new bignumber_js_1.default(value).times(multiplier).toString();
    }
    function setLatestValidatedLedgerSequence(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const ledgerSequence = yield client.getLedgerIndex();
        tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
      });
    }
    exports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;
    function checkAccountDeleteBlockers(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_objects",
          account: tx.Account,
          ledger_index: "validated",
          deletion_blockers_only: true
        };
        const response = yield client.request(request);
        return new Promise((resolve, reject) => {
          if (response.result.account_objects.length > 0) {
            reject(new errors_1.XrplError(`Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));
          }
          resolve();
        });
      });
    }
    exports.checkAccountDeleteBlockers = checkAccountDeleteBlockers;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/balances.js
var require_balances = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/balances.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBalances = void 0;
    function formatBalances(trustlines) {
      return trustlines.map((trustline) => ({
        value: trustline.balance,
        currency: trustline.currency,
        issuer: trustline.account
      }));
    }
    exports.formatBalances = formatBalances;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/Offer.js
var require_Offer = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/Offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OfferFlags = void 0;
    var OfferFlags;
    (function(OfferFlags2) {
      OfferFlags2[OfferFlags2["lsfPassive"] = 65536] = "lsfPassive";
      OfferFlags2[OfferFlags2["lsfSell"] = 131072] = "lsfSell";
    })(OfferFlags || (exports.OfferFlags = OfferFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/getOrderbook.js
var require_getOrderbook = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/sugar/getOrderbook.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortAndLimitOffers = exports.separateBuySellOrders = exports.combineOrders = exports.extractOffers = exports.reverseRequest = exports.requestAllOffers = exports.createBookOffersRequest = exports.validateOrderbookOptions = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var Offer_1 = require_Offer();
    var DEFAULT_LIMIT = 20;
    function sortOffers(offers) {
      return offers.sort((offerA, offerB) => {
        var _a, _b;
        const qualityA = (_a = offerA.quality) !== null && _a !== void 0 ? _a : 0;
        const qualityB = (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;
        return new bignumber_js_1.default(qualityA).comparedTo(qualityB);
      });
    }
    var getOrderbookOptionsSet = /* @__PURE__ */ new Set([
      "limit",
      "ledger_index",
      "ledger_hash",
      "taker"
    ]);
    function validateOrderbookOptions(options) {
      for (const key of Object.keys(options)) {
        if (!getOrderbookOptionsSet.has(key)) {
          throw new errors_1.ValidationError(`Unexpected option: ${key}`, options);
        }
      }
      if (options.limit && typeof options.limit !== "number") {
        throw new errors_1.ValidationError("limit must be a number", options.limit);
      }
      if (options.ledger_index && !(typeof options.ledger_index === "number" || typeof options.ledger_index === "string" && ["validated", "closed", "current"].includes(options.ledger_index))) {
        throw new errors_1.ValidationError('ledger_index must be a number or a string of "validated", "closed", or "current"', options.ledger_index);
      }
      if (options.ledger_hash !== void 0 && options.ledger_hash !== null && typeof options.ledger_hash !== "string") {
        throw new errors_1.ValidationError("ledger_hash must be a string", options.ledger_hash);
      }
      if (options.taker !== void 0 && typeof options.taker !== "string") {
        throw new errors_1.ValidationError("taker must be a string", options.taker);
      }
    }
    exports.validateOrderbookOptions = validateOrderbookOptions;
    function createBookOffersRequest(currency1, currency2, options) {
      var _a, _b;
      const request = {
        command: "book_offers",
        taker_pays: currency1,
        taker_gets: currency2,
        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
        ledger_hash: options.ledger_hash === null ? void 0 : options.ledger_hash,
        limit: (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,
        taker: options.taker ? options.taker : void 0
      };
      return request;
    }
    exports.createBookOffersRequest = createBookOffersRequest;
    function requestAllOffers(client, request) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield client.requestAll(request);
        return results.map((result) => result.result.offers);
      });
    }
    exports.requestAllOffers = requestAllOffers;
    function reverseRequest(request) {
      return Object.assign(Object.assign({}, request), { taker_pays: request.taker_gets, taker_gets: request.taker_pays });
    }
    exports.reverseRequest = reverseRequest;
    function extractOffers(offerResults) {
      return offerResults.flatMap((offerResult) => offerResult);
    }
    exports.extractOffers = extractOffers;
    function combineOrders(directOffers, reverseOffers) {
      return [...directOffers, ...reverseOffers];
    }
    exports.combineOrders = combineOrders;
    function separateBuySellOrders(orders) {
      const buy = [];
      const sell = [];
      orders.forEach((order) => {
        if ((order.Flags & Offer_1.OfferFlags.lsfSell) === 0) {
          buy.push(order);
        } else {
          sell.push(order);
        }
      });
      return { buy, sell };
    }
    exports.separateBuySellOrders = separateBuySellOrders;
    function sortAndLimitOffers(offers, limit) {
      const sortedOffers = sortOffers(offers);
      return sortedOffers.slice(0, limit);
    }
    exports.sortAndLimitOffers = sortAndLimitOffers;
  }
});

// node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HDKey = exports.HARDENED_OFFSET = void 0;
    var modular_1 = require_modular();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac();
    var legacy_1 = require_legacy();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var Point = secp256k1_1.secp256k1.ProjectivePoint;
    var base58check = (0, base_1.createBase58check)(sha2_1.sha256);
    function bytesToNumber(bytes) {
      (0, utils_1.abytes)(bytes);
      const h = bytes.length === 0 ? "0" : (0, utils_1.bytesToHex)(bytes);
      return BigInt("0x" + h);
    }
    function numberToBytes(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, "0"));
    }
    var MASTER_SECRET = (0, utils_1.utf8ToBytes)("Bitcoin seed");
    var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
    exports.HARDENED_OFFSET = 2147483648;
    var hash160 = (data) => (0, legacy_1.ripemd160)((0, sha2_1.sha256)(data));
    var fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
    var toU32 = (n) => {
      if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
      }
      const buf = new Uint8Array(4);
      (0, utils_1.createView)(buf).setUint32(0, n, false);
      return buf;
    };
    var HDKey = class _HDKey {
      get fingerprint() {
        if (!this.pubHash) {
          throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
      }
      get identifier() {
        return this.pubHash;
      }
      get pubKeyHash() {
        return this.pubHash;
      }
      get privateKey() {
        return this.privKeyBytes || null;
      }
      get publicKey() {
        return this.pubKey || null;
      }
      get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("No private key");
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
      }
      get publicExtendedKey() {
        if (!this.pubKey) {
          throw new Error("No public key");
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
      }
      static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, utils_1.abytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
          throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, MASTER_SECRET, seed);
        return new _HDKey({
          versions,
          chainCode: I.slice(32),
          privateKey: I.slice(0, 32)
        });
      }
      static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
          versions,
          depth: keyBuffer[4],
          parentFingerprint: keyView.getUint32(5, false),
          index: keyView.getUint32(9, false),
          chainCode: keyBuffer.slice(13, 45)
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? "private" : "public"]) {
          throw new Error("Version mismatch");
        }
        if (isPriv) {
          return new _HDKey({ ...opt, privateKey: key.slice(1) });
        } else {
          return new _HDKey({ ...opt, publicKey: key });
        }
      }
      static fromJSON(json) {
        return _HDKey.fromExtendedKey(json.xpriv);
      }
      constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== "object") {
          throw new Error("HDKey.constructor must not be called directly");
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
          if (this.parentFingerprint || this.index) {
            throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
          }
        }
        if (opt.publicKey && opt.privateKey) {
          throw new Error("HDKey: publicKey and privateKey at same time.");
        }
        if (opt.privateKey) {
          if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
            throw new Error("Invalid private key");
          }
          this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
          this.privKeyBytes = numberToBytes(this.privKey);
          this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        } else if (opt.publicKey) {
          this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
        } else {
          throw new Error("HDKey: no public or private key provided");
        }
        this.pubHash = hash160(this.pubKey);
      }
      derive(path) {
        if (!/^[mM]'?/.test(path)) {
          throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
          return this;
        }
        const parts = path.replace(/^[mM]'?\//, "").split("/");
        let child = this;
        for (const c of parts) {
          const m = /^(\d+)('?)$/.exec(c);
          const m1 = m && m[1];
          if (!m || m.length !== 3 || typeof m1 !== "string")
            throw new Error("invalid child index: " + c);
          let idx = +m1;
          if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
            throw new Error("Invalid index");
          }
          if (m[2] === "'") {
            idx += exports.HARDENED_OFFSET;
          }
          child = child.deriveChild(idx);
        }
        return child;
      }
      deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
          throw new Error("No publicKey or chainCode set");
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
          const priv = this.privateKey;
          if (!priv) {
            throw new Error("Could not derive hardened child key");
          }
          data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        } else {
          data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
          throw new Error("Tweak bigger than curve order");
        }
        const opt = {
          versions: this.versions,
          chainCode,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint,
          index
        };
        try {
          if (this.privateKey) {
            const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
              throw new Error("The tweak was out of range or the resulted private key is invalid");
            }
            opt.privateKey = added;
          } else {
            const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
            if (added.equals(Point.ZERO)) {
              throw new Error("The tweak was equal to negative P, which made the result key invalid");
            }
            opt.publicKey = added.toRawBytes(true);
          }
          return new _HDKey(opt);
        } catch (err) {
          return this.deriveChild(index + 1);
        }
      }
      sign(hash) {
        if (!this.privateKey) {
          throw new Error("No privateKey set!");
        }
        (0, utils_1.abytes)(hash, 32);
        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();
      }
      verify(hash, signature) {
        (0, utils_1.abytes)(hash, 32);
        (0, utils_1.abytes)(signature, 64);
        if (!this.publicKey) {
          throw new Error("No publicKey set!");
        }
        let sig;
        try {
          sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        } catch (error) {
          return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
      }
      wipePrivateData() {
        this.privKey = void 0;
        if (this.privKeyBytes) {
          this.privKeyBytes.fill(0);
          this.privKeyBytes = void 0;
        }
        return this;
      }
      toJSON() {
        return {
          xpriv: this.privateExtendedKey,
          xpub: this.publicExtendedKey
        };
      }
      serialize(version, key) {
        if (!this.chainCode) {
          throw new Error("No chainCode set");
        }
        (0, utils_1.abytes)(key, 33);
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
      }
    };
    exports.HDKey = HDKey;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = pbkdf2;
    exports.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMnemonic = generateMnemonic;
    exports.mnemonicToEntropy = mnemonicToEntropy;
    exports.entropyToMnemonic = entropyToMnemonic;
    exports.validateMnemonic = validateMnemonic;
    exports.mnemonicToSeed = mnemonicToSeed;
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError("invalid mnemonic type: " + typeof str);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function aentropy(ent) {
      (0, utils_1.abytes)(ent, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      (0, utils_1.anumber)(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha2_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error("wordlist: non-string element: " + i);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      aentropy(entropy);
      return entropy;
    }
    function entropyToMnemonic(entropy, wordlist) {
      aentropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "　" : " ");
    }
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js
var require_english = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/ECDSA.js
var require_ECDSA = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/ECDSA.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ECDSA;
    (function(ECDSA2) {
      ECDSA2["ed25519"] = "ed25519";
      ECDSA2["secp256k1"] = "ecdsa-secp256k1";
    })(ECDSA || (ECDSA = {}));
    exports.default = ECDSA;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/accountDelete.js
var require_accountDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/accountDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAccountDelete = void 0;
    var common_1 = require_common2();
    function validateAccountDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
    }
    exports.validateAccountDelete = validateAccountDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMBid.js
var require_AMMBid = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMBid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMBid = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var MAX_AUTH_ACCOUNTS = 4;
    function validateAMMBid(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMBid: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMBid: Asset2 must be a Currency");
      }
      if (tx.BidMin != null && !(0, common_1.isAmount)(tx.BidMin)) {
        throw new errors_1.ValidationError("AMMBid: BidMin must be an Amount");
      }
      if (tx.BidMax != null && !(0, common_1.isAmount)(tx.BidMax)) {
        throw new errors_1.ValidationError("AMMBid: BidMax must be an Amount");
      }
      if (tx.AuthAccounts != null) {
        if (!Array.isArray(tx.AuthAccounts)) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts must be an AuthAccount array`);
        }
        if (tx.AuthAccounts.length > MAX_AUTH_ACCOUNTS) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts length must not be greater than ${MAX_AUTH_ACCOUNTS}`);
        }
        validateAuthAccounts(tx.Account, tx.AuthAccounts);
      }
    }
    exports.validateAMMBid = validateAMMBid;
    function validateAuthAccounts(senderAddress, authAccounts) {
      for (const authAccount of authAccounts) {
        if (authAccount.AuthAccount == null || typeof authAccount.AuthAccount !== "object") {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account == null) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (typeof authAccount.AuthAccount.Account !== "string") {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account === senderAddress) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts must not include sender's address`);
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js
var require_AMMCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMCreate = exports.AMM_MAX_TRADING_FEE = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    exports.AMM_MAX_TRADING_FEE = 1e3;
    function validateAMMCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMCreate: Amount must be an Amount");
      }
      if (tx.Amount2 == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount2");
      }
      if (!(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMCreate: Amount2 must be an Amount");
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field TradingFee");
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError("AMMCreate: TradingFee must be a number");
      }
      if (tx.TradingFee < 0 || tx.TradingFee > exports.AMM_MAX_TRADING_FEE) {
        throw new errors_1.ValidationError(`AMMCreate: TradingFee must be between 0 and ${exports.AMM_MAX_TRADING_FEE}`);
      }
    }
    exports.validateAMMCreate = validateAMMCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js
var require_AMMDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateAMMDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMDelete: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMDelete: Asset2 must be a Currency");
      }
    }
    exports.validateAMMDelete = validateAMMDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMVote.js
var require_AMMVote = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/AMMVote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMVote = void 0;
    var errors_1 = require_errors();
    var AMMCreate_1 = require_AMMCreate();
    var common_1 = require_common2();
    function validateAMMVote(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMVote: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMVote: Asset2 must be a Currency");
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError("AMMVote: missing field TradingFee");
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError("AMMVote: TradingFee must be a number");
      }
      if (tx.TradingFee < 0 || tx.TradingFee > AMMCreate_1.AMM_MAX_TRADING_FEE) {
        throw new errors_1.ValidationError(`AMMVote: TradingFee must be between 0 and ${AMMCreate_1.AMM_MAX_TRADING_FEE}`);
      }
    }
    exports.validateAMMVote = validateAMMVote;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCancel.js
var require_checkCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateCheckCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCancel: invalid CheckID");
      }
    }
    exports.validateCheckCancel = validateCheckCancel;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCash.js
var require_checkCash = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCash = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateCheckCash(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null && tx.DeliverMin == null) {
        throw new errors_1.ValidationError("CheckCash: must have either Amount or DeliverMin");
      }
      if (tx.Amount != null && tx.DeliverMin != null) {
        throw new errors_1.ValidationError("CheckCash: cannot have both Amount and DeliverMin");
      }
      if (tx.Amount != null && tx.Amount !== void 0 && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("CheckCash: invalid Amount");
      }
      if (tx.DeliverMin != null && tx.DeliverMin !== void 0 && !(0, common_1.isAmount)(tx.DeliverMin)) {
        throw new errors_1.ValidationError("CheckCash: invalid DeliverMin");
      }
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCash: invalid CheckID");
      }
    }
    exports.validateCheckCash = validateCheckCash;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCreate.js
var require_checkCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/checkCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateCheckCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.SendMax === void 0) {
        throw new errors_1.ValidationError("CheckCreate: missing field SendMax");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (typeof tx.SendMax !== "string" && !(0, common_1.isIssuedCurrency)(tx.SendMax)) {
        throw new errors_1.ValidationError("CheckCreate: invalid SendMax");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("CheckCreate: invalid Expiration");
      }
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError("CheckCreate: invalid InvoiceID");
      }
    }
    exports.validateCheckCreate = validateCheckCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/clawback.js
var require_clawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/clawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateClawback = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
      if (tx.Amount == null) {
        throw new errors_1.ValidationError("Clawback: missing field Amount");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Amount) && !(0, common_1.isMPTAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("Clawback: invalid Amount");
      }
      if ((0, common_1.isIssuedCurrency)(tx.Amount) && tx.Account === tx.Amount.issuer) {
        throw new errors_1.ValidationError("Clawback: invalid holder Account");
      }
      if ((0, common_1.isMPTAmount)(tx.Amount) && tx.Account === tx.Holder) {
        throw new errors_1.ValidationError("Clawback: invalid holder Account");
      }
      if ((0, common_1.isIssuedCurrency)(tx.Amount) && tx.Holder) {
        throw new errors_1.ValidationError("Clawback: cannot have Holder for currency");
      }
      if ((0, common_1.isMPTAmount)(tx.Amount) && !tx.Holder) {
        throw new errors_1.ValidationError("Clawback: missing Holder");
      }
    }
    exports.validateClawback = validateClawback;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialAccept.js
var require_CredentialAccept = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialAccept.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialAccept = void 0;
    var common_1 = require_common2();
    function validateCredentialAccept(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Issuer", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
    }
    exports.validateCredentialAccept = validateCredentialAccept;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialCreate.js
var require_CredentialCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialCreate = void 0;
    var utils_1 = require_browser();
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var MAX_URI_LENGTH = 256;
    function validateCredentialCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Subject", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
      (0, common_1.validateOptionalField)(tx, "Expiration", common_1.isNumber);
      validateURI(tx.URI);
    }
    exports.validateCredentialCreate = validateCredentialCreate;
    function validateURI(URI) {
      if (URI === void 0) {
        return;
      }
      if (typeof URI !== "string") {
        throw new errors_1.ValidationError("CredentialCreate: invalid field URI");
      }
      if (URI.length === 0) {
        throw new errors_1.ValidationError("CredentialCreate: URI cannot be an empty string");
      } else if (URI.length > MAX_URI_LENGTH) {
        throw new errors_1.ValidationError(`CredentialCreate: URI length must be <= ${MAX_URI_LENGTH}`);
      }
      if (!utils_1.HEX_REGEX.test(URI)) {
        throw new errors_1.ValidationError("CredentialCreate: URI must be encoded in hex");
      }
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialDelete.js
var require_CredentialDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/CredentialDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateCredentialDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (!tx.Subject && !tx.Issuer) {
        throw new errors_1.ValidationError("CredentialDelete: either `Issuer` or `Subject` must be provided");
      }
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
      (0, common_1.validateOptionalField)(tx, "Subject", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Issuer", common_1.isString);
    }
    exports.validateCredentialDelete = validateCredentialDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js
var require_depositPreauth = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDepositPreauth = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateDepositPreauth(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      validateSingleAuthorizationFieldProvided(tx);
      if (tx.Authorize !== void 0) {
        if (typeof tx.Authorize !== "string") {
          throw new errors_1.ValidationError("DepositPreauth: Authorize must be a string");
        }
        if (tx.Account === tx.Authorize) {
          throw new errors_1.ValidationError("DepositPreauth: Account can't preauthorize its own address");
        }
      } else if (tx.Unauthorize !== void 0) {
        if (typeof tx.Unauthorize !== "string") {
          throw new errors_1.ValidationError("DepositPreauth: Unauthorize must be a string");
        }
        if (tx.Account === tx.Unauthorize) {
          throw new errors_1.ValidationError("DepositPreauth: Account can't unauthorize its own address");
        }
      } else if (tx.AuthorizeCredentials !== void 0) {
        (0, common_1.validateCredentialsList)(tx.AuthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);
      } else if (tx.UnauthorizeCredentials !== void 0) {
        (0, common_1.validateCredentialsList)(tx.UnauthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);
      }
    }
    exports.validateDepositPreauth = validateDepositPreauth;
    function validateSingleAuthorizationFieldProvided(tx) {
      const fields = [
        "Authorize",
        "Unauthorize",
        "AuthorizeCredentials",
        "UnauthorizeCredentials"
      ];
      const countProvided = fields.filter((key) => tx[key] !== void 0).length;
      if (countProvided !== 1) {
        throw new errors_1.ValidationError("DepositPreauth: Requires exactly one field of the following: Authorize, Unauthorize, AuthorizeCredentials, UnauthorizeCredentials.");
      }
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js
var require_DIDDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDIDDelete = void 0;
    var common_1 = require_common2();
    function validateDIDDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
    }
    exports.validateDIDDelete = validateDIDDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/DIDSet.js
var require_DIDSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/DIDSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDIDSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateDIDSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "DIDDocument", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      if (tx.Data === void 0 && tx.DIDDocument === void 0 && tx.URI === void 0) {
        throw new errors_1.ValidationError("DIDSet: Must have at least one of `Data`, `DIDDocument`, and `URI`");
      }
    }
    exports.validateDIDSet = validateDIDSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js
var require_escrowCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateEscrowCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError("EscrowCancel: missing OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number" && typeof tx.OfferSequence !== "string" || Number.isNaN(Number(tx.OfferSequence))) {
        throw new errors_1.ValidationError("EscrowCancel: OfferSequence must be a number");
      }
    }
    exports.validateEscrowCancel = validateEscrowCancel;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js
var require_escrowCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateEscrowCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("EscrowCreate: missing field Amount");
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("EscrowCreate: Amount must be a string");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (tx.CancelAfter === void 0 && tx.FinishAfter === void 0) {
        throw new errors_1.ValidationError("EscrowCreate: Either CancelAfter or FinishAfter must be specified");
      }
      if (tx.FinishAfter === void 0 && tx.Condition === void 0) {
        throw new errors_1.ValidationError("EscrowCreate: Either Condition or FinishAfter must be specified");
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError("EscrowCreate: CancelAfter must be a number");
      }
      if (tx.FinishAfter !== void 0 && typeof tx.FinishAfter !== "number") {
        throw new errors_1.ValidationError("EscrowCreate: FinishAfter must be a number");
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError("EscrowCreate: Condition must be a string");
      }
    }
    exports.validateEscrowCreate = validateEscrowCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js
var require_escrowFinish = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowFinish = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateEscrowFinish(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError("EscrowFinish: missing field OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number" && typeof tx.OfferSequence !== "string" || Number.isNaN(Number(tx.OfferSequence))) {
        throw new errors_1.ValidationError("EscrowFinish: OfferSequence must be a number");
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError("EscrowFinish: Condition must be a string");
      }
      if (tx.Fulfillment !== void 0 && typeof tx.Fulfillment !== "string") {
        throw new errors_1.ValidationError("EscrowFinish: Fulfillment must be a string");
      }
    }
    exports.validateEscrowFinish = validateEscrowFinish;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceDestroy.js
var require_MPTokenIssuanceDestroy = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceDestroy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceDestroy = void 0;
    var common_1 = require_common2();
    function validateMPTokenIssuanceDestroy(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
    }
    exports.validateMPTokenIssuanceDestroy = validateMPTokenIssuanceDestroy;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js
var require_NFTokenAcceptOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenAcceptOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateNFTokenBrokerFee(tx) {
      const value = (0, common_1.parseAmountValue)(tx.NFTokenBrokerFee);
      if (Number.isNaN(value)) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: invalid NFTokenBrokerFee");
      }
      if (value <= 0) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: NFTokenBrokerFee must be greater than 0; omit if there is no fee");
      }
      if (tx.NFTokenSellOffer == null || tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: both NFTokenSellOffer and NFTokenBuyOffer must be set if using brokered mode");
      }
    }
    function validateNFTokenAcceptOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.NFTokenBrokerFee != null) {
        validateNFTokenBrokerFee(tx);
      }
      if (tx.NFTokenSellOffer == null && tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: must set either NFTokenSellOffer or NFTokenBuyOffer");
      }
    }
    exports.validateNFTokenAcceptOffer = validateNFTokenAcceptOffer;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js
var require_NFTokenBurn = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenBurn = void 0;
    var common_1 = require_common2();
    function validateNFTokenBurn(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "NFTokenID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
    }
    exports.validateNFTokenBurn = validateNFTokenBurn;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js
var require_NFTokenCancelOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenCancelOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateNFTokenCancelOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (!Array.isArray(tx.NFTokenOffers)) {
        throw new errors_1.ValidationError("NFTokenCancelOffer: missing field NFTokenOffers");
      }
      if (tx.NFTokenOffers.length < 1) {
        throw new errors_1.ValidationError("NFTokenCancelOffer: empty field NFTokenOffers");
      }
    }
    exports.validateNFTokenCancelOffer = validateNFTokenCancelOffer;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenModify.js
var require_NFTokenModify = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenModify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenModify = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    function validateNFTokenModify(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "NFTokenID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      if (tx.URI !== void 0 && typeof tx.URI === "string") {
        if (tx.URI === "") {
          throw new errors_1.ValidationError("NFTokenModify: URI must not be empty string");
        }
        if (!(0, utils_1.isHex)(tx.URI)) {
          throw new errors_1.ValidationError("NFTokenModify: URI must be in hex format");
        }
      }
    }
    exports.validateNFTokenModify = validateNFTokenModify;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/offerCancel.js
var require_offerCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/offerCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOfferCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateOfferCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.OfferSequence === void 0) {
        throw new errors_1.ValidationError("OfferCancel: missing field OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError("OfferCancel: OfferSequence must be a number");
      }
    }
    exports.validateOfferCancel = validateOfferCancel;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js
var require_oracleDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOracleDelete = void 0;
    var common_1 = require_common2();
    function validateOracleDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "OracleDocumentID", common_1.isNumber);
    }
    exports.validateOracleDelete = validateOracleDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/oracleSet.js
var require_oracleSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/oracleSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOracleSet = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common2();
    var PRICE_DATA_SERIES_MAX_LENGTH = 10;
    var SCALE_MAX = 10;
    var MINIMUM_ASSET_PRICE_LENGTH = 1;
    var MAXIMUM_ASSET_PRICE_LENGTH = 16;
    function validateOracleSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "OracleDocumentID", common_1.isNumber);
      (0, common_1.validateRequiredField)(tx, "LastUpdateTime", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "Provider", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "AssetClass", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "PriceDataSeries", (value) => {
        if (!Array.isArray(value)) {
          throw new errors_1.ValidationError("OracleSet: PriceDataSeries must be an array");
        }
        if (value.length > PRICE_DATA_SERIES_MAX_LENGTH) {
          throw new errors_1.ValidationError(`OracleSet: PriceDataSeries must have at most ${PRICE_DATA_SERIES_MAX_LENGTH} PriceData objects`);
        }
        for (const priceData of value) {
          if (typeof priceData !== "object") {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must be an array of objects");
          }
          if (priceData.PriceData == null) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `PriceData` object");
          }
          if (Object.keys(priceData).length !== 1) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must only have a single PriceData object");
          }
          if (typeof priceData.PriceData.BaseAsset !== "string") {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `BaseAsset` string");
          }
          if (typeof priceData.PriceData.QuoteAsset !== "string") {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `QuoteAsset` string");
          }
          if (priceData.PriceData.AssetPrice == null !== (priceData.PriceData.Scale == null)) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have both `AssetPrice` and `Scale` if any are present");
          }
          if ("AssetPrice" in priceData.PriceData) {
            if (!(0, common_1.isNumber)(priceData.PriceData.AssetPrice)) {
              if (typeof priceData.PriceData.AssetPrice !== "string") {
                throw new errors_1.ValidationError("OracleSet: Field AssetPrice must be a string or a number");
              }
              if (!(0, utils_1.isHex)(priceData.PriceData.AssetPrice)) {
                throw new errors_1.ValidationError("OracleSet: Field AssetPrice must be a valid hex string");
              }
              if (priceData.PriceData.AssetPrice.length < MINIMUM_ASSET_PRICE_LENGTH || priceData.PriceData.AssetPrice.length > MAXIMUM_ASSET_PRICE_LENGTH) {
                throw new errors_1.ValidationError(`OracleSet: Length of AssetPrice field must be between ${MINIMUM_ASSET_PRICE_LENGTH} and ${MAXIMUM_ASSET_PRICE_LENGTH} characters long`);
              }
            }
          }
          if ("Scale" in priceData.PriceData && !(0, common_1.isNumber)(priceData.PriceData.Scale)) {
            throw new errors_1.ValidationError("OracleSet: invalid field Scale");
          }
          if (priceData.PriceData.Scale < 0 || priceData.PriceData.Scale > SCALE_MAX) {
            throw new errors_1.ValidationError(`OracleSet: Scale must be in range 0-${SCALE_MAX}`);
          }
        }
        return true;
      });
    }
    exports.validateOracleSet = validateOracleSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js
var require_paymentChannelCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validatePaymentChannelCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing Amount");
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelCreate: Amount must be a string");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (tx.SettleDelay === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing SettleDelay");
      }
      if (typeof tx.SettleDelay !== "number") {
        throw new errors_1.ValidationError("PaymentChannelCreate: SettleDelay must be a number");
      }
      if (tx.PublicKey === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing PublicKey");
      }
      if (typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError("PaymentChannelCreate: PublicKey must be a string");
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError("PaymentChannelCreate: CancelAfter must be a number");
      }
    }
    exports.validatePaymentChannelCreate = validatePaymentChannelCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js
var require_paymentChannelFund = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelFund = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validatePaymentChannelFund(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError("PaymentChannelFund: missing Channel");
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError("PaymentChannelFund: Channel must be a string");
      }
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentChannelFund: missing Amount");
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelFund: Amount must be a string");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("PaymentChannelFund: Expiration must be a number");
      }
    }
    exports.validatePaymentChannelFund = validatePaymentChannelFund;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainDelete.js
var require_permissionedDomainDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePermissionedDomainDelete = void 0;
    var common_1 = require_common2();
    function validatePermissionedDomainDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "DomainID", common_1.isString);
    }
    exports.validatePermissionedDomainDelete = validatePermissionedDomainDelete;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainSet.js
var require_permissionedDomainSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePermissionedDomainSet = void 0;
    var common_1 = require_common2();
    var MAX_ACCEPTED_CREDENTIALS = 10;
    function validatePermissionedDomainSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "AcceptedCredentials", () => tx.AcceptedCredentials instanceof Array);
      (0, common_1.validateCredentialsList)(tx.AcceptedCredentials, tx.TransactionType, false, MAX_ACCEPTED_CREDENTIALS);
    }
    exports.validatePermissionedDomainSet = validatePermissionedDomainSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js
var require_setRegularKey = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSetRegularKey = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    function validateSetRegularKey(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.RegularKey !== void 0 && typeof tx.RegularKey !== "string") {
        throw new errors_1.ValidationError("SetRegularKey: RegularKey must be a string");
      }
    }
    exports.validateSetRegularKey = validateSetRegularKey;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/signerListSet.js
var require_signerListSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/signerListSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSignerListSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var MAX_SIGNERS = 32;
    var HEX_WALLET_LOCATOR_REGEX = /^[0-9A-Fa-f]{64}$/u;
    function validateSignerListSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.SignerQuorum === void 0) {
        throw new errors_1.ValidationError("SignerListSet: missing field SignerQuorum");
      }
      if (typeof tx.SignerQuorum !== "number") {
        throw new errors_1.ValidationError("SignerListSet: invalid SignerQuorum");
      }
      if (tx.SignerQuorum === 0) {
        return;
      }
      if (tx.SignerEntries === void 0) {
        throw new errors_1.ValidationError("SignerListSet: missing field SignerEntries");
      }
      if (!Array.isArray(tx.SignerEntries)) {
        throw new errors_1.ValidationError("SignerListSet: invalid SignerEntries");
      }
      if (tx.SignerEntries.length === 0) {
        throw new errors_1.ValidationError("SignerListSet: need at least 1 member in SignerEntries");
      }
      if (tx.SignerEntries.length > MAX_SIGNERS) {
        throw new errors_1.ValidationError(`SignerListSet: maximum of ${MAX_SIGNERS} members allowed in SignerEntries`);
      }
      for (const entry of tx.SignerEntries) {
        const signerEntry = entry;
        const { WalletLocator } = signerEntry.SignerEntry;
        if (WalletLocator !== void 0 && !HEX_WALLET_LOCATOR_REGEX.test(WalletLocator)) {
          throw new errors_1.ValidationError(`SignerListSet: WalletLocator in SignerEntry must be a 256-bit (32-byte) hexadecimal value`);
        }
      }
    }
    exports.validateSignerListSet = validateSignerListSet;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js
var require_ticketCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTicketCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var MAX_TICKETS = 250;
    function validateTicketCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { TicketCount } = tx;
      if (TicketCount === void 0) {
        throw new errors_1.ValidationError("TicketCreate: missing field TicketCount");
      }
      if (typeof TicketCount !== "number") {
        throw new errors_1.ValidationError("TicketCreate: TicketCount must be a number");
      }
      if (!Number.isInteger(TicketCount) || TicketCount < 1 || TicketCount > MAX_TICKETS) {
        throw new errors_1.ValidationError("TicketCreate: TicketCount must be an integer from 1 to 250");
      }
    }
    exports.validateTicketCreate = validateTicketCreate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js
var require_XChainAccountCreateCommit = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAccountCreateCommit = void 0;
    var common_1 = require_common2();
    function validateXChainAccountCreateCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainAccountCreateCommit = validateXChainAccountCreateCommit;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js
var require_XChainAddAccountCreateAttestation = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAddAccountCreateAttestation = void 0;
    var common_1 = require_common2();
    function validateXChainAddAccountCreateAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "AttestationRewardAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "AttestationSignerAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
      (0, common_1.validateRequiredField)(tx, "XChainAccountCreateCount", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
    }
    exports.validateXChainAddAccountCreateAttestation = validateXChainAddAccountCreateAttestation;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js
var require_XChainAddClaimAttestation = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAddClaimAttestation = void 0;
    var common_1 = require_common2();
    function validateXChainAddClaimAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "AttestationRewardAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "AttestationSignerAccount", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
    }
    exports.validateXChainAddClaimAttestation = validateXChainAddClaimAttestation;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js
var require_XChainClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainClaim = void 0;
    var common_1 = require_common2();
    function validateXChainClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainClaim = validateXChainClaim;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js
var require_XChainCommit = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCommit = void 0;
    var common_1 = require_common2();
    function validateXChainCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateOptionalField)(tx, "OtherChainDestination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainCommit = validateXChainCommit;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js
var require_XChainCreateBridge = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCreateBridge = void 0;
    var common_1 = require_common2();
    function validateXChainCreateBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "MinAccountCreateAmount", common_1.isAmount);
    }
    exports.validateXChainCreateBridge = validateXChainCreateBridge;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js
var require_XChainCreateClaimID = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCreateClaimID = void 0;
    var common_1 = require_common2();
    function validateXChainCreateClaimID(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
    }
    exports.validateXChainCreateClaimID = validateXChainCreateClaimID;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/transaction.js
var require_transaction = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validate = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var flags_1 = require_flags();
    var accountDelete_1 = require_accountDelete();
    var accountSet_1 = require_accountSet();
    var AMMBid_1 = require_AMMBid();
    var AMMClawback_1 = require_AMMClawback();
    var AMMCreate_1 = require_AMMCreate();
    var AMMDelete_1 = require_AMMDelete();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMVote_1 = require_AMMVote();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var checkCancel_1 = require_checkCancel();
    var checkCash_1 = require_checkCash();
    var checkCreate_1 = require_checkCreate();
    var clawback_1 = require_clawback();
    var common_1 = require_common2();
    var CredentialAccept_1 = require_CredentialAccept();
    var CredentialCreate_1 = require_CredentialCreate();
    var CredentialDelete_1 = require_CredentialDelete();
    var depositPreauth_1 = require_depositPreauth();
    var DIDDelete_1 = require_DIDDelete();
    var DIDSet_1 = require_DIDSet();
    var escrowCancel_1 = require_escrowCancel();
    var escrowCreate_1 = require_escrowCreate();
    var escrowFinish_1 = require_escrowFinish();
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    var MPTokenIssuanceDestroy_1 = require_MPTokenIssuanceDestroy();
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    var NFTokenAcceptOffer_1 = require_NFTokenAcceptOffer();
    var NFTokenBurn_1 = require_NFTokenBurn();
    var NFTokenCancelOffer_1 = require_NFTokenCancelOffer();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var NFTokenModify_1 = require_NFTokenModify();
    var offerCancel_1 = require_offerCancel();
    var offerCreate_1 = require_offerCreate();
    var oracleDelete_1 = require_oracleDelete();
    var oracleSet_1 = require_oracleSet();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var paymentChannelCreate_1 = require_paymentChannelCreate();
    var paymentChannelFund_1 = require_paymentChannelFund();
    var permissionedDomainDelete_1 = require_permissionedDomainDelete();
    var permissionedDomainSet_1 = require_permissionedDomainSet();
    var setRegularKey_1 = require_setRegularKey();
    var signerListSet_1 = require_signerListSet();
    var ticketCreate_1 = require_ticketCreate();
    var trustSet_1 = require_trustSet();
    var XChainAccountCreateCommit_1 = require_XChainAccountCreateCommit();
    var XChainAddAccountCreateAttestation_1 = require_XChainAddAccountCreateAttestation();
    var XChainAddClaimAttestation_1 = require_XChainAddClaimAttestation();
    var XChainClaim_1 = require_XChainClaim();
    var XChainCommit_1 = require_XChainCommit();
    var XChainCreateBridge_1 = require_XChainCreateBridge();
    var XChainCreateClaimID_1 = require_XChainCreateClaimID();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    function validate(transaction) {
      const tx = Object.assign({}, transaction);
      if (tx.TransactionType == null) {
        throw new errors_1.ValidationError("Object does not have a `TransactionType`");
      }
      if (typeof tx.TransactionType !== "string") {
        throw new errors_1.ValidationError("Object's `TransactionType` is not a string");
      }
      if (tx.Memos != null && typeof tx.Memos !== "object") {
        throw new errors_1.ValidationError("Memo must be array");
      }
      if (tx.Memos != null) {
        ;
        tx.Memos.forEach((memo) => {
          if ((memo === null || memo === void 0 ? void 0 : memo.Memo) == null) {
            throw new errors_1.ValidationError("Memo data must be in a `Memo` field");
          }
          if (memo.Memo.MemoData) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoData)) {
              throw new errors_1.ValidationError("MemoData field must be a hex value");
            }
          }
          if (memo.Memo.MemoType) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoType)) {
              throw new errors_1.ValidationError("MemoType field must be a hex value");
            }
          }
          if (memo.Memo.MemoFormat) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoFormat)) {
              throw new errors_1.ValidationError("MemoFormat field must be a hex value");
            }
          }
        });
      }
      Object.keys(tx).forEach((key) => {
        const standard_currency_code_len = 3;
        if (tx[key] && (0, common_1.isIssuedCurrency)(tx[key])) {
          const txCurrency = tx[key].currency;
          if (txCurrency.length === standard_currency_code_len && txCurrency.toUpperCase() === "XRP") {
            throw new errors_1.ValidationError(`Cannot have an issued currency with a similar standard code to XRP (received '${txCurrency}'). XRP is not an issued currency.`);
          }
        }
      });
      tx.Flags = (0, flags_1.convertTxFlagsToNumber)(tx);
      switch (tx.TransactionType) {
        case "AMMBid":
          (0, AMMBid_1.validateAMMBid)(tx);
          break;
        case "AMMClawback":
          (0, AMMClawback_1.validateAMMClawback)(tx);
          break;
        case "AMMCreate":
          (0, AMMCreate_1.validateAMMCreate)(tx);
          break;
        case "AMMDelete":
          (0, AMMDelete_1.validateAMMDelete)(tx);
          break;
        case "AMMDeposit":
          (0, AMMDeposit_1.validateAMMDeposit)(tx);
          break;
        case "AMMVote":
          (0, AMMVote_1.validateAMMVote)(tx);
          break;
        case "AMMWithdraw":
          (0, AMMWithdraw_1.validateAMMWithdraw)(tx);
          break;
        case "AccountDelete":
          (0, accountDelete_1.validateAccountDelete)(tx);
          break;
        case "AccountSet":
          (0, accountSet_1.validateAccountSet)(tx);
          break;
        case "CheckCancel":
          (0, checkCancel_1.validateCheckCancel)(tx);
          break;
        case "CheckCash":
          (0, checkCash_1.validateCheckCash)(tx);
          break;
        case "CheckCreate":
          (0, checkCreate_1.validateCheckCreate)(tx);
          break;
        case "Clawback":
          (0, clawback_1.validateClawback)(tx);
          break;
        case "CredentialAccept":
          (0, CredentialAccept_1.validateCredentialAccept)(tx);
          break;
        case "CredentialCreate":
          (0, CredentialCreate_1.validateCredentialCreate)(tx);
          break;
        case "CredentialDelete":
          (0, CredentialDelete_1.validateCredentialDelete)(tx);
          break;
        case "DIDDelete":
          (0, DIDDelete_1.validateDIDDelete)(tx);
          break;
        case "DIDSet":
          (0, DIDSet_1.validateDIDSet)(tx);
          break;
        case "DepositPreauth":
          (0, depositPreauth_1.validateDepositPreauth)(tx);
          break;
        case "EscrowCancel":
          (0, escrowCancel_1.validateEscrowCancel)(tx);
          break;
        case "EscrowCreate":
          (0, escrowCreate_1.validateEscrowCreate)(tx);
          break;
        case "EscrowFinish":
          (0, escrowFinish_1.validateEscrowFinish)(tx);
          break;
        case "MPTokenAuthorize":
          (0, MPTokenAuthorize_1.validateMPTokenAuthorize)(tx);
          break;
        case "MPTokenIssuanceCreate":
          (0, MPTokenIssuanceCreate_1.validateMPTokenIssuanceCreate)(tx);
          break;
        case "MPTokenIssuanceDestroy":
          (0, MPTokenIssuanceDestroy_1.validateMPTokenIssuanceDestroy)(tx);
          break;
        case "MPTokenIssuanceSet":
          (0, MPTokenIssuanceSet_1.validateMPTokenIssuanceSet)(tx);
          break;
        case "NFTokenAcceptOffer":
          (0, NFTokenAcceptOffer_1.validateNFTokenAcceptOffer)(tx);
          break;
        case "NFTokenBurn":
          (0, NFTokenBurn_1.validateNFTokenBurn)(tx);
          break;
        case "NFTokenCancelOffer":
          (0, NFTokenCancelOffer_1.validateNFTokenCancelOffer)(tx);
          break;
        case "NFTokenCreateOffer":
          (0, NFTokenCreateOffer_1.validateNFTokenCreateOffer)(tx);
          break;
        case "NFTokenMint":
          (0, NFTokenMint_1.validateNFTokenMint)(tx);
          break;
        case "NFTokenModify":
          (0, NFTokenModify_1.validateNFTokenModify)(tx);
          break;
        case "OfferCancel":
          (0, offerCancel_1.validateOfferCancel)(tx);
          break;
        case "OfferCreate":
          (0, offerCreate_1.validateOfferCreate)(tx);
          break;
        case "OracleDelete":
          (0, oracleDelete_1.validateOracleDelete)(tx);
          break;
        case "OracleSet":
          (0, oracleSet_1.validateOracleSet)(tx);
          break;
        case "Payment":
          (0, payment_1.validatePayment)(tx);
          break;
        case "PaymentChannelClaim":
          (0, paymentChannelClaim_1.validatePaymentChannelClaim)(tx);
          break;
        case "PaymentChannelCreate":
          (0, paymentChannelCreate_1.validatePaymentChannelCreate)(tx);
          break;
        case "PaymentChannelFund":
          (0, paymentChannelFund_1.validatePaymentChannelFund)(tx);
          break;
        case "PermissionedDomainSet":
          (0, permissionedDomainSet_1.validatePermissionedDomainSet)(tx);
          break;
        case "PermissionedDomainDelete":
          (0, permissionedDomainDelete_1.validatePermissionedDomainDelete)(tx);
          break;
        case "SetRegularKey":
          (0, setRegularKey_1.validateSetRegularKey)(tx);
          break;
        case "SignerListSet":
          (0, signerListSet_1.validateSignerListSet)(tx);
          break;
        case "TicketCreate":
          (0, ticketCreate_1.validateTicketCreate)(tx);
          break;
        case "TrustSet":
          (0, trustSet_1.validateTrustSet)(tx);
          break;
        case "XChainAccountCreateCommit":
          (0, XChainAccountCreateCommit_1.validateXChainAccountCreateCommit)(tx);
          break;
        case "XChainAddAccountCreateAttestation":
          (0, XChainAddAccountCreateAttestation_1.validateXChainAddAccountCreateAttestation)(tx);
          break;
        case "XChainAddClaimAttestation":
          (0, XChainAddClaimAttestation_1.validateXChainAddClaimAttestation)(tx);
          break;
        case "XChainClaim":
          (0, XChainClaim_1.validateXChainClaim)(tx);
          break;
        case "XChainCommit":
          (0, XChainCommit_1.validateXChainCommit)(tx);
          break;
        case "XChainCreateBridge":
          (0, XChainCreateBridge_1.validateXChainCreateBridge)(tx);
          break;
        case "XChainCreateClaimID":
          (0, XChainCreateClaimID_1.validateXChainCreateClaimID)(tx);
          break;
        case "XChainModifyBridge":
          (0, XChainModifyBridge_1.validateXChainModifyBridge)(tx);
          break;
        default:
          throw new errors_1.ValidationError(`Invalid field TransactionType: ${tx.TransactionType}`);
      }
    }
    exports.validate = validate;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js
var require_enableAmendment = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnableAmendmentFlags = void 0;
    var EnableAmendmentFlags;
    (function(EnableAmendmentFlags2) {
      EnableAmendmentFlags2[EnableAmendmentFlags2["tfGotMajority"] = 65536] = "tfGotMajority";
      EnableAmendmentFlags2[EnableAmendmentFlags2["tfLostMajority"] = 131072] = "tfLostMajority";
    })(EnableAmendmentFlags || (exports.EnableAmendmentFlags = EnableAmendmentFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/transactions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XChainModifyBridgeFlags = exports.TrustSetFlags = exports.PaymentChannelClaimFlags = exports.PaymentFlags = exports.OfferCreateFlags = exports.validateNFTokenModify = exports.NFTokenMintFlags = exports.NFTokenCreateOfferFlags = exports.MPTokenIssuanceSetFlags = exports.MPTokenIssuanceCreateFlags = exports.MPTokenAuthorizeFlags = exports.EnableAmendmentFlags = exports.AMMWithdrawFlags = exports.AMMDepositFlags = exports.AMMClawbackFlags = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = exports.validate = exports.isMPTAmount = void 0;
    var common_1 = require_common2();
    Object.defineProperty(exports, "isMPTAmount", { enumerable: true, get: function() {
      return common_1.isMPTAmount;
    } });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return transaction_1.validate;
    } });
    __exportStar(require_metadata(), exports);
    var accountSet_1 = require_accountSet();
    Object.defineProperty(exports, "AccountSetAsfFlags", { enumerable: true, get: function() {
      return accountSet_1.AccountSetAsfFlags;
    } });
    Object.defineProperty(exports, "AccountSetTfFlags", { enumerable: true, get: function() {
      return accountSet_1.AccountSetTfFlags;
    } });
    var AMMClawback_1 = require_AMMClawback();
    Object.defineProperty(exports, "AMMClawbackFlags", { enumerable: true, get: function() {
      return AMMClawback_1.AMMClawbackFlags;
    } });
    var AMMDeposit_1 = require_AMMDeposit();
    Object.defineProperty(exports, "AMMDepositFlags", { enumerable: true, get: function() {
      return AMMDeposit_1.AMMDepositFlags;
    } });
    var AMMWithdraw_1 = require_AMMWithdraw();
    Object.defineProperty(exports, "AMMWithdrawFlags", { enumerable: true, get: function() {
      return AMMWithdraw_1.AMMWithdrawFlags;
    } });
    var enableAmendment_1 = require_enableAmendment();
    Object.defineProperty(exports, "EnableAmendmentFlags", { enumerable: true, get: function() {
      return enableAmendment_1.EnableAmendmentFlags;
    } });
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    Object.defineProperty(exports, "MPTokenAuthorizeFlags", { enumerable: true, get: function() {
      return MPTokenAuthorize_1.MPTokenAuthorizeFlags;
    } });
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    Object.defineProperty(exports, "MPTokenIssuanceCreateFlags", { enumerable: true, get: function() {
      return MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags;
    } });
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    Object.defineProperty(exports, "MPTokenIssuanceSetFlags", { enumerable: true, get: function() {
      return MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags;
    } });
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    Object.defineProperty(exports, "NFTokenCreateOfferFlags", { enumerable: true, get: function() {
      return NFTokenCreateOffer_1.NFTokenCreateOfferFlags;
    } });
    var NFTokenMint_1 = require_NFTokenMint();
    Object.defineProperty(exports, "NFTokenMintFlags", { enumerable: true, get: function() {
      return NFTokenMint_1.NFTokenMintFlags;
    } });
    var NFTokenModify_1 = require_NFTokenModify();
    Object.defineProperty(exports, "validateNFTokenModify", { enumerable: true, get: function() {
      return NFTokenModify_1.validateNFTokenModify;
    } });
    var offerCreate_1 = require_offerCreate();
    Object.defineProperty(exports, "OfferCreateFlags", { enumerable: true, get: function() {
      return offerCreate_1.OfferCreateFlags;
    } });
    var payment_1 = require_payment();
    Object.defineProperty(exports, "PaymentFlags", { enumerable: true, get: function() {
      return payment_1.PaymentFlags;
    } });
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    Object.defineProperty(exports, "PaymentChannelClaimFlags", { enumerable: true, get: function() {
      return paymentChannelClaim_1.PaymentChannelClaimFlags;
    } });
    var trustSet_1 = require_trustSet();
    Object.defineProperty(exports, "TrustSetFlags", { enumerable: true, get: function() {
      return trustSet_1.TrustSetFlags;
    } });
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    Object.defineProperty(exports, "XChainModifyBridgeFlags", { enumerable: true, get: function() {
      return XChainModifyBridge_1.XChainModifyBridgeFlags;
    } });
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json
var require_rfc1751Words = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json"(exports, module) {
    module.exports = [
      "A",
      "ABE",
      "ACE",
      "ACT",
      "AD",
      "ADA",
      "ADD",
      "AGO",
      "AID",
      "AIM",
      "AIR",
      "ALL",
      "ALP",
      "AM",
      "AMY",
      "AN",
      "ANA",
      "AND",
      "ANN",
      "ANT",
      "ANY",
      "APE",
      "APS",
      "APT",
      "ARC",
      "ARE",
      "ARK",
      "ARM",
      "ART",
      "AS",
      "ASH",
      "ASK",
      "AT",
      "ATE",
      "AUG",
      "AUK",
      "AVE",
      "AWE",
      "AWK",
      "AWL",
      "AWN",
      "AX",
      "AYE",
      "BAD",
      "BAG",
      "BAH",
      "BAM",
      "BAN",
      "BAR",
      "BAT",
      "BAY",
      "BE",
      "BED",
      "BEE",
      "BEG",
      "BEN",
      "BET",
      "BEY",
      "BIB",
      "BID",
      "BIG",
      "BIN",
      "BIT",
      "BOB",
      "BOG",
      "BON",
      "BOO",
      "BOP",
      "BOW",
      "BOY",
      "BUB",
      "BUD",
      "BUG",
      "BUM",
      "BUN",
      "BUS",
      "BUT",
      "BUY",
      "BY",
      "BYE",
      "CAB",
      "CAL",
      "CAM",
      "CAN",
      "CAP",
      "CAR",
      "CAT",
      "CAW",
      "COD",
      "COG",
      "COL",
      "CON",
      "COO",
      "COP",
      "COT",
      "COW",
      "COY",
      "CRY",
      "CUB",
      "CUE",
      "CUP",
      "CUR",
      "CUT",
      "DAB",
      "DAD",
      "DAM",
      "DAN",
      "DAR",
      "DAY",
      "DEE",
      "DEL",
      "DEN",
      "DES",
      "DEW",
      "DID",
      "DIE",
      "DIG",
      "DIN",
      "DIP",
      "DO",
      "DOE",
      "DOG",
      "DON",
      "DOT",
      "DOW",
      "DRY",
      "DUB",
      "DUD",
      "DUE",
      "DUG",
      "DUN",
      "EAR",
      "EAT",
      "ED",
      "EEL",
      "EGG",
      "EGO",
      "ELI",
      "ELK",
      "ELM",
      "ELY",
      "EM",
      "END",
      "EST",
      "ETC",
      "EVA",
      "EVE",
      "EWE",
      "EYE",
      "FAD",
      "FAN",
      "FAR",
      "FAT",
      "FAY",
      "FED",
      "FEE",
      "FEW",
      "FIB",
      "FIG",
      "FIN",
      "FIR",
      "FIT",
      "FLO",
      "FLY",
      "FOE",
      "FOG",
      "FOR",
      "FRY",
      "FUM",
      "FUN",
      "FUR",
      "GAB",
      "GAD",
      "GAG",
      "GAL",
      "GAM",
      "GAP",
      "GAS",
      "GAY",
      "GEE",
      "GEL",
      "GEM",
      "GET",
      "GIG",
      "GIL",
      "GIN",
      "GO",
      "GOT",
      "GUM",
      "GUN",
      "GUS",
      "GUT",
      "GUY",
      "GYM",
      "GYP",
      "HA",
      "HAD",
      "HAL",
      "HAM",
      "HAN",
      "HAP",
      "HAS",
      "HAT",
      "HAW",
      "HAY",
      "HE",
      "HEM",
      "HEN",
      "HER",
      "HEW",
      "HEY",
      "HI",
      "HID",
      "HIM",
      "HIP",
      "HIS",
      "HIT",
      "HO",
      "HOB",
      "HOC",
      "HOE",
      "HOG",
      "HOP",
      "HOT",
      "HOW",
      "HUB",
      "HUE",
      "HUG",
      "HUH",
      "HUM",
      "HUT",
      "I",
      "ICY",
      "IDA",
      "IF",
      "IKE",
      "ILL",
      "INK",
      "INN",
      "IO",
      "ION",
      "IQ",
      "IRA",
      "IRE",
      "IRK",
      "IS",
      "IT",
      "ITS",
      "IVY",
      "JAB",
      "JAG",
      "JAM",
      "JAN",
      "JAR",
      "JAW",
      "JAY",
      "JET",
      "JIG",
      "JIM",
      "JO",
      "JOB",
      "JOE",
      "JOG",
      "JOT",
      "JOY",
      "JUG",
      "JUT",
      "KAY",
      "KEG",
      "KEN",
      "KEY",
      "KID",
      "KIM",
      "KIN",
      "KIT",
      "LA",
      "LAB",
      "LAC",
      "LAD",
      "LAG",
      "LAM",
      "LAP",
      "LAW",
      "LAY",
      "LEA",
      "LED",
      "LEE",
      "LEG",
      "LEN",
      "LEO",
      "LET",
      "LEW",
      "LID",
      "LIE",
      "LIN",
      "LIP",
      "LIT",
      "LO",
      "LOB",
      "LOG",
      "LOP",
      "LOS",
      "LOT",
      "LOU",
      "LOW",
      "LOY",
      "LUG",
      "LYE",
      "MA",
      "MAC",
      "MAD",
      "MAE",
      "MAN",
      "MAO",
      "MAP",
      "MAT",
      "MAW",
      "MAY",
      "ME",
      "MEG",
      "MEL",
      "MEN",
      "MET",
      "MEW",
      "MID",
      "MIN",
      "MIT",
      "MOB",
      "MOD",
      "MOE",
      "MOO",
      "MOP",
      "MOS",
      "MOT",
      "MOW",
      "MUD",
      "MUG",
      "MUM",
      "MY",
      "NAB",
      "NAG",
      "NAN",
      "NAP",
      "NAT",
      "NAY",
      "NE",
      "NED",
      "NEE",
      "NET",
      "NEW",
      "NIB",
      "NIL",
      "NIP",
      "NIT",
      "NO",
      "NOB",
      "NOD",
      "NON",
      "NOR",
      "NOT",
      "NOV",
      "NOW",
      "NU",
      "NUN",
      "NUT",
      "O",
      "OAF",
      "OAK",
      "OAR",
      "OAT",
      "ODD",
      "ODE",
      "OF",
      "OFF",
      "OFT",
      "OH",
      "OIL",
      "OK",
      "OLD",
      "ON",
      "ONE",
      "OR",
      "ORB",
      "ORE",
      "ORR",
      "OS",
      "OTT",
      "OUR",
      "OUT",
      "OVA",
      "OW",
      "OWE",
      "OWL",
      "OWN",
      "OX",
      "PA",
      "PAD",
      "PAL",
      "PAM",
      "PAN",
      "PAP",
      "PAR",
      "PAT",
      "PAW",
      "PAY",
      "PEA",
      "PEG",
      "PEN",
      "PEP",
      "PER",
      "PET",
      "PEW",
      "PHI",
      "PI",
      "PIE",
      "PIN",
      "PIT",
      "PLY",
      "PO",
      "POD",
      "POE",
      "POP",
      "POT",
      "POW",
      "PRO",
      "PRY",
      "PUB",
      "PUG",
      "PUN",
      "PUP",
      "PUT",
      "QUO",
      "RAG",
      "RAM",
      "RAN",
      "RAP",
      "RAT",
      "RAW",
      "RAY",
      "REB",
      "RED",
      "REP",
      "RET",
      "RIB",
      "RID",
      "RIG",
      "RIM",
      "RIO",
      "RIP",
      "ROB",
      "ROD",
      "ROE",
      "RON",
      "ROT",
      "ROW",
      "ROY",
      "RUB",
      "RUE",
      "RUG",
      "RUM",
      "RUN",
      "RYE",
      "SAC",
      "SAD",
      "SAG",
      "SAL",
      "SAM",
      "SAN",
      "SAP",
      "SAT",
      "SAW",
      "SAY",
      "SEA",
      "SEC",
      "SEE",
      "SEN",
      "SET",
      "SEW",
      "SHE",
      "SHY",
      "SIN",
      "SIP",
      "SIR",
      "SIS",
      "SIT",
      "SKI",
      "SKY",
      "SLY",
      "SO",
      "SOB",
      "SOD",
      "SON",
      "SOP",
      "SOW",
      "SOY",
      "SPA",
      "SPY",
      "SUB",
      "SUD",
      "SUE",
      "SUM",
      "SUN",
      "SUP",
      "TAB",
      "TAD",
      "TAG",
      "TAN",
      "TAP",
      "TAR",
      "TEA",
      "TED",
      "TEE",
      "TEN",
      "THE",
      "THY",
      "TIC",
      "TIE",
      "TIM",
      "TIN",
      "TIP",
      "TO",
      "TOE",
      "TOG",
      "TOM",
      "TON",
      "TOO",
      "TOP",
      "TOW",
      "TOY",
      "TRY",
      "TUB",
      "TUG",
      "TUM",
      "TUN",
      "TWO",
      "UN",
      "UP",
      "US",
      "USE",
      "VAN",
      "VAT",
      "VET",
      "VIE",
      "WAD",
      "WAG",
      "WAR",
      "WAS",
      "WAY",
      "WE",
      "WEB",
      "WED",
      "WEE",
      "WET",
      "WHO",
      "WHY",
      "WIN",
      "WIT",
      "WOK",
      "WON",
      "WOO",
      "WOW",
      "WRY",
      "WU",
      "YAM",
      "YAP",
      "YAW",
      "YE",
      "YEA",
      "YES",
      "YET",
      "YOU",
      "ABED",
      "ABEL",
      "ABET",
      "ABLE",
      "ABUT",
      "ACHE",
      "ACID",
      "ACME",
      "ACRE",
      "ACTA",
      "ACTS",
      "ADAM",
      "ADDS",
      "ADEN",
      "AFAR",
      "AFRO",
      "AGEE",
      "AHEM",
      "AHOY",
      "AIDA",
      "AIDE",
      "AIDS",
      "AIRY",
      "AJAR",
      "AKIN",
      "ALAN",
      "ALEC",
      "ALGA",
      "ALIA",
      "ALLY",
      "ALMA",
      "ALOE",
      "ALSO",
      "ALTO",
      "ALUM",
      "ALVA",
      "AMEN",
      "AMES",
      "AMID",
      "AMMO",
      "AMOK",
      "AMOS",
      "AMRA",
      "ANDY",
      "ANEW",
      "ANNA",
      "ANNE",
      "ANTE",
      "ANTI",
      "AQUA",
      "ARAB",
      "ARCH",
      "AREA",
      "ARGO",
      "ARID",
      "ARMY",
      "ARTS",
      "ARTY",
      "ASIA",
      "ASKS",
      "ATOM",
      "AUNT",
      "AURA",
      "AUTO",
      "AVER",
      "AVID",
      "AVIS",
      "AVON",
      "AVOW",
      "AWAY",
      "AWRY",
      "BABE",
      "BABY",
      "BACH",
      "BACK",
      "BADE",
      "BAIL",
      "BAIT",
      "BAKE",
      "BALD",
      "BALE",
      "BALI",
      "BALK",
      "BALL",
      "BALM",
      "BAND",
      "BANE",
      "BANG",
      "BANK",
      "BARB",
      "BARD",
      "BARE",
      "BARK",
      "BARN",
      "BARR",
      "BASE",
      "BASH",
      "BASK",
      "BASS",
      "BATE",
      "BATH",
      "BAWD",
      "BAWL",
      "BEAD",
      "BEAK",
      "BEAM",
      "BEAN",
      "BEAR",
      "BEAT",
      "BEAU",
      "BECK",
      "BEEF",
      "BEEN",
      "BEER",
      "BEET",
      "BELA",
      "BELL",
      "BELT",
      "BEND",
      "BENT",
      "BERG",
      "BERN",
      "BERT",
      "BESS",
      "BEST",
      "BETA",
      "BETH",
      "BHOY",
      "BIAS",
      "BIDE",
      "BIEN",
      "BILE",
      "BILK",
      "BILL",
      "BIND",
      "BING",
      "BIRD",
      "BITE",
      "BITS",
      "BLAB",
      "BLAT",
      "BLED",
      "BLEW",
      "BLOB",
      "BLOC",
      "BLOT",
      "BLOW",
      "BLUE",
      "BLUM",
      "BLUR",
      "BOAR",
      "BOAT",
      "BOCA",
      "BOCK",
      "BODE",
      "BODY",
      "BOGY",
      "BOHR",
      "BOIL",
      "BOLD",
      "BOLO",
      "BOLT",
      "BOMB",
      "BONA",
      "BOND",
      "BONE",
      "BONG",
      "BONN",
      "BONY",
      "BOOK",
      "BOOM",
      "BOON",
      "BOOT",
      "BORE",
      "BORG",
      "BORN",
      "BOSE",
      "BOSS",
      "BOTH",
      "BOUT",
      "BOWL",
      "BOYD",
      "BRAD",
      "BRAE",
      "BRAG",
      "BRAN",
      "BRAY",
      "BRED",
      "BREW",
      "BRIG",
      "BRIM",
      "BROW",
      "BUCK",
      "BUDD",
      "BUFF",
      "BULB",
      "BULK",
      "BULL",
      "BUNK",
      "BUNT",
      "BUOY",
      "BURG",
      "BURL",
      "BURN",
      "BURR",
      "BURT",
      "BURY",
      "BUSH",
      "BUSS",
      "BUST",
      "BUSY",
      "BYTE",
      "CADY",
      "CAFE",
      "CAGE",
      "CAIN",
      "CAKE",
      "CALF",
      "CALL",
      "CALM",
      "CAME",
      "CANE",
      "CANT",
      "CARD",
      "CARE",
      "CARL",
      "CARR",
      "CART",
      "CASE",
      "CASH",
      "CASK",
      "CAST",
      "CAVE",
      "CEIL",
      "CELL",
      "CENT",
      "CERN",
      "CHAD",
      "CHAR",
      "CHAT",
      "CHAW",
      "CHEF",
      "CHEN",
      "CHEW",
      "CHIC",
      "CHIN",
      "CHOU",
      "CHOW",
      "CHUB",
      "CHUG",
      "CHUM",
      "CITE",
      "CITY",
      "CLAD",
      "CLAM",
      "CLAN",
      "CLAW",
      "CLAY",
      "CLOD",
      "CLOG",
      "CLOT",
      "CLUB",
      "CLUE",
      "COAL",
      "COAT",
      "COCA",
      "COCK",
      "COCO",
      "CODA",
      "CODE",
      "CODY",
      "COED",
      "COIL",
      "COIN",
      "COKE",
      "COLA",
      "COLD",
      "COLT",
      "COMA",
      "COMB",
      "COME",
      "COOK",
      "COOL",
      "COON",
      "COOT",
      "CORD",
      "CORE",
      "CORK",
      "CORN",
      "COST",
      "COVE",
      "COWL",
      "CRAB",
      "CRAG",
      "CRAM",
      "CRAY",
      "CREW",
      "CRIB",
      "CROW",
      "CRUD",
      "CUBA",
      "CUBE",
      "CUFF",
      "CULL",
      "CULT",
      "CUNY",
      "CURB",
      "CURD",
      "CURE",
      "CURL",
      "CURT",
      "CUTS",
      "DADE",
      "DALE",
      "DAME",
      "DANA",
      "DANE",
      "DANG",
      "DANK",
      "DARE",
      "DARK",
      "DARN",
      "DART",
      "DASH",
      "DATA",
      "DATE",
      "DAVE",
      "DAVY",
      "DAWN",
      "DAYS",
      "DEAD",
      "DEAF",
      "DEAL",
      "DEAN",
      "DEAR",
      "DEBT",
      "DECK",
      "DEED",
      "DEEM",
      "DEER",
      "DEFT",
      "DEFY",
      "DELL",
      "DENT",
      "DENY",
      "DESK",
      "DIAL",
      "DICE",
      "DIED",
      "DIET",
      "DIME",
      "DINE",
      "DING",
      "DINT",
      "DIRE",
      "DIRT",
      "DISC",
      "DISH",
      "DISK",
      "DIVE",
      "DOCK",
      "DOES",
      "DOLE",
      "DOLL",
      "DOLT",
      "DOME",
      "DONE",
      "DOOM",
      "DOOR",
      "DORA",
      "DOSE",
      "DOTE",
      "DOUG",
      "DOUR",
      "DOVE",
      "DOWN",
      "DRAB",
      "DRAG",
      "DRAM",
      "DRAW",
      "DREW",
      "DRUB",
      "DRUG",
      "DRUM",
      "DUAL",
      "DUCK",
      "DUCT",
      "DUEL",
      "DUET",
      "DUKE",
      "DULL",
      "DUMB",
      "DUNE",
      "DUNK",
      "DUSK",
      "DUST",
      "DUTY",
      "EACH",
      "EARL",
      "EARN",
      "EASE",
      "EAST",
      "EASY",
      "EBEN",
      "ECHO",
      "EDDY",
      "EDEN",
      "EDGE",
      "EDGY",
      "EDIT",
      "EDNA",
      "EGAN",
      "ELAN",
      "ELBA",
      "ELLA",
      "ELSE",
      "EMIL",
      "EMIT",
      "EMMA",
      "ENDS",
      "ERIC",
      "EROS",
      "EVEN",
      "EVER",
      "EVIL",
      "EYED",
      "FACE",
      "FACT",
      "FADE",
      "FAIL",
      "FAIN",
      "FAIR",
      "FAKE",
      "FALL",
      "FAME",
      "FANG",
      "FARM",
      "FAST",
      "FATE",
      "FAWN",
      "FEAR",
      "FEAT",
      "FEED",
      "FEEL",
      "FEET",
      "FELL",
      "FELT",
      "FEND",
      "FERN",
      "FEST",
      "FEUD",
      "FIEF",
      "FIGS",
      "FILE",
      "FILL",
      "FILM",
      "FIND",
      "FINE",
      "FINK",
      "FIRE",
      "FIRM",
      "FISH",
      "FISK",
      "FIST",
      "FITS",
      "FIVE",
      "FLAG",
      "FLAK",
      "FLAM",
      "FLAT",
      "FLAW",
      "FLEA",
      "FLED",
      "FLEW",
      "FLIT",
      "FLOC",
      "FLOG",
      "FLOW",
      "FLUB",
      "FLUE",
      "FOAL",
      "FOAM",
      "FOGY",
      "FOIL",
      "FOLD",
      "FOLK",
      "FOND",
      "FONT",
      "FOOD",
      "FOOL",
      "FOOT",
      "FORD",
      "FORE",
      "FORK",
      "FORM",
      "FORT",
      "FOSS",
      "FOUL",
      "FOUR",
      "FOWL",
      "FRAU",
      "FRAY",
      "FRED",
      "FREE",
      "FRET",
      "FREY",
      "FROG",
      "FROM",
      "FUEL",
      "FULL",
      "FUME",
      "FUND",
      "FUNK",
      "FURY",
      "FUSE",
      "FUSS",
      "GAFF",
      "GAGE",
      "GAIL",
      "GAIN",
      "GAIT",
      "GALA",
      "GALE",
      "GALL",
      "GALT",
      "GAME",
      "GANG",
      "GARB",
      "GARY",
      "GASH",
      "GATE",
      "GAUL",
      "GAUR",
      "GAVE",
      "GAWK",
      "GEAR",
      "GELD",
      "GENE",
      "GENT",
      "GERM",
      "GETS",
      "GIBE",
      "GIFT",
      "GILD",
      "GILL",
      "GILT",
      "GINA",
      "GIRD",
      "GIRL",
      "GIST",
      "GIVE",
      "GLAD",
      "GLEE",
      "GLEN",
      "GLIB",
      "GLOB",
      "GLOM",
      "GLOW",
      "GLUE",
      "GLUM",
      "GLUT",
      "GOAD",
      "GOAL",
      "GOAT",
      "GOER",
      "GOES",
      "GOLD",
      "GOLF",
      "GONE",
      "GONG",
      "GOOD",
      "GOOF",
      "GORE",
      "GORY",
      "GOSH",
      "GOUT",
      "GOWN",
      "GRAB",
      "GRAD",
      "GRAY",
      "GREG",
      "GREW",
      "GREY",
      "GRID",
      "GRIM",
      "GRIN",
      "GRIT",
      "GROW",
      "GRUB",
      "GULF",
      "GULL",
      "GUNK",
      "GURU",
      "GUSH",
      "GUST",
      "GWEN",
      "GWYN",
      "HAAG",
      "HAAS",
      "HACK",
      "HAIL",
      "HAIR",
      "HALE",
      "HALF",
      "HALL",
      "HALO",
      "HALT",
      "HAND",
      "HANG",
      "HANK",
      "HANS",
      "HARD",
      "HARK",
      "HARM",
      "HART",
      "HASH",
      "HAST",
      "HATE",
      "HATH",
      "HAUL",
      "HAVE",
      "HAWK",
      "HAYS",
      "HEAD",
      "HEAL",
      "HEAR",
      "HEAT",
      "HEBE",
      "HECK",
      "HEED",
      "HEEL",
      "HEFT",
      "HELD",
      "HELL",
      "HELM",
      "HERB",
      "HERD",
      "HERE",
      "HERO",
      "HERS",
      "HESS",
      "HEWN",
      "HICK",
      "HIDE",
      "HIGH",
      "HIKE",
      "HILL",
      "HILT",
      "HIND",
      "HINT",
      "HIRE",
      "HISS",
      "HIVE",
      "HOBO",
      "HOCK",
      "HOFF",
      "HOLD",
      "HOLE",
      "HOLM",
      "HOLT",
      "HOME",
      "HONE",
      "HONK",
      "HOOD",
      "HOOF",
      "HOOK",
      "HOOT",
      "HORN",
      "HOSE",
      "HOST",
      "HOUR",
      "HOVE",
      "HOWE",
      "HOWL",
      "HOYT",
      "HUCK",
      "HUED",
      "HUFF",
      "HUGE",
      "HUGH",
      "HUGO",
      "HULK",
      "HULL",
      "HUNK",
      "HUNT",
      "HURD",
      "HURL",
      "HURT",
      "HUSH",
      "HYDE",
      "HYMN",
      "IBIS",
      "ICON",
      "IDEA",
      "IDLE",
      "IFFY",
      "INCA",
      "INCH",
      "INTO",
      "IONS",
      "IOTA",
      "IOWA",
      "IRIS",
      "IRMA",
      "IRON",
      "ISLE",
      "ITCH",
      "ITEM",
      "IVAN",
      "JACK",
      "JADE",
      "JAIL",
      "JAKE",
      "JANE",
      "JAVA",
      "JEAN",
      "JEFF",
      "JERK",
      "JESS",
      "JEST",
      "JIBE",
      "JILL",
      "JILT",
      "JIVE",
      "JOAN",
      "JOBS",
      "JOCK",
      "JOEL",
      "JOEY",
      "JOHN",
      "JOIN",
      "JOKE",
      "JOLT",
      "JOVE",
      "JUDD",
      "JUDE",
      "JUDO",
      "JUDY",
      "JUJU",
      "JUKE",
      "JULY",
      "JUNE",
      "JUNK",
      "JUNO",
      "JURY",
      "JUST",
      "JUTE",
      "KAHN",
      "KALE",
      "KANE",
      "KANT",
      "KARL",
      "KATE",
      "KEEL",
      "KEEN",
      "KENO",
      "KENT",
      "KERN",
      "KERR",
      "KEYS",
      "KICK",
      "KILL",
      "KIND",
      "KING",
      "KIRK",
      "KISS",
      "KITE",
      "KLAN",
      "KNEE",
      "KNEW",
      "KNIT",
      "KNOB",
      "KNOT",
      "KNOW",
      "KOCH",
      "KONG",
      "KUDO",
      "KURD",
      "KURT",
      "KYLE",
      "LACE",
      "LACK",
      "LACY",
      "LADY",
      "LAID",
      "LAIN",
      "LAIR",
      "LAKE",
      "LAMB",
      "LAME",
      "LAND",
      "LANE",
      "LANG",
      "LARD",
      "LARK",
      "LASS",
      "LAST",
      "LATE",
      "LAUD",
      "LAVA",
      "LAWN",
      "LAWS",
      "LAYS",
      "LEAD",
      "LEAF",
      "LEAK",
      "LEAN",
      "LEAR",
      "LEEK",
      "LEER",
      "LEFT",
      "LEND",
      "LENS",
      "LENT",
      "LEON",
      "LESK",
      "LESS",
      "LEST",
      "LETS",
      "LIAR",
      "LICE",
      "LICK",
      "LIED",
      "LIEN",
      "LIES",
      "LIEU",
      "LIFE",
      "LIFT",
      "LIKE",
      "LILA",
      "LILT",
      "LILY",
      "LIMA",
      "LIMB",
      "LIME",
      "LIND",
      "LINE",
      "LINK",
      "LINT",
      "LION",
      "LISA",
      "LIST",
      "LIVE",
      "LOAD",
      "LOAF",
      "LOAM",
      "LOAN",
      "LOCK",
      "LOFT",
      "LOGE",
      "LOIS",
      "LOLA",
      "LONE",
      "LONG",
      "LOOK",
      "LOON",
      "LOOT",
      "LORD",
      "LORE",
      "LOSE",
      "LOSS",
      "LOST",
      "LOUD",
      "LOVE",
      "LOWE",
      "LUCK",
      "LUCY",
      "LUGE",
      "LUKE",
      "LULU",
      "LUND",
      "LUNG",
      "LURA",
      "LURE",
      "LURK",
      "LUSH",
      "LUST",
      "LYLE",
      "LYNN",
      "LYON",
      "LYRA",
      "MACE",
      "MADE",
      "MAGI",
      "MAID",
      "MAIL",
      "MAIN",
      "MAKE",
      "MALE",
      "MALI",
      "MALL",
      "MALT",
      "MANA",
      "MANN",
      "MANY",
      "MARC",
      "MARE",
      "MARK",
      "MARS",
      "MART",
      "MARY",
      "MASH",
      "MASK",
      "MASS",
      "MAST",
      "MATE",
      "MATH",
      "MAUL",
      "MAYO",
      "MEAD",
      "MEAL",
      "MEAN",
      "MEAT",
      "MEEK",
      "MEET",
      "MELD",
      "MELT",
      "MEMO",
      "MEND",
      "MENU",
      "MERT",
      "MESH",
      "MESS",
      "MICE",
      "MIKE",
      "MILD",
      "MILE",
      "MILK",
      "MILL",
      "MILT",
      "MIMI",
      "MIND",
      "MINE",
      "MINI",
      "MINK",
      "MINT",
      "MIRE",
      "MISS",
      "MIST",
      "MITE",
      "MITT",
      "MOAN",
      "MOAT",
      "MOCK",
      "MODE",
      "MOLD",
      "MOLE",
      "MOLL",
      "MOLT",
      "MONA",
      "MONK",
      "MONT",
      "MOOD",
      "MOON",
      "MOOR",
      "MOOT",
      "MORE",
      "MORN",
      "MORT",
      "MOSS",
      "MOST",
      "MOTH",
      "MOVE",
      "MUCH",
      "MUCK",
      "MUDD",
      "MUFF",
      "MULE",
      "MULL",
      "MURK",
      "MUSH",
      "MUST",
      "MUTE",
      "MUTT",
      "MYRA",
      "MYTH",
      "NAGY",
      "NAIL",
      "NAIR",
      "NAME",
      "NARY",
      "NASH",
      "NAVE",
      "NAVY",
      "NEAL",
      "NEAR",
      "NEAT",
      "NECK",
      "NEED",
      "NEIL",
      "NELL",
      "NEON",
      "NERO",
      "NESS",
      "NEST",
      "NEWS",
      "NEWT",
      "NIBS",
      "NICE",
      "NICK",
      "NILE",
      "NINA",
      "NINE",
      "NOAH",
      "NODE",
      "NOEL",
      "NOLL",
      "NONE",
      "NOOK",
      "NOON",
      "NORM",
      "NOSE",
      "NOTE",
      "NOUN",
      "NOVA",
      "NUDE",
      "NULL",
      "NUMB",
      "OATH",
      "OBEY",
      "OBOE",
      "ODIN",
      "OHIO",
      "OILY",
      "OINT",
      "OKAY",
      "OLAF",
      "OLDY",
      "OLGA",
      "OLIN",
      "OMAN",
      "OMEN",
      "OMIT",
      "ONCE",
      "ONES",
      "ONLY",
      "ONTO",
      "ONUS",
      "ORAL",
      "ORGY",
      "OSLO",
      "OTIS",
      "OTTO",
      "OUCH",
      "OUST",
      "OUTS",
      "OVAL",
      "OVEN",
      "OVER",
      "OWLY",
      "OWNS",
      "QUAD",
      "QUIT",
      "QUOD",
      "RACE",
      "RACK",
      "RACY",
      "RAFT",
      "RAGE",
      "RAID",
      "RAIL",
      "RAIN",
      "RAKE",
      "RANK",
      "RANT",
      "RARE",
      "RASH",
      "RATE",
      "RAVE",
      "RAYS",
      "READ",
      "REAL",
      "REAM",
      "REAR",
      "RECK",
      "REED",
      "REEF",
      "REEK",
      "REEL",
      "REID",
      "REIN",
      "RENA",
      "REND",
      "RENT",
      "REST",
      "RICE",
      "RICH",
      "RICK",
      "RIDE",
      "RIFT",
      "RILL",
      "RIME",
      "RING",
      "RINK",
      "RISE",
      "RISK",
      "RITE",
      "ROAD",
      "ROAM",
      "ROAR",
      "ROBE",
      "ROCK",
      "RODE",
      "ROIL",
      "ROLL",
      "ROME",
      "ROOD",
      "ROOF",
      "ROOK",
      "ROOM",
      "ROOT",
      "ROSA",
      "ROSE",
      "ROSS",
      "ROSY",
      "ROTH",
      "ROUT",
      "ROVE",
      "ROWE",
      "ROWS",
      "RUBE",
      "RUBY",
      "RUDE",
      "RUDY",
      "RUIN",
      "RULE",
      "RUNG",
      "RUNS",
      "RUNT",
      "RUSE",
      "RUSH",
      "RUSK",
      "RUSS",
      "RUST",
      "RUTH",
      "SACK",
      "SAFE",
      "SAGE",
      "SAID",
      "SAIL",
      "SALE",
      "SALK",
      "SALT",
      "SAME",
      "SAND",
      "SANE",
      "SANG",
      "SANK",
      "SARA",
      "SAUL",
      "SAVE",
      "SAYS",
      "SCAN",
      "SCAR",
      "SCAT",
      "SCOT",
      "SEAL",
      "SEAM",
      "SEAR",
      "SEAT",
      "SEED",
      "SEEK",
      "SEEM",
      "SEEN",
      "SEES",
      "SELF",
      "SELL",
      "SEND",
      "SENT",
      "SETS",
      "SEWN",
      "SHAG",
      "SHAM",
      "SHAW",
      "SHAY",
      "SHED",
      "SHIM",
      "SHIN",
      "SHOD",
      "SHOE",
      "SHOT",
      "SHOW",
      "SHUN",
      "SHUT",
      "SICK",
      "SIDE",
      "SIFT",
      "SIGH",
      "SIGN",
      "SILK",
      "SILL",
      "SILO",
      "SILT",
      "SINE",
      "SING",
      "SINK",
      "SIRE",
      "SITE",
      "SITS",
      "SITU",
      "SKAT",
      "SKEW",
      "SKID",
      "SKIM",
      "SKIN",
      "SKIT",
      "SLAB",
      "SLAM",
      "SLAT",
      "SLAY",
      "SLED",
      "SLEW",
      "SLID",
      "SLIM",
      "SLIT",
      "SLOB",
      "SLOG",
      "SLOT",
      "SLOW",
      "SLUG",
      "SLUM",
      "SLUR",
      "SMOG",
      "SMUG",
      "SNAG",
      "SNOB",
      "SNOW",
      "SNUB",
      "SNUG",
      "SOAK",
      "SOAR",
      "SOCK",
      "SODA",
      "SOFA",
      "SOFT",
      "SOIL",
      "SOLD",
      "SOME",
      "SONG",
      "SOON",
      "SOOT",
      "SORE",
      "SORT",
      "SOUL",
      "SOUR",
      "SOWN",
      "STAB",
      "STAG",
      "STAN",
      "STAR",
      "STAY",
      "STEM",
      "STEW",
      "STIR",
      "STOW",
      "STUB",
      "STUN",
      "SUCH",
      "SUDS",
      "SUIT",
      "SULK",
      "SUMS",
      "SUNG",
      "SUNK",
      "SURE",
      "SURF",
      "SWAB",
      "SWAG",
      "SWAM",
      "SWAN",
      "SWAT",
      "SWAY",
      "SWIM",
      "SWUM",
      "TACK",
      "TACT",
      "TAIL",
      "TAKE",
      "TALE",
      "TALK",
      "TALL",
      "TANK",
      "TASK",
      "TATE",
      "TAUT",
      "TEAL",
      "TEAM",
      "TEAR",
      "TECH",
      "TEEM",
      "TEEN",
      "TEET",
      "TELL",
      "TEND",
      "TENT",
      "TERM",
      "TERN",
      "TESS",
      "TEST",
      "THAN",
      "THAT",
      "THEE",
      "THEM",
      "THEN",
      "THEY",
      "THIN",
      "THIS",
      "THUD",
      "THUG",
      "TICK",
      "TIDE",
      "TIDY",
      "TIED",
      "TIER",
      "TILE",
      "TILL",
      "TILT",
      "TIME",
      "TINA",
      "TINE",
      "TINT",
      "TINY",
      "TIRE",
      "TOAD",
      "TOGO",
      "TOIL",
      "TOLD",
      "TOLL",
      "TONE",
      "TONG",
      "TONY",
      "TOOK",
      "TOOL",
      "TOOT",
      "TORE",
      "TORN",
      "TOTE",
      "TOUR",
      "TOUT",
      "TOWN",
      "TRAG",
      "TRAM",
      "TRAY",
      "TREE",
      "TREK",
      "TRIG",
      "TRIM",
      "TRIO",
      "TROD",
      "TROT",
      "TROY",
      "TRUE",
      "TUBA",
      "TUBE",
      "TUCK",
      "TUFT",
      "TUNA",
      "TUNE",
      "TUNG",
      "TURF",
      "TURN",
      "TUSK",
      "TWIG",
      "TWIN",
      "TWIT",
      "ULAN",
      "UNIT",
      "URGE",
      "USED",
      "USER",
      "USES",
      "UTAH",
      "VAIL",
      "VAIN",
      "VALE",
      "VARY",
      "VASE",
      "VAST",
      "VEAL",
      "VEDA",
      "VEIL",
      "VEIN",
      "VEND",
      "VENT",
      "VERB",
      "VERY",
      "VETO",
      "VICE",
      "VIEW",
      "VINE",
      "VISE",
      "VOID",
      "VOLT",
      "VOTE",
      "WACK",
      "WADE",
      "WAGE",
      "WAIL",
      "WAIT",
      "WAKE",
      "WALE",
      "WALK",
      "WALL",
      "WALT",
      "WAND",
      "WANE",
      "WANG",
      "WANT",
      "WARD",
      "WARM",
      "WARN",
      "WART",
      "WASH",
      "WAST",
      "WATS",
      "WATT",
      "WAVE",
      "WAVY",
      "WAYS",
      "WEAK",
      "WEAL",
      "WEAN",
      "WEAR",
      "WEED",
      "WEEK",
      "WEIR",
      "WELD",
      "WELL",
      "WELT",
      "WENT",
      "WERE",
      "WERT",
      "WEST",
      "WHAM",
      "WHAT",
      "WHEE",
      "WHEN",
      "WHET",
      "WHOA",
      "WHOM",
      "WICK",
      "WIFE",
      "WILD",
      "WILL",
      "WIND",
      "WINE",
      "WING",
      "WINK",
      "WINO",
      "WIRE",
      "WISE",
      "WISH",
      "WITH",
      "WOLF",
      "WONT",
      "WOOD",
      "WOOL",
      "WORD",
      "WORE",
      "WORK",
      "WORM",
      "WORN",
      "WOVE",
      "WRIT",
      "WYNN",
      "YALE",
      "YANG",
      "YANK",
      "YARD",
      "YARN",
      "YAWL",
      "YAWN",
      "YEAH",
      "YEAR",
      "YELL",
      "YOGA",
      "YOKE"
    ];
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/rfc1751.js
var require_rfc1751 = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/rfc1751.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyToRFC1751Mnemonic = exports.rfc1751MnemonicToKey = void 0;
    var utils_1 = require_browser();
    var rfc1751Words_json_1 = __importDefault(require_rfc1751Words());
    var rfc1751WordList = rfc1751Words_json_1.default;
    var BINARY = [
      "0000",
      "0001",
      "0010",
      "0011",
      "0100",
      "0101",
      "0110",
      "0111",
      "1000",
      "1001",
      "1010",
      "1011",
      "1100",
      "1101",
      "1110",
      "1111"
    ];
    function keyToBinary(key) {
      let res = "";
      for (const num of key) {
        res += BINARY[num >> 4] + BINARY[num & 15];
      }
      return res;
    }
    function extract(key, start, length) {
      const subKey = key.substring(start, start + length);
      let acc = 0;
      for (let index = 0; index < subKey.length; index++) {
        acc = acc * 2 + subKey.charCodeAt(index) - 48;
      }
      return acc;
    }
    function keyToRFC1751Mnemonic(hex_key) {
      const buf = (0, utils_1.hexToBytes)(hex_key.replace(/\s+/gu, ""));
      let key = bufferToArray(swap128(buf));
      const padding = [];
      for (let index = 0; index < (8 - key.length % 8) % 8; index++) {
        padding.push(0);
      }
      key = padding.concat(key);
      const english = [];
      for (let index = 0; index < key.length; index += 8) {
        const subKey = key.slice(index, index + 8);
        let skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        subKey.push(parity << 6 & 255);
        skbin = keyToBinary(subKey);
        for (let j = 0; j < 64; j += 11) {
          english.push(rfc1751WordList[extract(skbin, j, 11)]);
        }
      }
      return english.join(" ");
    }
    exports.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;
    function rfc1751MnemonicToKey(english) {
      const words = english.split(" ");
      let key = [];
      for (let index = 0; index < words.length; index += 6) {
        const { subKey, word } = getSubKey(words, index);
        const skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        const cs0 = extract(skbin, 64, 2);
        const cs1 = parity & 3;
        if (cs0 !== cs1) {
          throw new Error(`Parity error at ${word}`);
        }
        key = key.concat(subKey.slice(0, 8));
      }
      const bufferKey = swap128(Uint8Array.from(key));
      return bufferKey;
    }
    exports.rfc1751MnemonicToKey = rfc1751MnemonicToKey;
    function getSubKey(words, index) {
      const sublist = words.slice(index, index + 6);
      let bits = 0;
      const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      let word = "";
      for (word of sublist) {
        const idx = rfc1751WordList.indexOf(word.toUpperCase());
        if (idx === -1) {
          throw new TypeError(`Expected an RFC1751 word, but received '${word}'. For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`);
        }
        const shift = (8 - (bits + 11) % 8) % 8;
        const y = idx << shift;
        const cl = y >> 16;
        const cc = y >> 8 & 255;
        const cr = y & 255;
        const t = Math.floor(bits / 8);
        if (shift > 5) {
          ch[t] |= cl;
          ch[t + 1] |= cc;
          ch[t + 2] |= cr;
        } else if (shift > -3) {
          ch[t] |= cc;
          ch[t + 1] |= cr;
        } else {
          ch[t] |= cr;
        }
        bits += 11;
      }
      const subKey = ch.slice();
      return { subKey, word };
    }
    function bufferToArray(buf) {
      return Array.prototype.slice.call(buf);
    }
    function swap(arr, n, m) {
      const i = arr[n];
      arr[n] = arr[m];
      arr[m] = i;
    }
    function swap64(arr) {
      const len = arr.length;
      for (let i = 0; i < len; i += 8) {
        swap(arr, i, i + 7);
        swap(arr, i + 1, i + 6);
        swap(arr, i + 2, i + 5);
        swap(arr, i + 3, i + 4);
      }
      return arr;
    }
    function swap128(arr) {
      const reversedBytes = swap64(arr);
      return (0, utils_1.concat)([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)]);
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/signer.js
var require_signer = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multisign = exports.verifySignature = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = require_bignumber();
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    function multisign(transactions) {
      if (transactions.length === 0) {
        throw new errors_1.ValidationError("There were 0 transactions to multisign");
      }
      const decodedTransactions = transactions.map((txOrBlob) => {
        return getDecodedTransaction(txOrBlob);
      });
      decodedTransactions.forEach((tx) => {
        (0, transactions_1.validate)(tx);
        if (tx.Signers == null || tx.Signers.length === 0) {
          throw new errors_1.ValidationError("For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.");
        }
        if (tx.SigningPubKey !== "") {
          throw new errors_1.ValidationError("SigningPubKey must be an empty string for all transactions when multisigning.");
        }
      });
      validateTransactionEquivalence(decodedTransactions);
      return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));
    }
    exports.multisign = multisign;
    function verifySignature(tx, publicKey) {
      const decodedTx = getDecodedTransaction(tx);
      let key = publicKey;
      if (typeof decodedTx.TxnSignature !== "string" || !decodedTx.TxnSignature) {
        throw new Error("Transaction is missing a signature, TxnSignature");
      }
      if (!key) {
        if (typeof decodedTx.SigningPubKey !== "string" || !decodedTx.SigningPubKey) {
          throw new Error("Transaction is missing a public key, SigningPubKey");
        }
        key = decodedTx.SigningPubKey;
      }
      return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);
    }
    exports.verifySignature = verifySignature;
    function validateTransactionEquivalence(transactions) {
      const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
      if (transactions.slice(1).some((tx) => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {
        throw new errors_1.ValidationError("txJSON is not the same for all signedTransactions");
      }
    }
    function getTransactionWithAllSigners(transactions) {
      const sortedSigners = transactions.flatMap((tx) => {
        var _a;
        return (_a = tx.Signers) !== null && _a !== void 0 ? _a : [];
      }).sort(compareSigners);
      return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
    }
    function compareSigners(left, right) {
      return addressToBigNumber(left.Signer.Account).comparedTo(addressToBigNumber(right.Signer.Account));
    }
    var NUM_BITS_IN_HEX = 16;
    function addressToBigNumber(address) {
      const hex = (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));
      return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);
    }
    function getDecodedTransaction(txOrBlob) {
      if (typeof txOrBlob === "object") {
        return (0, ripple_binary_codec_1.decode)((0, ripple_binary_codec_1.encode)(txOrBlob));
      }
      return (0, ripple_binary_codec_1.decode)(txOrBlob);
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/index.js
var require_Wallet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = void 0;
    var bip32_1 = require_lib2();
    var bip39_1 = require_bip39();
    var english_1 = require_english();
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    var utils_2 = require_utils9();
    var collections_1 = require_collections();
    var hashLedger_1 = require_hashLedger();
    var rfc1751_1 = require_rfc1751();
    var signer_1 = require_signer();
    var DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;
    var DEFAULT_DERIVATION_PATH = "m/44'/144'/0'/0/0";
    function validateKey(node) {
      if (!(node.privateKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError("Unable to derive privateKey from mnemonic input");
      }
      if (!(node.publicKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError("Unable to derive publicKey from mnemonic input");
      }
    }
    var Wallet = class _Wallet {
      constructor(publicKey, privateKey, opts = {}) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.classicAddress = opts.masterAddress ? (0, utils_2.ensureClassicAddress)(opts.masterAddress) : (0, ripple_keypairs_1.deriveAddress)(publicKey);
        this.seed = opts.seed;
      }
      get address() {
        return this.classicAddress;
      }
      static generate(algorithm = DEFAULT_ALGORITHM) {
        if (!Object.values(ECDSA_1.default).includes(algorithm)) {
          throw new errors_1.ValidationError("Invalid cryptographic signing algorithm");
        }
        const seed = (0, ripple_keypairs_1.generateSeed)({ algorithm });
        return _Wallet.fromSeed(seed, { algorithm });
      }
      static fromSeed(seed, opts = {}) {
        return _Wallet.deriveWallet(seed, {
          algorithm: opts.algorithm,
          masterAddress: opts.masterAddress
        });
      }
      static fromEntropy(entropy, opts = {}) {
        var _a;
        const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;
        const options = {
          entropy: Uint8Array.from(entropy),
          algorithm
        };
        const seed = (0, ripple_keypairs_1.generateSeed)(options);
        return _Wallet.deriveWallet(seed, {
          algorithm,
          masterAddress: opts.masterAddress
        });
      }
      static fromMnemonic(mnemonic, opts = {}) {
        var _a;
        if (opts.mnemonicEncoding === "rfc1751") {
          return _Wallet.fromRFC1751Mnemonic(mnemonic, {
            masterAddress: opts.masterAddress,
            algorithm: opts.algorithm
          });
        }
        if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
          throw new errors_1.ValidationError("Unable to parse the given mnemonic using bip39 encoding");
        }
        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
        const masterNode = bip32_1.HDKey.fromMasterSeed(seed);
        const node = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);
        validateKey(node);
        const publicKey = (0, utils_1.bytesToHex)(node.publicKey);
        const privateKey = (0, utils_1.bytesToHex)(node.privateKey);
        return new _Wallet(publicKey, `00${privateKey}`, {
          masterAddress: opts.masterAddress
        });
      }
      static fromRFC1751Mnemonic(mnemonic, opts) {
        const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);
        let encodeAlgorithm;
        if (opts.algorithm === ECDSA_1.default.ed25519) {
          encodeAlgorithm = "ed25519";
        } else {
          encodeAlgorithm = "secp256k1";
        }
        const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(seed, encodeAlgorithm);
        return _Wallet.fromSeed(encodedSeed, {
          masterAddress: opts.masterAddress,
          algorithm: opts.algorithm
        });
      }
      static deriveWallet(seed, opts = {}) {
        var _a;
        const { publicKey, privateKey } = (0, ripple_keypairs_1.deriveKeypair)(seed, {
          algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM
        });
        return new _Wallet(publicKey, privateKey, {
          seed,
          masterAddress: opts.masterAddress
        });
      }
      sign(transaction, multisign) {
        let multisignAddress = false;
        if (typeof multisign === "string" && multisign.startsWith("X")) {
          multisignAddress = multisign;
        } else if (multisign) {
          multisignAddress = this.classicAddress;
        }
        const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), (value) => value == null);
        if (tx.TxnSignature || tx.Signers) {
          throw new errors_1.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
        }
        removeTrailingZeros(tx);
        (0, transactions_1.validate)(tx);
        const txToSignAndEncode = Object.assign({}, tx);
        txToSignAndEncode.SigningPubKey = multisignAddress ? "" : this.publicKey;
        if (multisignAddress) {
          const signer = {
            Account: multisignAddress,
            SigningPubKey: this.publicKey,
            TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress)
          };
          txToSignAndEncode.Signers = [{ Signer: signer }];
        } else {
          txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);
        }
        const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);
        return {
          tx_blob: serialized,
          hash: (0, hashLedger_1.hashSignedTx)(serialized)
        };
      }
      verifyTransaction(signedTransaction) {
        return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);
      }
      getXAddress(tag = false, isTestnet = false) {
        return (0, ripple_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);
      }
    };
    exports.Wallet = Wallet;
    Wallet.fromSecret = Wallet.fromSeed;
    function computeSignature(tx, privateKey, signAs) {
      if (signAs) {
        const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(signAs) ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress : signAs;
        return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);
      }
      return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigning)(tx), privateKey);
    }
    function removeTrailingZeros(tx) {
      if (tx.TransactionType === "Payment" && typeof tx.Amount !== "string" && tx.Amount.value.includes(".") && tx.Amount.value.endsWith("0")) {
        tx.Amount = Object.assign({}, tx.Amount);
        tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();
      }
    }
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js
var require_defaultFaucets = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultFaucetPath = exports.getFaucetHost = exports.FaucetNetworkPaths = exports.FaucetNetwork = void 0;
    var errors_1 = require_errors();
    var FaucetNetwork;
    (function(FaucetNetwork2) {
      FaucetNetwork2["Testnet"] = "faucet.altnet.rippletest.net";
      FaucetNetwork2["Devnet"] = "faucet.devnet.rippletest.net";
    })(FaucetNetwork || (exports.FaucetNetwork = FaucetNetwork = {}));
    exports.FaucetNetworkPaths = {
      [FaucetNetwork.Testnet]: "/accounts",
      [FaucetNetwork.Devnet]: "/accounts"
    };
    function getFaucetHost(client) {
      const connectionUrl = client.url;
      if (connectionUrl.includes("altnet") || connectionUrl.includes("testnet")) {
        return FaucetNetwork.Testnet;
      }
      if (connectionUrl.includes("sidechain-net2")) {
        throw new errors_1.XRPLFaucetError("Cannot fund an account on an issuing chain. Accounts must be created via the bridge.");
      }
      if (connectionUrl.includes("devnet")) {
        return FaucetNetwork.Devnet;
      }
      throw new errors_1.XRPLFaucetError("Faucet URL is not defined or inferrable.");
    }
    exports.getFaucetHost = getFaucetHost;
    function getDefaultFaucetPath(hostname) {
      if (hostname === void 0) {
        return "/accounts";
      }
      return exports.FaucetNetworkPaths[hostname] || "/accounts";
    }
    exports.getDefaultFaucetPath = getDefaultFaucetPath;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/fundWallet.js
var require_fundWallet = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/fundWallet.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    var defaultFaucets_1 = require_defaultFaucets();
    var _1 = require_Wallet();
    var INTERVAL_SECONDS = 1;
    var MAX_ATTEMPTS = 20;
    function generateWalletToFund(wallet) {
      if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {
        return wallet;
      }
      return _1.Wallet.generate();
    }
    exports.generateWalletToFund = generateWalletToFund;
    function getStartingBalance(client, classicAddress) {
      return __awaiter(this, void 0, void 0, function* () {
        let startingBalance = 0;
        try {
          startingBalance = Number(yield client.getXrpBalance(classicAddress));
        } catch (_a) {
        }
        return startingBalance;
      });
    }
    exports.getStartingBalance = getStartingBalance;
    function requestFunding(options, client, startingBalance, walletToFund, postBody) {
      var _a, _b, _c;
      return __awaiter(this, void 0, void 0, function* () {
        const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);
        if (!hostname) {
          throw new errors_1.XRPLFaucetError("No faucet hostname could be derived");
        }
        const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);
        const response = yield fetch(`https://${hostname}${pathname}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(postBody)
        });
        const body = yield response.json();
        if (response.ok && ((_c = response.headers.get("Content-Type")) === null || _c === void 0 ? void 0 : _c.startsWith("application/json"))) {
          const classicAddress = body.account.classicAddress;
          return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);
        }
        return processError(response, body);
      });
    }
    exports.requestFunding = requestFunding;
    function processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!classicAddress) {
          return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));
        }
        try {
          const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);
          if (updatedBalance > startingBalance) {
            return {
              wallet: walletToFund,
              balance: updatedBalance
            };
          }
          throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);
        } catch (err) {
          if (err instanceof Error) {
            throw new errors_1.XRPLFaucetError(err.message);
          }
          throw err;
        }
      });
    }
    function processError(response, body) {
      return __awaiter(this, void 0, void 0, function* () {
        return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify({
          body: body || {},
          contentType: response.headers.get("Content-Type"),
          statusCode: response.status
        })}`));
      });
    }
    function getUpdatedBalance(client, address, originalBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          let attempts = MAX_ATTEMPTS;
          const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            if (attempts < 0) {
              clearInterval(interval);
              resolve(originalBalance);
            } else {
              attempts -= 1;
            }
            try {
              let newBalance;
              try {
                newBalance = Number(yield client.getXrpBalance(address));
              } catch (_a) {
              }
              if (newBalance > originalBalance) {
                clearInterval(interval);
                resolve(newBalance);
              }
            } catch (err) {
              clearInterval(interval);
              if (err instanceof Error) {
                reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));
              }
              reject(err);
            }
          }), INTERVAL_SECONDS * 1e3);
        });
      });
    }
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1/node_modules/@xrplf/isomorphic/dist/ws/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventemitter3_1 = require_eventemitter3();
    var WSWrapper = class extends eventemitter3_1.EventEmitter {
      /**
       * Constructs a browser-safe websocket.
       *
       * @param url - URL to connect to.
       * @param _protocols - Not used.
       * @param _websocketOptions - Not used.
       */
      constructor(url, _protocols, _websocketOptions) {
        super();
        this.ws = new WebSocket(url);
        this.ws.onclose = (closeEvent) => {
          let reason;
          if (closeEvent.reason) {
            const enc = new TextEncoder();
            reason = enc.encode(closeEvent.reason);
          }
          this.emit("close", closeEvent.code, reason);
        };
        this.ws.onopen = () => {
          this.emit("open");
        };
        this.ws.onerror = (error) => {
          this.emit("error", error);
        };
        this.ws.onmessage = (message) => {
          this.emit("message", message.data);
        };
      }
      /**
       * Get the ready state of the websocket.
       *
       * @returns The Websocket's ready state.
       */
      get readyState() {
        return this.ws.readyState;
      }
      /**
       * Closes the websocket.
       *
       * @param code - Close code.
       * @param reason - Close reason.
       */
      close(code, reason) {
        if (this.readyState === 1) {
          this.ws.close(code, reason);
        }
      }
      /**
       * Sends a message over the Websocket connection.
       *
       * @param message - Message to send.
       */
      send(message) {
        this.ws.send(message);
      }
    };
    WSWrapper.CONNECTING = 0;
    WSWrapper.OPEN = 1;
    WSWrapper.CLOSING = 2;
    WSWrapper.CLOSED = 3;
    exports.default = WSWrapper;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/ConnectionManager.js
var require_ConnectionManager = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/ConnectionManager.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConnectionManager = class {
      constructor() {
        this.promisesAwaitingConnection = [];
      }
      resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve }) => resolve());
        this.promisesAwaitingConnection = [];
      }
      rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
      }
      awaitConnection() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingConnection.push({ resolve, reject });
          });
        });
      }
    };
    exports.default = ConnectionManager;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/ExponentialBackoff.js
var require_ExponentialBackoff = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/ExponentialBackoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_MIN = 100;
    var DEFAULT_MAX = 1e3;
    var ExponentialBackoff = class {
      constructor(opts = {}) {
        var _a, _b;
        this.factor = 2;
        this.numAttempts = 0;
        this.ms = (_a = opts.min) !== null && _a !== void 0 ? _a : DEFAULT_MIN;
        this.max = (_b = opts.max) !== null && _b !== void 0 ? _b : DEFAULT_MAX;
      }
      get attempts() {
        return this.numAttempts;
      }
      duration() {
        const ms = this.ms * Math.pow(this.factor, this.numAttempts);
        this.numAttempts += 1;
        return Math.floor(Math.min(ms, this.max));
      }
      reset() {
        this.numAttempts = 0;
      }
    };
    exports.default = ExponentialBackoff;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/RequestManager.js
var require_RequestManager = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/RequestManager.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var RequestManager = class {
      constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = /* @__PURE__ */ new Map();
      }
      addPromise(newId, timer) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingResponse.set(newId, {
              resolve,
              reject,
              timer
            });
          });
        });
      }
      resolve(id, response) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "resolve",
            response
          });
        }
        clearTimeout(promise.timer);
        promise.resolve(response);
        this.deletePromise(id);
      }
      reject(id, error) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "reject",
            error
          });
        }
        clearTimeout(promise.timer);
        promise.reject(error);
        this.deletePromise(id);
      }
      rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_promise, id, _map) => {
          this.reject(id, error);
          this.deletePromise(id);
        });
      }
      createRequest(request, timeout) {
        let newId;
        if (request.id == null) {
          newId = this.nextId;
          this.nextId += 1;
        } else {
          newId = request.id;
        }
        const newRequest = JSON.stringify(Object.assign(Object.assign({}, request), { id: newId }));
        const timer = setTimeout(() => {
          this.reject(newId, new errors_1.TimeoutError(`Timeout for request: ${JSON.stringify(request)} with id ${newId}`, request));
        }, timeout);
        if (timer.unref) {
          ;
          timer.unref();
        }
        if (this.promisesAwaitingResponse.has(newId)) {
          clearTimeout(timer);
          throw new errors_1.XrplError(`Response with id '${newId}' is already pending`, request);
        }
        const newPromise = new Promise((resolve, reject) => {
          this.promisesAwaitingResponse.set(newId, {
            resolve,
            reject,
            timer
          });
        });
        return [newId, newRequest, newPromise];
      }
      handleResponse(response) {
        var _a, _b;
        if (response.id == null || !(typeof response.id === "string" || typeof response.id === "number")) {
          throw new errors_1.ResponseFormatError("valid id not found in response", response);
        }
        if (!this.promisesAwaitingResponse.has(response.id)) {
          return;
        }
        if (response.status == null) {
          const error = new errors_1.ResponseFormatError("Response has no status");
          this.reject(response.id, error);
        }
        if (response.status === "error") {
          const errorResponse = response;
          const error = new errors_1.RippledError((_a = errorResponse.error_message) !== null && _a !== void 0 ? _a : errorResponse.error, errorResponse);
          this.reject(response.id, error);
          return;
        }
        if (response.status !== "success") {
          const error = new errors_1.ResponseFormatError(`unrecognized response.status: ${(_b = response.status) !== null && _b !== void 0 ? _b : ""}`, response);
          this.reject(response.id, error);
          return;
        }
        delete response.status;
        this.resolve(response.id, response);
      }
      deletePromise(id) {
        this.promisesAwaitingResponse.delete(id);
      }
    };
    exports.default = RequestManager;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/connection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = exports.INTENTIONAL_DISCONNECT_CODE = void 0;
    var utils_1 = require_browser();
    var ws_1 = __importDefault(require_browser5());
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var ConnectionManager_1 = __importDefault(require_ConnectionManager());
    var ExponentialBackoff_1 = __importDefault(require_ExponentialBackoff());
    var RequestManager_1 = __importDefault(require_RequestManager());
    var SECONDS_PER_MINUTE = 60;
    var TIMEOUT = 20;
    var CONNECTION_TIMEOUT = 5;
    exports.INTENTIONAL_DISCONNECT_CODE = 4e3;
    function createWebSocket(url, config) {
      const options = {
        agent: config.agent
      };
      if (config.headers) {
        options.headers = config.headers;
      }
      if (config.authorization != null) {
        options.headers = Object.assign(Object.assign({}, options.headers), { Authorization: `Basic ${btoa(config.authorization)}` });
      }
      const websocketOptions = Object.assign({}, options);
      return new ws_1.default(url, websocketOptions);
    }
    function websocketSendAsync(ws, message) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          ws.send(message, (error) => {
            if (error) {
              reject(new errors_1.DisconnectedError(error.message, error));
            } else {
              resolve();
            }
          });
        });
      });
    }
    var Connection = class extends eventemitter3_1.EventEmitter {
      constructor(url, options = {}) {
        super();
        this.ws = null;
        this.reconnectTimeoutID = null;
        this.heartbeatIntervalID = null;
        this.retryConnectionBackoff = new ExponentialBackoff_1.default({
          min: 100,
          max: SECONDS_PER_MINUTE * 1e3
        });
        this.requestManager = new RequestManager_1.default();
        this.connectionManager = new ConnectionManager_1.default();
        this.trace = () => {
        };
        this.url = url;
        this.config = Object.assign({ timeout: TIMEOUT * 1e3, connectionTimeout: CONNECTION_TIMEOUT * 1e3 }, options);
        if (typeof options.trace === "function") {
          this.trace = options.trace;
        } else if (options.trace) {
          this.trace = console.log;
        }
      }
      get state() {
        return this.ws ? this.ws.readyState : ws_1.default.CLOSED;
      }
      get shouldBeConnected() {
        return this.ws !== null;
      }
      isConnected() {
        return this.state === ws_1.default.OPEN;
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.isConnected()) {
            return Promise.resolve();
          }
          if (this.state === ws_1.default.CONNECTING) {
            return this.connectionManager.awaitConnection();
          }
          if (!this.url) {
            return Promise.reject(new errors_1.ConnectionError("Cannot connect because no server was specified"));
          }
          if (this.ws != null) {
            return Promise.reject(new errors_1.XrplError("Websocket connection never cleaned up.", {
              state: this.state
            }));
          }
          const connectionTimeoutID = setTimeout(() => {
            this.onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`));
          }, this.config.connectionTimeout);
          this.ws = createWebSocket(this.url, this.config);
          if (this.ws == null) {
            throw new errors_1.XrplError("Connect: created null websocket");
          }
          this.ws.on("error", (error) => this.onConnectionFailed(error));
          this.ws.on("error", () => clearTimeout(connectionTimeoutID));
          this.ws.on("close", (reason) => this.onConnectionFailed(reason));
          this.ws.on("close", () => clearTimeout(connectionTimeoutID));
          this.ws.once("open", () => {
            void this.onceOpen(connectionTimeoutID);
          });
          return this.connectionManager.awaitConnection();
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.clearHeartbeatInterval();
          if (this.reconnectTimeoutID !== null) {
            clearTimeout(this.reconnectTimeoutID);
            this.reconnectTimeoutID = null;
          }
          if (this.state === ws_1.default.CLOSED) {
            return Promise.resolve(void 0);
          }
          if (this.ws == null) {
            return Promise.resolve(void 0);
          }
          return new Promise((resolve) => {
            if (this.ws == null) {
              resolve(void 0);
            }
            if (this.ws != null) {
              this.ws.once("close", (code) => resolve(code));
            }
            if (this.ws != null && this.state !== ws_1.default.CLOSING) {
              this.ws.close(exports.INTENTIONAL_DISCONNECT_CODE);
            }
          });
        });
      }
      reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.emit("reconnect");
          yield this.disconnect();
          yield this.connect();
        });
      }
      request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.shouldBeConnected || this.ws == null) {
            throw new errors_1.NotConnectedError(JSON.stringify(request), request);
          }
          const [id, message, responsePromise] = this.requestManager.createRequest(request, timeout !== null && timeout !== void 0 ? timeout : this.config.timeout);
          this.trace("send", message);
          websocketSendAsync(this.ws, message).catch((error) => {
            this.requestManager.reject(id, error);
          });
          return responsePromise;
        });
      }
      getUrl() {
        var _a;
        return (_a = this.url) !== null && _a !== void 0 ? _a : "";
      }
      onMessage(message) {
        this.trace("receive", message);
        let data;
        try {
          data = JSON.parse(message);
        } catch (error) {
          if (error instanceof Error) {
            this.emit("error", "badMessage", error.message, message);
          }
          return;
        }
        if (data.type == null && data.error) {
          this.emit("error", data.error, data.error_message, data);
          return;
        }
        if (data.type) {
          this.emit(data.type, data);
        }
        if (data.type === "response") {
          try {
            this.requestManager.handleResponse(data);
          } catch (error) {
            if (error instanceof Error) {
              this.emit("error", "badMessage", error.message, message);
            } else {
              this.emit("error", "badMessage", error, error);
            }
          }
        }
      }
      onceOpen(connectionTimeoutID) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.ws == null) {
            throw new errors_1.XrplError("onceOpen: ws is null");
          }
          this.ws.removeAllListeners();
          clearTimeout(connectionTimeoutID);
          this.ws.on("message", (message) => this.onMessage(message));
          this.ws.on("error", (error) => this.emit("error", "websocket", error.message, error));
          this.ws.once("close", (code, reason) => {
            if (this.ws == null) {
              throw new errors_1.XrplError("onceClose: ws is null");
            }
            this.clearHeartbeatInterval();
            this.requestManager.rejectAll(new errors_1.DisconnectedError(`websocket was closed, ${reason ? (0, utils_1.hexToString)((0, utils_1.bytesToHex)(reason)) : ""}`));
            this.ws.removeAllListeners();
            this.ws = null;
            if (code === void 0) {
              const internalErrorCode = 1011;
              this.emit("disconnected", internalErrorCode);
            } else {
              this.emit("disconnected", code);
            }
            if (code !== exports.INTENTIONAL_DISCONNECT_CODE && code !== void 0) {
              this.intentionalDisconnect();
            }
          });
          try {
            this.retryConnectionBackoff.reset();
            this.startHeartbeatInterval();
            this.connectionManager.resolveAllAwaiting();
            this.emit("connected");
          } catch (error) {
            if (error instanceof Error) {
              this.connectionManager.rejectAllAwaiting(error);
              yield this.disconnect().catch(() => {
              });
            }
          }
        });
      }
      intentionalDisconnect() {
        const retryTimeout = this.retryConnectionBackoff.duration();
        this.trace("reconnect", `Retrying connection in ${retryTimeout}ms.`);
        this.emit("reconnecting", this.retryConnectionBackoff.attempts);
        this.reconnectTimeoutID = setTimeout(() => {
          this.reconnect().catch((error) => {
            this.emit("error", "reconnect", error.message, error);
          });
        }, retryTimeout);
      }
      clearHeartbeatInterval() {
        if (this.heartbeatIntervalID) {
          clearInterval(this.heartbeatIntervalID);
        }
      }
      startHeartbeatInterval() {
        this.clearHeartbeatInterval();
        this.heartbeatIntervalID = setInterval(() => {
          void this.heartbeat();
        }, this.config.timeout);
      }
      heartbeat() {
        return __awaiter(this, void 0, void 0, function* () {
          this.request({ command: "ping" }).catch(() => __awaiter(this, void 0, void 0, function* () {
            return this.reconnect().catch((error) => {
              this.emit("error", "reconnect", error.message, error);
            });
          }));
        });
      }
      onConnectionFailed(errorOrCode) {
        if (this.ws) {
          this.ws.removeAllListeners();
          this.ws.on("error", () => {
          });
          this.ws.close();
          this.ws = null;
        }
        if (typeof errorOrCode === "number") {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {
            code: errorOrCode
          }));
        } else if (errorOrCode === null || errorOrCode === void 0 ? void 0 : errorOrCode.message) {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));
        } else {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError("Connection failed."));
        }
      }
    };
    exports.Connection = Connection;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/partialPayment.js
var require_partialPayment = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/partialPayment.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleStreamPartialPayment = exports.handlePartialPayment = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist2();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils4();
    var WARN_PARTIAL_PAYMENT_CODE = 2001;
    function amountsEqual(amt1, amt2) {
      if (typeof amt1 === "string" && typeof amt2 === "string") {
        return amt1 === amt2;
      }
      if (typeof amt1 === "string" || typeof amt2 === "string") {
        return false;
      }
      if ((0, transactions_1.isMPTAmount)(amt1) && (0, transactions_1.isMPTAmount)(amt2)) {
        const aValue2 = new bignumber_js_1.default(amt1.value);
        const bValue2 = new bignumber_js_1.default(amt2.value);
        return amt1.mpt_issuance_id === amt2.mpt_issuance_id && aValue2.isEqualTo(bValue2);
      }
      if ((0, transactions_1.isMPTAmount)(amt1) || (0, transactions_1.isMPTAmount)(amt2)) {
        return false;
      }
      const aValue = new bignumber_js_1.default(amt1.value);
      const bValue = new bignumber_js_1.default(amt2.value);
      return amt1.currency === amt2.currency && amt1.issuer === amt2.issuer && aValue.isEqualTo(bValue);
    }
    function isPartialPayment(tx, metadata) {
      var _a;
      if (tx == null || metadata == null || tx.TransactionType !== "Payment") {
        return false;
      }
      let meta = metadata;
      if (typeof meta === "string") {
        if (meta === "unavailable") {
          return false;
        }
        meta = (0, ripple_binary_codec_1.decode)(meta);
      }
      const tfPartial = typeof tx.Flags === "number" ? (0, utils_1.isFlagEnabled)(tx.Flags, transactions_1.PaymentFlags.tfPartialPayment) : (_a = tx.Flags) === null || _a === void 0 ? void 0 : _a.tfPartialPayment;
      if (!tfPartial) {
        return false;
      }
      const delivered = meta.delivered_amount;
      const amount = tx.DeliverMax;
      if (delivered === void 0) {
        return false;
      }
      return !amountsEqual(delivered, amount);
    }
    function txHasPartialPayment(response) {
      return isPartialPayment(response.result.tx_json, response.result.meta);
    }
    function txEntryHasPartialPayment(response) {
      return isPartialPayment(response.result.tx_json, response.result.metadata);
    }
    function accountTxHasPartialPayment(response) {
      const { transactions } = response.result;
      const foo = transactions.some((tx) => {
        if (tx.tx_json != null) {
          const transaction2 = tx;
          return isPartialPayment(transaction2.tx_json, transaction2.meta);
        }
        const transaction = tx;
        return isPartialPayment(transaction.tx, transaction.meta);
      });
      return foo;
    }
    function hasPartialPayment(command, response) {
      switch (command) {
        case "tx":
          return txHasPartialPayment(response);
        case "transaction_entry":
          return txEntryHasPartialPayment(response);
        case "account_tx":
          return accountTxHasPartialPayment(response);
        default:
          return false;
      }
    }
    function handlePartialPayment(command, response) {
      var _a;
      if (hasPartialPayment(command, response)) {
        const warnings = (_a = response.warnings) !== null && _a !== void 0 ? _a : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment"
        };
        warnings.push(warning);
        response.warnings = warnings;
      }
    }
    exports.handlePartialPayment = handlePartialPayment;
    function handleStreamPartialPayment(stream, log) {
      var _a, _b;
      if (isPartialPayment((_a = stream.tx_json) !== null && _a !== void 0 ? _a : stream.transaction, stream.meta)) {
        const warnings = (_b = stream.warnings) !== null && _b !== void 0 ? _b : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment"
        };
        warnings.push(warning);
        stream.warnings = warnings;
        log("Partial payment received", JSON.stringify(stream));
      }
    }
    exports.handleStreamPartialPayment = handleStreamPartialPayment;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/index.js
var require_client = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/client/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = void 0;
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var common_1 = require_common();
    var flags_1 = require_flags();
    var sugar_1 = require_sugar();
    var autofill_1 = require_autofill();
    var balances_1 = require_balances();
    var getOrderbook_1 = require_getOrderbook();
    var utils_1 = require_utils8();
    var Wallet_1 = require_Wallet();
    var fundWallet_1 = require_fundWallet();
    var connection_1 = require_connection();
    var partialPayment_1 = require_partialPayment();
    function getCollectKeyFromCommand(command) {
      switch (command) {
        case "account_channels":
          return "channels";
        case "account_lines":
          return "lines";
        case "account_objects":
          return "account_objects";
        case "account_tx":
          return "transactions";
        case "account_offers":
        case "book_offers":
          return "offers";
        case "ledger_data":
          return "state";
        default:
          return null;
      }
    }
    function clamp(value, min, max) {
      if (min > max) {
        throw new Error("Illegal clamp bounds");
      }
      return Math.min(Math.max(value, min), max);
    }
    var DEFAULT_FEE_CUSHION = 1.2;
    var DEFAULT_MAX_FEE_XRP = "2";
    var MIN_LIMIT = 10;
    var MAX_LIMIT = 400;
    var NORMAL_DISCONNECT_CODE = 1e3;
    var Client = class extends eventemitter3_1.EventEmitter {
      constructor(server, options = {}) {
        var _a, _b;
        super();
        this.apiVersion = common_1.DEFAULT_API_VERSION;
        if (typeof server !== "string" || !/wss?(?:\+unix)?:\/\//u.exec(server)) {
          throw new errors_1.ValidationError("server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.");
        }
        this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;
        this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;
        this.connection = new connection_1.Connection(server, options);
        this.connection.on("error", (errorCode, errorMessage, data) => {
          this.emit("error", errorCode, errorMessage, data);
        });
        this.connection.on("reconnect", () => {
          this.connection.on("connected", () => this.emit("connected"));
        });
        this.connection.on("disconnected", (code) => {
          let finalCode = code;
          if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {
            finalCode = NORMAL_DISCONNECT_CODE;
          }
          this.emit("disconnected", finalCode);
        });
        this.connection.on("ledgerClosed", (ledger) => {
          this.emit("ledgerClosed", ledger);
        });
        this.connection.on("transaction", (tx) => {
          (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);
          this.emit("transaction", tx);
        });
        this.connection.on("validationReceived", (validation) => {
          this.emit("validationReceived", validation);
        });
        this.connection.on("manifestReceived", (manifest) => {
          this.emit("manifestReceived", manifest);
        });
        this.connection.on("peerStatusChange", (status) => {
          this.emit("peerStatusChange", status);
        });
        this.connection.on("consensusPhase", (consensus) => {
          this.emit("consensusPhase", consensus);
        });
        this.connection.on("path_find", (path) => {
          this.emit("path_find", path);
        });
      }
      get url() {
        return this.connection.getUrl();
      }
      request(req) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const request = Object.assign(Object.assign({}, req), { account: typeof req.account === "string" ? (0, sugar_1.ensureClassicAddress)(req.account) : void 0, api_version: (_a = req.api_version) !== null && _a !== void 0 ? _a : this.apiVersion });
          const response = yield this.connection.request(request);
          (0, partialPayment_1.handlePartialPayment)(req.command, response);
          return response;
        });
      }
      requestNextPage(req, resp) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!resp.result.marker) {
            return Promise.reject(new errors_1.NotFoundError("response does not have a next page"));
          }
          const nextPageRequest = Object.assign(Object.assign({}, req), { marker: resp.result.marker });
          return this.request(nextPageRequest);
        });
      }
      on(eventName, listener) {
        return super.on(eventName, listener);
      }
      requestAll(request, collect) {
        return __awaiter(this, void 0, void 0, function* () {
          const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);
          if (!collectKey) {
            throw new errors_1.ValidationError(`no collect key for command ${request.command}`);
          }
          const countTo = request.limit == null ? Infinity : request.limit;
          let count = 0;
          let marker = request.marker;
          const results = [];
          do {
            const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);
            const repeatProps = Object.assign(Object.assign({}, request), { limit: countRemaining, marker });
            const singleResponse = yield this.connection.request(repeatProps);
            const singleResult = singleResponse.result;
            if (!(collectKey in singleResult)) {
              throw new errors_1.XrplError(`${collectKey} not in result`);
            }
            const collectedData = singleResult[collectKey];
            marker = singleResult.marker;
            results.push(singleResponse);
            if (Array.isArray(collectedData)) {
              count += collectedData.length;
            }
          } while (Boolean(marker) && count < countTo);
          return results;
        });
      }
      getServerInfo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const response = yield this.request({
              command: "server_info"
            });
            this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : void 0;
            this.buildVersion = response.result.info.build_version;
          } catch (error) {
            console.error(error);
          }
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {
            yield this.getServerInfo();
            this.emit("connected");
          }));
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.connection.disconnect();
        });
      }
      isConnected() {
        return this.connection.isConnected();
      }
      autofill(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
          const tx = Object.assign({}, transaction);
          (0, autofill_1.setValidAddresses)(tx);
          tx.Flags = (0, flags_1.convertTxFlagsToNumber)(tx);
          const promises = [];
          if (tx.NetworkID == null) {
            tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : void 0;
          }
          if (tx.Sequence == null) {
            promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));
          }
          if (tx.Fee == null) {
            promises.push((0, autofill_1.calculateFeePerTransactionType)(this, tx, signersCount));
          }
          if (tx.LastLedgerSequence == null) {
            promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));
          }
          if (tx.TransactionType === "AccountDelete") {
            promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));
          }
          if (tx.TransactionType === "Payment" && tx.DeliverMax != null) {
            if (tx.Amount == null) {
              tx.Amount = tx.DeliverMax;
            }
            if (tx.Amount != null && tx.Amount !== tx.DeliverMax) {
              return Promise.reject(new errors_1.ValidationError("PaymentTransaction: Amount and DeliverMax fields must be identical when both are provided"));
            }
            delete tx.DeliverMax;
          }
          return Promise.all(promises).then(() => tx);
        });
      }
      submit(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
          return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
        });
      }
      simulate(transaction, opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const binary = (_a = opts === null || opts === void 0 ? void 0 : opts.binary) !== null && _a !== void 0 ? _a : false;
          const request = typeof transaction === "string" ? { command: "simulate", tx_blob: transaction, binary } : { command: "simulate", tx_json: transaction, binary };
          return this.request(request);
        });
      }
      submitAndWait(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
          const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);
          if (lastLedger == null) {
            throw new errors_1.ValidationError("Transaction must contain a LastLedgerSequence value for reliable submission.");
          }
          const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
          const txHash = utils_1.hashes.hashSignedTx(signedTx);
          return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);
        });
      }
      prepareTransaction(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.autofill(transaction, signersCount);
        });
      }
      getXrpBalance(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const xrpRequest = {
            command: "account_info",
            account: address,
            ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
            ledger_hash: options.ledger_hash
          };
          const response = yield this.request(xrpRequest);
          return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);
        });
      }
      getBalances(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const balances = [];
          let xrpPromise = Promise.resolve(0);
          if (!options.peer) {
            xrpPromise = this.getXrpBalance(address, {
              ledger_hash: options.ledger_hash,
              ledger_index: options.ledger_index
            });
          }
          const linesRequest = {
            command: "account_lines",
            account: address,
            ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
            ledger_hash: options.ledger_hash,
            peer: options.peer,
            limit: options.limit
          };
          const linesPromise = this.requestAll(linesRequest);
          yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {
            const accountLinesBalance = linesResponses.flatMap((response) => (0, balances_1.formatBalances)(response.result.lines));
            if (xrpBalance !== 0) {
              balances.push({ currency: "XRP", value: xrpBalance.toString() });
            }
            balances.push(...accountLinesBalance);
          });
          return balances.slice(0, options.limit);
        });
      }
      getOrderbook(currency1, currency2, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          (0, getOrderbook_1.validateOrderbookOptions)(options);
          const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);
          const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);
          const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));
          const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);
          const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);
          const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);
          const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(orders);
          return {
            buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),
            sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit)
          };
        });
      }
      getLedgerIndex() {
        return __awaiter(this, void 0, void 0, function* () {
          const ledgerResponse = yield this.request({
            command: "ledger",
            ledger_index: "validated"
          });
          return ledgerResponse.result.ledger_index;
        });
      }
      fundWallet(wallet, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.isConnected()) {
            throw new errors_1.RippledError("Client not connected, cannot call faucet");
          }
          const existingWallet = Boolean(wallet);
          const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress) ? wallet : Wallet_1.Wallet.generate();
          const postBody = {
            destination: walletToFund.classicAddress,
            xrpAmount: options.amount,
            usageContext: options.usageContext,
            userAgent: "xrpl.js"
          };
          let startingBalance = 0;
          if (existingWallet) {
            try {
              startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));
            } catch (_a) {
            }
          }
          return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);
        });
      }
    };
    exports.Client = Client;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/Amendments.js
var require_Amendments = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/Amendments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AMENDMENTS_ID = void 0;
    exports.AMENDMENTS_ID = "7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4";
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js
var require_FeeSettings = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FEE_SETTINGS_ID = void 0;
    exports.FEE_SETTINGS_ID = "4BC50C9B0D8515D3EAAE1E74B29A95804346C491EE1A95BF25E4AAB854A6A651";
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js
var require_NegativeUNL = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NEGATIVE_UNL_ID = void 0;
    exports.NEGATIVE_UNL_ID = "2E8A59AA9D3B5B186B0B9E0F62E6C02587CA74A4D778938E957B6357D364B244";
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/RippleState.js
var require_RippleState = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/RippleState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RippleStateFlags = void 0;
    var RippleStateFlags;
    (function(RippleStateFlags2) {
      RippleStateFlags2[RippleStateFlags2["lsfLowReserve"] = 65536] = "lsfLowReserve";
      RippleStateFlags2[RippleStateFlags2["lsfHighReserve"] = 131072] = "lsfHighReserve";
      RippleStateFlags2[RippleStateFlags2["lsfLowAuth"] = 262144] = "lsfLowAuth";
      RippleStateFlags2[RippleStateFlags2["lsfHighAuth"] = 524288] = "lsfHighAuth";
      RippleStateFlags2[RippleStateFlags2["lsfLowNoRipple"] = 1048576] = "lsfLowNoRipple";
      RippleStateFlags2[RippleStateFlags2["lsfHighNoRipple"] = 2097152] = "lsfHighNoRipple";
      RippleStateFlags2[RippleStateFlags2["lsfLowFreeze"] = 4194304] = "lsfLowFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfHighFreeze"] = 8388608] = "lsfHighFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfAMMNode"] = 16777216] = "lsfAMMNode";
      RippleStateFlags2[RippleStateFlags2["lsfLowDeepFreeze"] = 33554432] = "lsfLowDeepFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfHighDeepFreeze"] = 67108864] = "lsfHighDeepFreeze";
    })(RippleStateFlags || (exports.RippleStateFlags = RippleStateFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/SignerList.js
var require_SignerList = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/SignerList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerListFlags = void 0;
    var SignerListFlags;
    (function(SignerListFlags2) {
      SignerListFlags2[SignerListFlags2["lsfOneOwnerCount"] = 65536] = "lsfOneOwnerCount";
    })(SignerListFlags || (exports.SignerListFlags = SignerListFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/index.js
var require_ledger = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/ledger/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerListFlags = exports.RippleStateFlags = exports.OfferFlags = exports.NEGATIVE_UNL_ID = exports.FEE_SETTINGS_ID = exports.AMENDMENTS_ID = exports.AccountRootFlags = void 0;
    var AccountRoot_1 = require_AccountRoot();
    Object.defineProperty(exports, "AccountRootFlags", { enumerable: true, get: function() {
      return AccountRoot_1.AccountRootFlags;
    } });
    var Amendments_1 = require_Amendments();
    Object.defineProperty(exports, "AMENDMENTS_ID", { enumerable: true, get: function() {
      return Amendments_1.AMENDMENTS_ID;
    } });
    var FeeSettings_1 = require_FeeSettings();
    Object.defineProperty(exports, "FEE_SETTINGS_ID", { enumerable: true, get: function() {
      return FeeSettings_1.FEE_SETTINGS_ID;
    } });
    var NegativeUNL_1 = require_NegativeUNL();
    Object.defineProperty(exports, "NEGATIVE_UNL_ID", { enumerable: true, get: function() {
      return NegativeUNL_1.NEGATIVE_UNL_ID;
    } });
    var Offer_1 = require_Offer();
    Object.defineProperty(exports, "OfferFlags", { enumerable: true, get: function() {
      return Offer_1.OfferFlags;
    } });
    var RippleState_1 = require_RippleState();
    Object.defineProperty(exports, "RippleStateFlags", { enumerable: true, get: function() {
      return RippleState_1.RippleStateFlags;
    } });
    var SignerList_1 = require_SignerList();
    Object.defineProperty(exports, "SignerListFlags", { enumerable: true, get: function() {
      return SignerList_1.SignerListFlags;
    } });
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/methods/index.js
var require_methods = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/methods/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/index.js
var require_models = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = exports.LedgerEntry = void 0;
    exports.LedgerEntry = __importStar(require_ledger());
    var flags_1 = require_flags();
    Object.defineProperty(exports, "parseAccountRootFlags", { enumerable: true, get: function() {
      return flags_1.parseAccountRootFlags;
    } });
    Object.defineProperty(exports, "setTransactionFlagsToNumber", { enumerable: true, get: function() {
      return flags_1.setTransactionFlagsToNumber;
    } });
    Object.defineProperty(exports, "convertTxFlagsToNumber", { enumerable: true, get: function() {
      return flags_1.convertTxFlagsToNumber;
    } });
    Object.defineProperty(exports, "parseTransactionFlags", { enumerable: true, get: function() {
      return flags_1.parseTransactionFlags;
    } });
    __exportStar(require_methods(), exports);
    __exportStar(require_transactions(), exports);
    __exportStar(require_common(), exports);
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/utils/index.js
var require_utils10 = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
    var utils_1 = require_browser();
    function randomEntropy() {
      return (0, utils_1.randomBytes)(16);
    }
    exports.randomEntropy = randomEntropy;
    function calculateChecksum(position, value) {
      return value * (position * 2 + 1) % 9;
    }
    exports.calculateChecksum = calculateChecksum;
    function checkChecksum(position, value, checksum) {
      let normalizedChecksum;
      let normalizedValue;
      if (typeof value === "string") {
        if (value.length !== 6) {
          throw new Error("value must have a length of 6");
        }
        normalizedChecksum = parseInt(value.slice(5), 10);
        normalizedValue = parseInt(value.slice(0, 5), 10);
      } else {
        if (typeof checksum !== "number") {
          throw new Error("checksum must be a number when value is a number");
        }
        normalizedChecksum = checksum;
        normalizedValue = value;
      }
      return normalizedValue * (position * 2 + 1) % 9 === normalizedChecksum;
    }
    exports.checkChecksum = checkChecksum;
    function entropyToSecret(entropy) {
      const len = new Array(Math.ceil(entropy.length / 2));
      const chunks = Array.from(len, (_a, chunk) => {
        const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);
        const no = parseInt((0, utils_1.bytesToHex)(buffChunk), 16);
        const fill = "0".repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(chunk, no));
      });
      if (chunks.length !== 8) {
        throw new Error("Chucks must have 8 digits");
      }
      return chunks;
    }
    exports.entropyToSecret = entropyToSecret;
    function randomSecret() {
      return entropyToSecret(randomEntropy());
    }
    exports.randomSecret = randomSecret;
    function secretToEntropy(secret) {
      return (0, utils_1.concat)(secret.map((chunk, i) => {
        const no = Number(chunk.slice(0, 5));
        const checksum = Number(chunk.slice(5));
        if (chunk.length !== 6) {
          throw new Error("Invalid secret: number invalid");
        }
        if (!checkChecksum(i, no, checksum)) {
          throw new Error("Invalid secret part: checksum invalid");
        }
        const hex = `0000${no.toString(16)}`.slice(-4);
        return (0, utils_1.hexToBytes)(hex);
      }));
    }
    exports.secretToEntropy = secretToEntropy;
    function parseSecretString(secret) {
      const normalizedSecret = secret.replace(/[^0-9]/gu, "");
      if (normalizedSecret.length !== 48) {
        throw new Error("Invalid secret string (should contain 8 blocks of 6 digits");
      }
      return Array.from(new Array(8), (_a, index) => {
        return normalizedSecret.slice(index * 6, (index + 1) * 6);
      });
    }
    exports.parseSecretString = parseSecretString;
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/schema/Account.js
var require_Account = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/schema/Account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var ripple_keypairs_1 = require_dist3();
    var utils_1 = require_utils10();
    var Account = class {
      constructor(secretNumbers) {
        this._account = {
          familySeed: "",
          address: "",
          keypair: {
            publicKey: "",
            privateKey: ""
          }
        };
        if (typeof secretNumbers === "string") {
          this._secret = (0, utils_1.parseSecretString)(secretNumbers);
        } else if (Array.isArray(secretNumbers)) {
          this._secret = secretNumbers;
        } else if (secretNumbers instanceof Uint8Array) {
          this._secret = (0, utils_1.entropyToSecret)(secretNumbers);
        } else {
          this._secret = (0, utils_1.randomSecret)();
        }
        validateLengths(this._secret);
        this.derive();
      }
      getSecret() {
        return this._secret;
      }
      getSecretString() {
        return this._secret.join(" ");
      }
      getAddress() {
        return this._account.address;
      }
      getFamilySeed() {
        return this._account.familySeed;
      }
      getKeypair() {
        return this._account.keypair;
      }
      toString() {
        return this.getSecretString();
      }
      derive() {
        try {
          const entropy = (0, utils_1.secretToEntropy)(this._secret);
          this._account.familySeed = (0, ripple_keypairs_1.generateSeed)({ entropy });
          this._account.keypair = (0, ripple_keypairs_1.deriveKeypair)(this._account.familySeed);
          this._account.address = (0, ripple_keypairs_1.deriveAddress)(this._account.keypair.publicKey);
        } catch (error) {
          let message = "Unknown Error";
          if (error instanceof Error) {
            message = error.message;
          }
          throw new Error(message);
        }
      }
    };
    exports.Account = Account;
    function validateLengths(secretNumbers) {
      if (secretNumbers.length !== 8) {
        throw new Error("Secret must have 8 numbers");
      }
      secretNumbers.forEach((num) => {
        if (num.length !== 6) {
          throw new Error("Each secret number must be 6 digits");
        }
      });
    }
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@1.0.0/node_modules/@xrplf/secret-numbers/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Account(), exports);
    __exportStar(require_utils10(), exports);
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js
var require_walletFromSecretNumbers = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletFromSecretNumbers = void 0;
    var secret_numbers_1 = require_dist4();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var _1 = require_Wallet();
    function walletFromSecretNumbers(secretNumbers, opts) {
      var _a;
      const secret = new secret_numbers_1.Account(secretNumbers).getFamilySeed();
      const updatedOpts = {
        masterAddress: void 0,
        algorithm: void 0
      };
      if (opts === void 0) {
        updatedOpts.algorithm = ECDSA_1.default.secp256k1;
      } else {
        updatedOpts.masterAddress = opts.masterAddress;
        updatedOpts.algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : ECDSA_1.default.secp256k1;
      }
      return _1.Wallet.fromSecret(secret, updatedOpts);
    }
    exports.walletFromSecretNumbers = walletFromSecretNumbers;
  }
});

// node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/index.js
var require_npm = __commonJS({
  "node_modules/.pnpm/xrpl@4.2.5/node_modules/xrpl/dist/npm/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rfc1751MnemonicToKey = exports.keyToRFC1751Mnemonic = exports.walletFromSecretNumbers = exports.Wallet = exports.ECDSA = exports.Client = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    __exportStar(require_models(), exports);
    __exportStar(require_utils8(), exports);
    var ECDSA_1 = require_ECDSA();
    Object.defineProperty(exports, "ECDSA", { enumerable: true, get: function() {
      return __importDefault(ECDSA_1).default;
    } });
    __exportStar(require_errors(), exports);
    var Wallet_1 = require_Wallet();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return Wallet_1.Wallet;
    } });
    var walletFromSecretNumbers_1 = require_walletFromSecretNumbers();
    Object.defineProperty(exports, "walletFromSecretNumbers", { enumerable: true, get: function() {
      return walletFromSecretNumbers_1.walletFromSecretNumbers;
    } });
    var rfc1751_1 = require_rfc1751();
    Object.defineProperty(exports, "keyToRFC1751Mnemonic", { enumerable: true, get: function() {
      return rfc1751_1.keyToRFC1751Mnemonic;
    } });
    Object.defineProperty(exports, "rfc1751MnemonicToKey", { enumerable: true, get: function() {
      return rfc1751_1.rfc1751MnemonicToKey;
    } });
    __exportStar(require_signer(), exports);
  }
});
export default require_npm();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=xrpl.js.map
